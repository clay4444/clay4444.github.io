---
title: 数据结构之图
categories:
  - 数据结构
abbrlink: f932ba85
date: 2018-01-29 10:26:57
---

### 概念

图 ( Graph )是由顶点的有穷非空集合和顶点之间的边的集合组成，通常表示为：G (V, E) 其中，G表示一个图，V是图G中顶点的集合，E是图中边的集合。

<br/>

### 图的特性

{% asset_img 图的特性.png %}

<br/>

### 无向图

{% asset_img 无向图.png %}

<br/>

### 有向图

{% asset_img 有向图.png %}

<br/>

### 图的权

{% asset_img 图的权.png %}

<br/>

### 连通图

{% asset_img 连通图.png %}

<br/>

### 度

{% asset_img 图的度.png %}

<br/>

### 图的存储结构

{% asset_img 图的存储结构.png %}

<br/>

### 邻接矩阵

{% asset_img 邻接矩阵.png %}

**一个一维数组存储图中的顶点信息**

**一个二维数组存储图中的边或弧的信息**

<br/>

### 无向图的邻接矩阵

{% asset_img 无向图的邻接矩阵.png %}

<br/>

### 有向图的邻接矩阵

{% asset_img 有向图的邻接矩阵.png %}

<br/>

### 带权的邻接矩阵

{% asset_img 带权的邻接矩阵.png %}

<br/>

###  邻接表

#### 无向图的邻接表(散列表)

{% asset_img 无向图的邻接表.png %}

<br/>

#### 有向图的邻接表

{% asset_img 有向图的邻接表.png %}

<br/>

#### 逆邻接表

{% asset_img 逆邻接表.png %}

<br/>

#### 带权值的邻接表

{% asset_img 带权值的邻接表.png %}

<br/>

### 邻接矩阵实现图：代码

~~~java
public class Graph {
  private int vertexSize;//顶点数量
  private int [] vertexs;//顶点数组 	
  private int[][]  matrix;
  private static final int MAX_WEIGHT = 1000;
  private boolean [] isVisited;
  public Graph(int vertextSize){
    this.vertexSize = vertextSize;
    matrix = new int[vertextSize][vertextSize];
    vertexs = new int[vertextSize];
    for(int i = 0;i<vertextSize;i++){
      vertexs[i] = i;
    }
    isVisited = new boolean[vertextSize];
  }

  /**
	 * 获取某个顶点的出度
	 * @return
	 */
  public int getOutDegree(int index){
    int degree = 0;
    for(int j = 0;j<matrix[index].length;j++){
      int weight = matrix[index][j];
      if(weight!=0&&weight!=MAX_WEIGHT){
        degree++;
      }
    }
    return degree;
  }

  /**
	 * 入度
	 * @return
	 */

  /**
	 * 获取某个顶点的第一个邻接点
	 */
  public int getFirstNeighbor(int index){
    for(int j = 0;j<vertexSize;j++){
      if(matrix[index][j]>0&&matrix[index][j]<MAX_WEIGHT){
        return j;
      }
    }
    return -1;
  }

  /**
	 * 获取两个顶点之间的权值
	 * @return
	 */
  public int getWeight(int v1,int v2){
    int weight = matrix[v1][v2];
    return weight == 0?0:(weight == MAX_WEIGHT?-1:weight);
  }


  public int[] getVertexs() {
    return vertexs;
  }

  public void setVertexs(int[] vertexs) {
    this.vertexs = vertexs;
  }

  public static void main(String [] args){
    Graph graph = new Graph(9);

    int [] a1 = new int[]{0,10,MAX_WEIGHT,MAX_WEIGHT,MAX_WEIGHT,11,MAX_WEIGHT,MAX_WEIGHT,MAX_WEIGHT};
    int [] a2 = new int[]{10,0,18,MAX_WEIGHT,MAX_WEIGHT,MAX_WEIGHT,16,MAX_WEIGHT,12};
    int [] a3 = new int[]{MAX_WEIGHT,MAX_WEIGHT,0,22,MAX_WEIGHT,MAX_WEIGHT,MAX_WEIGHT,MAX_WEIGHT,8};
    int [] a4 = new int[]{MAX_WEIGHT,MAX_WEIGHT,22,0,20,MAX_WEIGHT,MAX_WEIGHT,16,21};
    int [] a5 = new int[]{MAX_WEIGHT,MAX_WEIGHT,MAX_WEIGHT,20,0,26,MAX_WEIGHT,7,MAX_WEIGHT};
    int [] a6 = new int[]{11,MAX_WEIGHT,MAX_WEIGHT,MAX_WEIGHT,26,0,17,MAX_WEIGHT,MAX_WEIGHT};
    int [] a7 = new int[]{MAX_WEIGHT,16,MAX_WEIGHT,MAX_WEIGHT,MAX_WEIGHT,17,0,19,MAX_WEIGHT};
    int [] a8 = new int[]{MAX_WEIGHT,MAX_WEIGHT,MAX_WEIGHT,16,7,MAX_WEIGHT,19,0,MAX_WEIGHT};
    int [] a9 = new int[]{MAX_WEIGHT,12,8,21,MAX_WEIGHT,MAX_WEIGHT,MAX_WEIGHT,MAX_WEIGHT,0};

    graph.matrix[0] = a1;
    graph.matrix[1] = a2;
    graph.matrix[2] = a3;
    graph.matrix[3] = a4;
    graph.matrix[4] = a5;
    graph.matrix[5] = a6;
    graph.matrix[6] = a7;
    graph.matrix[7] = a8;
    graph.matrix[8] = a9;

    //		int degree = graph.getOutDegree(4);
    //		System.out.println("vo的出度:"+degree);
    //		System.out.println("权值："+graph.getWeight(2,3));
    //		graph.depthFirstSearch();
    //		graph.broadFirstSearch();
    graph.prim();
  }
}
~~~



### 图的遍历

{% asset_img 图的遍历.png %}

#### 深度优先遍历

翻看目录查找资料。每个文件夹的子文件夹的遍历方式

类似前序遍历

- 整体思想：类似于树的前序遍历，先找到最靠近它的第一个节点，如果有这个节点的话，先遍历，然后再以这个节点为根继续往下找，但是与此同时要注意：考虑一下回溯的问题，因为可能出现某一点找不到后面的这个点了，但是此时不一定是并不存在，可能在之前已经遍历的点中，的第一个节点的后面。所以要用while循环，而且还要记得遍历完一个节点之后，除了要递归遍历它的子节点之外，还要找这个节点的下一个节点。

{% asset_img 深度优先遍历.png %}

<br/>

{% asset_img DFS的临接矩阵.png %}

~~~java
	/**
	 * 获取某个顶点的第一个邻接点
	 */
public int getFirstNeighbor(int index){
  for(int j = 0;j<vertexSize;j++){
    if(matrix[index][j]>0&&matrix[index][j]<MAX_WEIGHT){
      return j;
    }
  }
  return -1;
}

	/**
	 * 根据前一个邻接点的下标来取得下一个邻接点
	 * @param v 表示要找的顶点
	 * @param index 表示该顶点相对于哪个邻接点去获取下一个邻接点
	 */
public int getNextNeighbor(int v,int index){
  for(int j = index+1;j<vertexSize;j++){
    if(matrix[v][j]>0&&matrix[v][j]<MAX_WEIGHT){
      return j;
    }
  }
  return -1;
}

	/**
	 * 真正的深度优先搜索
	 * @param index 要从哪个节点开始遍历
	 */
private void depthFirstSearch(int index) {

  isVisited[index] = true;
  int w = getFirstNeighbor(index);

  while(w != -1){
    if(!isVisited[w]){  //说明没有被遍历过
      System.out.println(" 遍历到了 " + w + "节点");
      depthFirstSearch(w);
    }

    w = getNextNeighbor(index,w);// 如果真的遍历到-1了，就说明遍历到v7了。因为只有v7的临接点都已经被遍历了
    //此时返回v6，v6再执行此函数，也是-1，返回v5，v5也返回-1。递归一步步返回。直到返回到v3的时候，找到v8，遍历完成，
    //v6 相对于v7的下一个节点    -1
    //v5 相对于v6的下一个节点	-1
    //v4 相对于v5的下一个节点	v7 已经被遍历了，v4 相对于v7的下一个节点，-1
    //v3 相对于v4的下一个节点	v7 已经被遍历了  v3 相对于v7的下一个节点   v8 完成
  }
}

	/**
	 * 对外公开的深度优先遍历
	 */

public void depthFirstSearch(){
  isVisited = new boolean[vertexSize];
  for(int i = 0;i<vertexSize;i++){
    if(!isVisited[i]){
      System.out.println("访问到了："+i+"顶点");
      depthFirstSearch(i);
    }
  }
  isVisited = new boolean[vertexSize];
}
~~~

<br/>

#### 广度优先遍历 

目录搜索东西，先每一层的找，类似层序遍历

深度就是往下面走，广度就是横着走，

{% asset_img 广度优先遍历的思想.png %}

- 一开始先把第一个放进队列，在第一层while循环中先弹出队列的第一个。然后再利用一个while循环，开始找它的子节点，把它的所有临接节点先遍历，再放进队列，这样下一个while循环就会把队列的头一个元素删除，再把它的所有临接节点都放进来，以此循环。

代码：

~~~java
	/**
	 * 实现广度优先遍历
	 * @param i
	 */
//第一次外层while循环完成之后，还剩一个v1，v5，第二次外层while循环，先弹出v1，并且通过内层while循环，
//获取v1所有的临接节点。并添加到队列中，第三次外层while循环，弹出v5，并且通过内层while循环，获取v5所有的临接节点。并添加到队列中
//此时队列中还有2，6，8，4
//通过外层whil循环，把v2弹出去，通过内存while循环，把v2的所有临接节点(只剩v3)添加到队列中，此时队列中是6，8，4，3
//通过外层whil循环，把v6弹出去，通过内存while循环，把v6的所有临接节点(只剩v7)添加到队列中，此时队列中是8，4，3，7
//下面的过程，由于，所有节点都被遍历过了，不会再被遍历了。只是弹出队列而已。

	/**
	 * 从v0开始，先弹出v0，然后获取v0的的下一层的所有临界点，添加到队列中，再弹出下一层的
	 * @param i
	 */
private void broadFirstSearch(int i) {
  int u,w;
  LinkedList<Integer> queue = new LinkedList<Integer>();
  System.out.println("访问到："+i+"顶点");
  isVisited[i] = true;
  queue.add(i);//第一次把v0加到队列 
  while(!queue.isEmpty()){
    u = (Integer)(queue.removeFirst()).intValue();
    w = getFirstNeighbor(u);
    while(w!=-1){		 //通过这个while循环，就可以把所有的u这个顶点里面所有的w，
      //也就是它所有的临接节点，同一层次的。都加入到队列当中去。
      if(!isVisited[w]){
        System.out.println("访问到了："+w+"顶点");
        isVisited[w] = true;
        queue.add(w);
      }
      w = getNextNeighbor(u, w);
    }
  }
}							
~~~

<br/>

### 最小生成树

{% asset_img 最小生成树的问题.png %}

<br/>

### 方案：

{% asset_img 最小生成数的概念.png %}

<br/>

### 找联通网的最小生成树：普利姆算法和克鲁斯卡尔算法

