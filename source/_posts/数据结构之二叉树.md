---
title: 数据结构之二叉树
categories:
  - 数据结构
abbrlink: 39aa6912
date: 2018-01-26 12:41:53
---

## 二叉树的建立

为了唯一确定一颗二叉树的结构，除了把二叉树补成完全二叉树之外，还需要把叶子节点补充补充两个子节点，否则无法唯一确定一个二叉树的结构，示例：

{% asset_img 唯一确定一颗二叉树.png %}

<br/>

### 通过前序遍历的数据序列反向生成二叉树

~~~java
public class BinaryTree {

  private TreeNode root = null;

  public BinaryTree(){
    root = new TreeNode(1, "A");
  }

  /**
	 * 构建一颗二叉树
	 * 				A
	 *  	B				C
	 * D		E					F
	 * 
	 */
  public void createBinaryTree(){

    TreeNode nodeB = new TreeNode(2, "B");
    TreeNode nodeC = new TreeNode(3, "C");
    TreeNode nodeD = new TreeNode(4, "D");
    TreeNode nodeE = new TreeNode(5, "E");
    TreeNode nodeF = new TreeNode(6, "F");

    root.leftChild = nodeB;
    root.rightChild = nodeC;

    nodeB.leftChild = nodeD;
    nodeB.rightChild = nodeE;

    nodeC.rightChild = nodeF;
  }

  /**
	 * 通过前序遍历的数据序列反向生成二叉树
	 * 	 * 				A
	 *  	B				C
	 * D		E					F
	 * 
	 * ABD##E##C#F##
	 */
  public void createBinaryTreePre(ArrayList<String> data){
    createBinaryTree(data.size(),data);
  }

  private TreeNode createBinaryTree(int size, ArrayList<String> data) {
    String d = data.get(0);
    TreeNode node;
    int index = size - data.size();
    if(d.equals("#")){
      node  =null;
      data.remove(0);
      return node;
    }

    node = new TreeNode(index, d);
    if(index == 0){
      //创建根节点
      root = node;
    }
    data.remove(0);
    node.leftChild = createBinaryTree(size,data);
    node.rightChild = createBinaryTree(size,data);

    return node;
  }


  public class TreeNode{

    private int index;
    private String data;
    private TreeNode leftChild;
    private TreeNode rightChild;

    public TreeNode(int index, String data){
      this.index = index;
      this.data = data;
      leftChild = null;
      rightChild = null;
    }

    public int getIndex() {
      return index;
    }

    public void setIndex(int index) {
      this.index = index;
    }

    public String getData() {
      return data;
    }

    public void setData(String data) {
      this.data = data;
    }


  }

  public static void main(String[] args) {
    BinaryTree tree = new BinaryTree();

    ArrayList<String> data = new ArrayList<>();
    String[] s = {"A","B","D","#","#","E","#","#","C","#","F","#","#"};

    for (String string : s) {
      data.add(string);
    }

    tree.createBinaryTree(data.size(), data);
    tree.preOrder(tree.root);
  }
}
~~~

<br/>

### 一般树转化成二叉树

{% asset_img 一般树转化成二叉树.png %}

<br/>

### 森林转化成二叉树

{% asset_img 森林转化成二叉树.png %}

{% asset_img 森林转化成二叉树二.png %}

<br/>

### 二叉树转化成普通的树

{% asset_img 二叉树转化为普通的树.png %}

{% asset_img 二叉树转化为普通的树二.png %}

<br/>

### 赫夫曼树----数据压缩领域

引出：不同的学生的成绩对应不同的等级，不及格，及格，普通，优秀，等。

简化成用两棵二叉树来表示的话就是：

{% asset_img 赫夫曼树一.png %}

<br/>

### 赫夫曼树的定义

{% asset_img 赫夫曼树的定义.png %}

节点的路径长度是从树中一个节点到另一个节点之间的分支。

树的路径长度就是从树根到每一节点的路径长度之和。

节点的带权的路径长度为该节点到树根之间的路径长度与节点上权的乘机。

树的带权路径长度就是树中所有叶子节点的带权路径长度之和。

带权路径长度称为     WPL

带权路径长度最小的二叉树叫做赫夫曼树

<br/>

### 赫夫曼树的构造

{% asset_img 赫夫曼树的构造一.png %}

{% asset_img 赫夫曼树的构造二.png %}

核心思想：尽量让权值小的距离根节点远一点，权值小的放左边，权值大的放右边，

做法：按照权值从小到大排列，然后两个两个的组成新的一个，再和后面一个比较大小，小的放在左边，大的放右边，比较完后重新组成一个，重复此步骤。

<br/>

### 赫夫曼树的应用：赫夫曼编码

{% asset_img 赫夫曼编码.png %}

{% asset_img 赫夫曼编码二.png %}

<br/>

## 查找二叉树

### 查找二叉树的构建：put函数

基本思想：

​	先找到传进来的这个节点的要挂载的父节点，然后判断传进来的节点和这个要挂载的父节点的大小，如果传进来的节点大，就把它挂载到找到的父节点的右边，反之，挂载到左边。

​	首先设置一个node变量，代表最后查找到的传进来的这个数字的父节点，然后就要开始查找这样的节点了，查找的基本过程就是最开始从根节点开始查找，然后每次判断传进来的数字和当前正在遍历的这个node节点的大小，如果传进来的数字大，说明传进来的这个新节点就要挂在当前这个node节点的右子节点上。所以就把当前这个node节点设置为它的右子节点，反之，就把当前节点设置为它的左子节点，那么终止的条件是找不到这样一个节点了，此时说明：最后一次遍历的node节点就是传进来的这个节点的父节点。
​	因为最后的终止条件是node节点为空了，那么我们就需要一个临时节点，来保存我们最后一次遍历时找到的内个节点，也就是传进来的节点要挂载的节点。它也就是我们传进来的节点的父节点。

​	其实这个二叉树中完全可以不要parent这个属性的。

~~~~java
public class SearchBinaryTree {

  public static void main(String[] args) {
    SearchBinaryTree tree = new SearchBinaryTree();

    int[] intArray = new int[]{50,30,20,44,88,33,87,16,7,77};

    for (int i : intArray) {
      tree.put(i);
    }

    tree.minOrder(tree.root);
  }

  private TreeNode root;

  public SearchBinaryTree() {
    super();
  }

  public void minOrder(TreeNode node){

    if(node == null){
      return;
    }else{
      minOrder(node.leftChild);
      System.out.println(node.data);
      minOrder(node.rightChild);
    }
  }

  /**
	 * 创建查找二叉树，添加节点
	 * @author clay
	 *
	 */
  public TreeNode put(int data){

    TreeNode node = null;
    TreeNode parent = null;

    if(root == null){
      node = new TreeNode(0, data);
      root = node;
      return node;
    }

    node = root;
    while(node != null){
      parent = node;

      if(data > node.data){
        node = node.rightChild;
      }else if(data < node.data){
        node = node.leftChild;
      }else{
        return node;
      }
    }
    //表示将此节点添加到相应的位置
    node = new TreeNode(0, data);
    if(data<parent.data){
      parent.leftChild = node;
    }else{
      parent.rightChild = node;
    }

    node.parent = parent;
    return node;
  }


  class TreeNode{
    private int key;
    private int data;
    private TreeNode leftChild;
    private TreeNode rightChild;
    private TreeNode parent;
    public TreeNode(int key, int data) {
      super();
      this.key = key;
      this.data = data;
      this.leftChild = null;
      this.rightChild = null;
      this.parent = null;
    }
    public int getKey() {
      return key;
    }
    public void setKey(int key) {
      this.key = key;
    }
    public int getData() {
      return data;
    }
    public void setData(int data) {
      this.data = data;
    }
    public TreeNode getLeftChild() {
      return leftChild;
    }
    public void setLeftChild(TreeNode leftChild) {
      this.leftChild = leftChild;
    }
    public TreeNode getRightChild() {
      return rightChild;
    }
    public void setRightChild(TreeNode rightChild) {
      this.rightChild = rightChild;
    }
    public TreeNode getParent() {
      return parent;
    }
    public void setParent(TreeNode parent) {
      this.parent = parent;
    }
  }
}
~~~~

<br/>

### 查找二叉树的删除

{% asset_img 查找二叉树的后继节点说明.png %}

注意看上图：前三种删除情况都比较好删除，但是要注意第四种删除情况，比如要删除54节点的后继节点，不一定就是要删除56节点，而是要删除55节点。。。。

<br/>

注意二：比如说要删除54节点，并且已经找到了它的后继节点是55节点，此时要做的操作就是把55号节点的数据直接赋给54节点，再把55节点删除即可，这样做的原因就是因为是按照顺序遍历或者说排序的，这是根据二叉树的性质得来的，当按照中序遍历一颗二叉树的时候，如果数字是从小到大排列的，那么它一定是二叉查找树，或者说如果是二叉查找树，当中序遍历它的时候，一定是从小到大排列的。所以，把后面的一个节点删除，再把它赋值给它的前面一个节点，再中序遍历它一定是还是从小到大排列的，所以一定还是二叉查找树。

<br/>

注意三：找一个节点的后继节点的时候，这个后继节点一定是叶子节点，还拿上述的例子举例，加入说要删除54节点，按照上图所示，55节点就是它的后继节点，但是如果55号节点还有叶子节点，那么节点的数据肯定在54和55之间，此时，后继节点就是55节点后面的叶子节点，后面依次类推。比如说50的后继节点就是52。所以说，如果找到了后继节点，直接删除即可。

<br/>

找一个节点后继节点的步骤：

1. 判断这个节点有没有右子节点，如果这个节点存在右子节点，就去找它的右子树中的最小关键子节点，也就	是从右子树中一直往左节点找，这样做的原因可以看上图，根据二叉树的性质，如果要找50的后继节点，就从以60为根的这棵左子树一直往左找，即62.

<br/>

2. 但是要注意的是：不是一个节点没有右子树，就说明他没有后继节点，整棵二叉查找树中，只有最后一个节点没有后继节点，其他所有节点都有后继节点，比如46的后继节点是50。

<br/>

2. 没有右子树的当前node节点的后继节点的查找步骤是：从当前的node节点一直往上循环找，利用一个parent临时节点，当发现当前的node节点不是当前parent节点的右子树的时候，此时就说明这个parent临时节点就是最开始的node节点的后继节点，原因是：当我们找一个节点的前驱节点的时候，就是从它的左子树中一直往右找，其实这也是根据二叉树的性质来的，即中序遍历的时候，数字从小到大排列，所以一颗左子树的最右边的叶子节点一定是当前这棵左子树的父节点的前驱节点。反之，一颗左子树的最右边的叶子节点的后继节点肯定是这棵左子树的父节点。

~~~java
public class SearchBinaryTree {

  public static void main(String[] args) throws Throwable {
    SearchBinaryTree tree = new SearchBinaryTree();

    int[] intArray = new int[]{50,30,20,44,88,33,87,16,7,77};

    for (int i : intArray) {
      tree.put(i);
    }
    tree.minOrder(tree.root);

    tree.deleteNode(44);


    tree.minOrder(tree.root);
  }

  private TreeNode root;

  public SearchBinaryTree() {
    super();
  }

  public void minOrder(TreeNode node){

    if(node == null){
      return;
    }else{
      minOrder(node.leftChild);
      System.out.println(node.data);
      minOrder(node.rightChild);
    }
  }

  /**
	 * 创建查找二叉树，添加节点
	 * @author clay
	 *
	 */
  public TreeNode put(int data){

    TreeNode node = null;
    TreeNode parent = null;

    if(root == null){
      node = new TreeNode(0, data);
      root = node;
      return node;
    }

    node = root;
    while(node != null){
      parent = node;

      if(data > node.data){
        node = node.rightChild;
      }else if(data < node.data){
        node = node.leftChild;
      }else{
        return node;
      }
    }
    //表示将此节点添加到相应的位置
    node = new TreeNode(0, data);
    if(data<parent.data){
      parent.leftChild = node;
    }else{
      parent.rightChild = node;
    }

    node.parent = parent;
    return node;
  }

  /**
	 * 创建查找二叉树，删除节点
	 * @author clay
	 * @throws Throwable 
	 *
	 */
  public void deleteNode(int key) throws Throwable{
    TreeNode node = searchNode(key);

    if(node == null){
      throw new Exception("该节点无法找到");
    }else{
      //删除该节点
      delete(node);
    }
  }

  /**
	 * 删除一个节点
	 */
  private void delete(TreeNode node) throws Exception {

    if(node == null){
      throw new Exception("该节点无法找到");
    }else{
      TreeNode parent = node.parent;

      if(node.leftChild == null && node.rightChild == null){
        if(node == parent.leftChild){
          parent.leftChild = null;
        }else{
          parent.rightChild = null;
        }

        return;
      }

      if(node.leftChild != null && node.rightChild == null){
        if(node == parent.leftChild){
          parent.leftChild = node.leftChild;
        }else{
          parent.rightChild = node.leftChild;
        }
        return;
      }

      if(node.leftChild == null && node.rightChild != null){
        if(node == parent.leftChild){
          parent.leftChild = node.rightChild;
        }else{
          parent.rightChild = node.rightChild;
        }
        return;
      }

      TreeNode next = getNextNode(node);
      //后继节点一定是叶子节点
      delete(next);
      node.data = next.data;
    }
  }

  //找一个节点的后继节点
  private TreeNode getNextNode(TreeNode node) {

    if(node == null){
      return null;
    }else{
      if(node.rightChild != null){
        //找某节点的最小关键字节点
        return getMinTreeNode(node.rightChild);
      }else{
        //不是一个节点没有右子树，就说明他没有后继节点，
        TreeNode parent = node.parent;
        while(parent != null && node == parent.rightChild){
          node = parent;
          parent = parent.parent;
        }

        return parent;
      }
    }
  }

  /**
	 * 找某节点的最小关键字节点
	 */
  private TreeNode getMinTreeNode(TreeNode node) {

    if(node == null){
      return null;
    }else{
      while(node.leftChild != null){
        node = node.leftChild;
      }
    }

    return node;
  }

  /**
	 * 根据数据查找节点
	 */
  private TreeNode searchNode(int data) {

    TreeNode node = root;

    if(node == null){

      return null;
    }else{
      while(node != null&&data!= node.data){
        if(data > node.data){
          node = node.rightChild;
        }else{
          node = node.leftChild;
        }
      }
    }

    return node;
  }

  class TreeNode{
    private int key;
    private int data;
    private TreeNode leftChild;
    private TreeNode rightChild;
    private TreeNode parent;
    public TreeNode(int key, int data) {
      super();
      this.key = key;
      this.data = data;
      this.leftChild = null;
      this.rightChild = null;
      this.parent = null;
    }
    public int getKey() {
      return key;
    }
    public void setKey(int key) {
      this.key = key;
    }
    public int getData() {
      return data;
    }
    public void setData(int data) {
      this.data = data;
    }
    public TreeNode getLeftChild() {
      return leftChild;
    }
    public void setLeftChild(TreeNode leftChild) {
      this.leftChild = leftChild;
    }
    public TreeNode getRightChild() {
      return rightChild;
    }
    public void setRightChild(TreeNode rightChild) {
      this.rightChild = rightChild;
    }
    public TreeNode getParent() {
      return parent;
    }
    public void setParent(TreeNode parent) {
      this.parent = parent;
    }
  }
}
~~~

<br/>

### 二叉查找树的查找

查找的过程只是简单的从根节点开始遍历而已，遍历的过程和构建二叉查找树时的循环过程相同，	只需要注意循环的条件是node节点不为空并且传进来的数字和遍历的node节点的数据不相等。此时的终止条件就是找不到node节点或者已经找到node节点都会触发循环终止的条件。

~~~java
public class SearchBinaryTree {

  public static void main(String[] args) {
    SearchBinaryTree tree = new SearchBinaryTree();

    int[] intArray = new int[]{50,30,20,44,88,33,87,16,7,77};

    for (int i : intArray) {
      tree.put(i);
    }

    tree.minOrder(tree.root);
  }

  private TreeNode root;

  public SearchBinaryTree() {
    super();
  }

  public void minOrder(TreeNode node){

    if(node == null){
      return;
    }else{
      minOrder(node.leftChild);
      System.out.println(node.data);
      minOrder(node.rightChild);
    }
  }

  /**
	 * 创建查找二叉树，添加节点
	 * @author clay
	 *
	 */
  public TreeNode put(int data){

    TreeNode node = null;
    TreeNode parent = null;

    if(root == null){
      node = new TreeNode(0, data);
      root = node;
      return node;
    }

    node = root;
    while(node != null){
      parent = node;

      if(data > node.data){
        node = node.rightChild;
      }else if(data < node.data){
        node = node.leftChild;
      }else{
        return node;
      }
    }
    //表示将此节点添加到相应的位置
    node = new TreeNode(0, data);
    if(data<parent.data){
      parent.leftChild = node;
    }else{
      parent.rightChild = node;
    }

    node.parent = parent;
    return node;
  }

  /**
	 * 根据数据查找节点
	 */
  private TreeNode searchNode(int data) {

    TreeNode node = root;

    if(node == null){

      return null;
    }else{
      while(node != null&&data!= node.data){
        if(data > node.data){
          node = node.rightChild;
        }else{
          node = node.leftChild;
        }
      }
    }

    return node;
  }

  class TreeNode{
    private int key;
    private int data;
    private TreeNode leftChild;
    private TreeNode rightChild;
    private TreeNode parent;
    public TreeNode(int key, int data) {
      super();
      this.key = key;
      this.data = data;
      this.leftChild = null;
      this.rightChild = null;
      this.parent = null;
    }
    public int getKey() {
      return key;
    }
    public void setKey(int key) {
      this.key = key;
    }
    public int getData() {
      return data;
    }
    public void setData(int data) {
      this.data = data;
    }
    public TreeNode getLeftChild() {
      return leftChild;
    }
    public void setLeftChild(TreeNode leftChild) {
      this.leftChild = leftChild;
    }
    public TreeNode getRightChild() {
      return rightChild;
    }
    public void setRightChild(TreeNode rightChild) {
      this.rightChild = rightChild;
    }
    public TreeNode getParent() {
      return parent;
    }
    public void setParent(TreeNode parent) {
      this.parent = parent;
    }
  }
}
~~~

<br/>

### 平衡二叉排序树           AVL树

{% asset_img AVL树.png %}

也就是说平衡因子（BF）只能是0，1，-1

<br/>

### 为什么需要它

因为不同的数字的排列顺序所构造的二叉排序树，查找效率会差别很大，一棵不平衡的树，甚至还不如不构造出一棵二叉树

例如： 5 9 3 7 1 4 6 8 2

{% asset_img 593714682.png %}

1 2 3 4 5 6 7 8 9

{% asset_img 123456789.png %}

<br/>

### 实现原理

构建思想就是在构建一棵二叉排序树的过程中，每当插入一个节点就立刻检查，这个节点是否会导致这个树的平衡性遭到破坏，

最小不平衡子树，导致这棵二叉排序树不平衡的关键的内棵树及其子树。

{% asset_img AVL树举例.png %}

如图，在6节点插入的时候，就已经导致了这棵树不再平衡，所以，要删除8号节点，并且把这棵树进行修改，

{% asset_img AVL树2.png %}

<br/>

### 修改方法

旋转这棵最小不平衡子树

举例：  如何把下图构建成平衡二叉树

{% asset_img AVL树旋转1.png %}

第一步：此时出现问题：平衡因子是2，需要旋转

{% asset_img AVL树旋转2.png %}

第二步：如果平衡因子是正数且大于1，那么对应的整棵最小不平衡子树，就应该右旋转，即顺时针旋转，节点3变为节点2的右子节点

{% asset_img AVL树旋转3.png %}

第三步：插入节点4

{% asset_img AVL树旋转4.png %}

第四步：插入节点5，此时出现问题：节点3的平衡因子是-2，此时以3为节点的树是最小不平衡树

{% asset_img AVL树旋转5.png %}

第五步：如果平衡因子是正数且小于1，那么对应的整棵最小不平衡子,345，就应该左旋转，即逆时针旋转，节点3变为节点4的左子节点，节点4变为节点2的右子节点

{% asset_img AVL树旋转6.png %}

第六步：插入节点6，出现问题，平衡因子是-2	，最小不平衡子树是2,3,4,5,6，

{% asset_img AVL树旋转7.png %}

第七步骤。旋转，最小不平衡子树是2,3,4,5,6，所以把节点2左旋转，即逆时针旋转，

{% asset_img AVL树旋转8.png %}

此时出现问题：4节点有了三个子节点，需要抛弃

一个节点的右子树的最左边的那个孩子事实上可以放在这个节点的左子树的最右边的孩子的位置。

所以：第八步：

{% asset_img AVL树旋转9.png %}

第九步：插入节点7，

{% asset_img AVL树旋转10.png %}

第十步：此时需要旋转，最小不平衡子树是5,6,7，不平衡因子-2，所以：左旋转，

{% asset_img AVL树旋转11.png %}

第十一步：插入节点10

{% asset_img AVL树旋转12.png %}

第十二步：插入节点9

{% asset_img AVL树旋转13.png %}

第十三步：此时4,6,7的平衡因子都是-2.  最小不平衡子树7,10,9，需要进行左旋转，

{% asset_img AVL树旋转14.png %}

此时出现问题：9变为10的右子树，

原因：插入节点9之后，4,6,7的平衡因子都是-2, 10的平衡因子是1，这种是不符合规则的。正确情况下都是正数或者都是负数。对于这种特殊情况，应该先将节点9和10进行旋转，

正确的第十三步：将9和10进行右旋转，此时4,6,7,9  平衡因子都是负数

{% asset_img AVL树旋转15.png %}

第十四步骤：最小不平衡子树7,9,10，平衡因子都是负数，左旋，

{% asset_img AVL树旋转16.png %}

第十五步：插入节点8，

{% asset_img AVL树旋转17.png %}

第十六步：4,6节点都是-2，节点9是1，不符合规则，所以先要把9,7,10,8 进行右旋

注意这里的图示有错误，8本来是7的右子节点，这么写成了左子节点，正确的过程是9向右旋转后，8和9都是7的右节点，应该把8放在9的左子树。

一个节点的右子树的最左边的那个孩子事实上可以放在这个节点的左子树的最右边的孩子的位置。

{% asset_img AVL树旋转18.png %}

第十七步：最小不平衡树，6,5,7,9,8,10，平衡因子为负数，把6向左旋转

{% asset_img AVL树旋转19.png %}

旋转完成。

### 代码实现

~~~
//http://www.cnblogs.com/skywang12345/p/3577479.html
~~~

<br/>

### 多路查找树 ( B树 )

如果数据很多，如果二叉树的话，树会变得非常深，非常大，

主要是为了减少CPU访问硬盘的时间。

{% asset_img 多路查找树特点.png %}

所有元素之间存在某种特定排序关系。

在降低磁盘IO上起到了很好的作用。

<br/>

### 2-3树

2指的是两个节点，3指的是有3个节点。

每个节点有两个孩子或者三个孩子， 不能只有一个孩子，

{% asset_img 2-3树特点.png %}

举例：

{% asset_img 2-3树.png %}

<br/>

### 插入原理

一：新建，

二：在一个2节点中插入数据，比如在上图中插入数据3，则只需要在1的右边插入数据3即可。

三：①在一3节点中插入数据，比如在上图中插入5，就不能直接在6的左子树插入，否则就违背了2-3树的在一个层次上的原则，所以只能往上走，看4的位置，4是一个2节点，可以变成一个3节点，此时4会产生三个指针，所以就要把67这个3节点拆成两个2节点，使得三个指针都有指向 (2-3树的要求) 再根据排序原则，5要放在6的位置，6放在4的右边，7不变。

{% asset_img 插入原理1.png %}

②比如插入11，此时和上面不同，10所在的节点和12所在的节点都是3节点，所以就继续往上找，8节点是2节点，所以就要改成3节点，多出来一个指针，因为要保证中序遍历的数据是顺序排列的，所以要把12 14的左子树整个的移过来，还要把12放上去，14变为2节点。

{% asset_img 2-3树插入2.png %}

四：在上图中插入2，往上走，都是3节点，只能增加高度，此时就要拆解，要从下往上拆，多拆出来一层。

{% asset_img 2-3树插入3.png %}

### 删除原理

{% asset_img 2-3树删除1.png %}

一：要删除的元素在3节点上，直接删掉变为2节点即可。

二：要删除的元素在一个2节点的叶子上，  

{% asset_img 2-3.png %}

①：删除1：节点的双亲也是一个2节点，并且拥有一棵3节点的孩子，直接删除是不可以的，不符合规则，此时需要做的就是删除1，然后4,6,7做一个左旋转，

{% asset_img 2-3树删除1.png %}

②：删除4：节点的双亲也是一个2节点，并且另一个孩子也是2节点，直接删除是不可以的，不符合规则，也无法左转了，看根节点，7是根节点的直接前驱，9是根节点的直接后继，所以把9 借过来，放在根节点，其他全部往左边根据规则放。

{% asset_img 2-3树删除2.png %}

③：删除10：节点的双亲是一个3节点，把它的双亲变为2节点即可。

{% asset_img 2-3树删除3.png %}

④：在一个满二叉树中去删除一个节点，没有3节点可以借用元素了，此时，需要逆向考虑插入的时候，应该减小一层，想办法构造3节点，

{% asset_img 2-3树删除4.png %}

三：删除的不是叶子节点：比如下图

{% asset_img 2-3树.png %}

①删除4，借助它的右孩子，67这个3节点即可。

{% asset_img 2-3树删除5.png %}

<br/>

### 2-3-4树

构建过程

{% asset_img 2-3-4的构建过程.png %}

​	构建的过程中，优先考虑横向的扩展添加，可能的情况是横向扩展了，就多了一个指针，如果下面还有的话，就要进行分裂，整体的思想就是这样。最需要注意的就是要从下往上构建，进来一个数字的时候，要优先考虑在下面一层进行添加，等添加到4节点了，再考虑向上层添加，上层添加完成之后，要考虑分裂问题。

<br/>

### B树

{% asset_img B树.png %}

#### 属性：

{% asset_img B树的属性.png %}

{% asset_img B树的属性2.png %}

n表示元素个数，k表示元素的值，A表示指针，

如果m设置为1000，两次读取，就可以读取超过100万的数据。