---
title: 并发编程实战(三)
categories:
  - 多线程编程
tags:
  - 并发编程实战读书笔记
abbrlink: 3ad494db
date: 2018-02-24 18:51:46
---

## 第三章：对象的共享

主要介绍如何共享和发布对象

<br/>

### 内存可见性：

一个常见的误区是：认为关键字synchronized 只能用于实现原子性或者确定  “ 临界区 （ Critical Section ）”。罔同步还有另一个重要的方面：内存可见性（ Memoy Visibility ）。我们不仅希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，西且希望确保当一个线程修改了对象状态后，其能线程能够看到发生的状态变化

<br/>

为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。

示例代码：

```java
public class NoVisibility{
  private static boolean ready;
  private static int number;
  
  private static class ReaderThread extends Thread{
    public void run(){
      while(!ready){
          Thread.yield();
      System.out.println(number);
      }
    }
    
    public static void main(){
      nerw ReaderThread().start();
      number = 42;
      ready = true;
    }
    
  }
}
```

结果：无限循环。

原因：重排序

失效数据：当读线程查看ready变量时，读取到了一个失效数据，因为主线程已经把数据修改了。

<br/>

### 最低安全性

当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证也被称为最低安全性（ out-of-thin-airsafety）。适用于绝大多数变量

<br/>

例外：非volatile 类型的64 位数值变量(double 和 long）

<br/>

Java 内存模型要求，变量的读取操作如写入操作都必级是原子操作，但对于非volatile 类型的long 和double 变量， JVM 允许将64 位的读操作或写操作分解为两个32 位操作。当读取一个非volatile 类型的long 变量时，如果对该量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高32 位和另一个值的低32位。因此，即使不考虑失效数据问题，在多线程程序中使用共享旦可变的long 和double 等类型的变量也是不安全的，除非用关键学volatile 来声明它们，或者用锁保护起来。

<br/>

### 同步的可见性保证

当线程A 执行某个同步代码块时，线程 B 随后进入由同一个锁保护的同步代码块，在这种情况下可以保证，在锁被释放之前， A 看到的变量值 在B 获得锁后同样可以由B看到。换句话说，当线程B 执行由锁保护的同步代码块时，可以看到线程A 之前在同一个同步代码块中的所有操作结果。如果没有同步，那么就无法实现上述保证。

{% asset_img 三1.png %}

<br/>

我们可以进一步理解为什么在访问某个共享且可变的变量时要求所有线程在同一个锁上同步，就是为了确保某个线程写入该变量的值对于其他线程来说都是可见的。否则，如果一个线程在未持有正确锁的情况下读取某个变量，那么读取的可能是一个失效值。

<br/>

### Volatile变量

volatile 变量是一种比  sychronized 关键字更轻量级的同步机制，不会加锁。

只有可见性，没有原子性。

典型用法：检查某个状态标记语句以判断是否退出循环

```java
volatile boolean asleep;
	while (!asleep)
	countSomeSheep();
```

<br/>

**加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性 **

<br/>

当且仅当满足以下所有条件时，才应该使用volatile 变量：

- 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。
- 该变量不会与其他状态变量一起纳入不变性条件中。
- 在访问变量时不需要加锁。

<br/>

### 发布与逸出

 “发布（Publish）”一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。例如，将一个指向该对象的引用保存到其他代码可以访问的地方，或者在某一个非私有的方注中返回该引用，或者将引用传递到其他的方法中。在许多情况中，我们要确保对象及其内部状态不被发布。但在某些情况下，我们又需要发布某个对象，但如果在发布时要确保线程安全性，则可能需要问步。发布内部状态可能会破坏封装性，并使得程序难以维持不变性件。例如，如果在对象构造完成之前就发布该对象，就会破坏结程安全性，当某个不该发布的对象被发布时，这种情况就被称为逸出。

<br/>

当发布某个对象时可能会间接的发布其他对象

当发布一个对象时，在该对象的非私有域中引用的所有对象同样会被发布

```java
class UnsafeStates {
	private String[} states ; new String [] {
		"AK","AL"...
	};
	public String[] getStates () { return states;}
}
```

<br/>

假定有一个类C，对于C 来说，“外部（ Alien）方法” 是指行为并不完全由C 来规定的方法；包括其他类中定义的方法以及类C 中可以被改写的方法〈既不是私有［private］方法也不是终结［final］方站〉。当把一个对象传递给某个外部方法时，就相当于发布了这个对象。你无法知道哪些代码会执行，也不知道在外部方法中究竟会发布这个对象，还是会保留对象的引用并在随后由另一个线程使用。

<br/>

如果有人窃取了你的密码并发布到alt.free-pass新闻组上，那么你的信息将“逸出", 无论是否有人会〈或者尚未〉恶意地使用这些个人信息，你的账户都已经不再安全了，发布一个引用同样会带来类似的风险。

<br/>

### 隐式地使this 引用逸出

```java
public class ThisEscape{
  public ThisEscape(EventSource source){
    source.registerListener(
      new EventListener(){
        public void onEvent(Event e){
          doSomething(e);
        }
      }
    );
  }
}
```

当thisEscape 发布EventListener 时，也隐含地发布了ThisEscape 实例本身，因为在这个内部类的实例中包含了对ThisEscape 实例的隐含引用。

<br/>

当内部的EventListener 实例发布时，在外部封装的ThisEscape 实例也逸出了。当且仅当对象的构造函数返回时，对象才处于可预测的和一致的状态。因此，当从对象的构造函数中发布对象时，只是发布了一个尚未构造完成的对象。即使发布对象的语句位于构造函数的最后一行也是如此。如果this 引用在构造过程中逸出，那么这种对象就被认为是不正确构造。

<br/>

**不要在构造过程中使this引用逃逸 **

<br/>

### 使用工厂方法来防止this 引用在构造过程中逸出

```java
public class SafeListener{
  private final EventListener listener;
  
  private SafeListener(){
    listener = new EventListener(){
      public void OnEvent(Event e){
        doSomething(e);
      }
    }
  }
  
  public static SafeListener newInstance(EventSource source){
    SafeListener safe = new SafeListener();
    source.registerListener(safe.listener);
    return safe;
  }
}
```

<br/>

### 隐式地使this 引用逸出的常见错误：在构造函数中启动一个线程

当对象在其构造函数中创建一个线程时，无论是显示创建〈通过将它传给构造函数）还是隐式制建（由Thread 或 Runnable 是该对象的一个内部类）， this 引用都会被新创建的线程共享。在对象尚未完全构造之前，新的线程就可以看见它。在构造函数中创建线程并没有错误，但最好不要立即启动它，而是通过一个start 或initialize 方法来启动。

<br/>

### 使用面向对象的封装性的最主要的原因：

当某个对象逸出后，你必须假设有某个类或线程可能会误用该对象。这正是需要使用封装的最主要原因：封接能够使得对程序的正确性进行分析变得可能，并使得无意中破坏设计约束条件变得更难。

<br/>



### 避免使用同步的保护线程安全的技术：线程封闭

Swing，

Jdbc的Connection对象：由于大多数请求（例如Serviet 需求或EJB 调用等〉都是由单个线程采用同步的方式来处理，并且在Connection 对象返回之前，连接池不会再将它分配给其他线程，因此，这种连接管理模式在处理请求时隐含地将Connection 对象封闭在线程中。

<br/>

线程封闭：必须在程序中实现，java语言无法强制将对象封闭在某个线程中。

<br/>

### Ad-hoc线程封闭

维护线程封闭的职责完全由程序实现来承担。

<br/>

**volitile **：一种特殊的线程封闭：只要你能确保只有单个钱辑对共享的volatile变量执行写入操作，那么就可以安全地在这些共享的volatile 变量上执行＂ 读取 - 修改  - 写入 ”的操作。在这种情况下，相当于将修改操作封闭在单个线程中以防止发生竟态条件，并且volatile 变量的可见性保证还确深了其他线程能看到最新的值。

<br/>

脆弱：应该尽量少使用。

<br/>

### 栈封闭

其实本质就是局部变量：局部变量的固有属性之一就是封闭在执行线程中，他们位于线程的栈中，其他线程无法访问这个栈，栈封闭比Ad-hoc线程封闭更容易维护，也更健壮。

<br/>

对于基本类型的局部变量，例如程序中loadτheArk 方法的numPairs，无论如何都不会破坏栈封闭性。由于任何方法都无法获得对基本类型的引用，因此Java语言的这种语义就确保了基本类型的局部变量始终封闭在线程内。

```java
public int loadTheArk(Collection<Animal> candidates){
	SortedSetc<Animal> animals;
	int numPairs = 0；
	Animal candidate = null;{
	// animals 被封闭在方法中！不要使它们逸出：
	animals= new Treeset<Animal>(new SpeciesGenderComparator ()];
    animals.addAll(candidates);
    for (Animal a: animals) {
        if (candidate == null || candidate.isPotentialMate(a){
           candidate= a;
        else {
           ark.load(new AnimalPair (candidate， a));
           ++ numPairs;
           candidate= null;
        }
    }
    return numPairs;
}
```



<br/>

### ThreadLocal

这个类能使线程中的某个值与保存值的对象关联起来。ThreadLocal 提供了get与set 等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的剧本，因此get 总是返回由当前执行线程在调用set 时设置的最新值。

<br/>

通常用于防止对可变的单实例变量或全局变量进行共亭。

<br/>

例如，在单线程应用程序中可能会维持一个全局的数据库连接，并在程序启动时初始化这个连接对象，从而避免在提用每个方能时都要传递一个Connection 对象。由于JDBC 的连接对象不一定是线程安金的，因此，当多线程应用程序在没有协调的情况下使用全局变量时，就不是线程安全的。通过将JDBC 的连接保存到 ThreadLocal 对象中，每个线程都会拥有属于自己的连接。

```java
private static ThreadLocal<Connection> connectionHolder
  = new ThreadLocal<Connection>(){
    public Connection initialValue(){
   		 return DriverManager.getConnection(DB_URL)
    }
  };
public static Connection getConnection(){
	return connectionHolder.get();
}
```

当线程终止后，线程所对应的值会作为垃圾回收。

应用：EJB调用，J2EE容器需要将一个事务上下文和某个执行中的线程关联起来。

<br/>



### 不变性

如果某个对象在被创建后其状志就不能被修改，那么这个对象就称为不可变对象。线程安全是不可变对象的固有属性之一。

<br/>

不可变对象一定是线程安全的。

<br/>

不可变性并不等于将对象中所有的域都声明为final 类型，即使对象中所有的域都是final 类型的，这个对象也仍然是可变的，因为在final 类型的域中可以保存对可变对象的引用。

<br/>

只有满足以下条件时，对象才是不可变的：

- 对象创建以后其状态就不能修改
- 对象的所有域都是final类型
- 对象是正确创建的（在对象的创建期间，没有this引用逃逸）

```java
@Immutable
public final class ThreadStooges{
  private final Set<String> stooges = new HashSet<String>();
  
  public ThreadStooges(){
    stooges.add("Moe");
    stooges.add("Larry");
    stooges.add("Curly");
  }
  
  public boolean isStooges(String name){
    return stooges.contains(name);
  }

}
```

尽管保存姓名的Set 对象是可变的，但从ThreeStooges 的设计中可以看到，在Set 对象构造完成后无法对其进行修改。 stooges 是一个 final 类型 的引用变量，因此所有的对象状态都通过一个final 域来访问。最后一个要求是“正确地构造对象”，这个要求很容易满足，因为构造函数能使该引用由除了构造函数及其调用者之外的代码来访问。

<br/>

### 使用Volatile来发布不可变对象（可以代替锁来进行同步）

每当需要对一组相关数据以原子方式执行某个操作时，就可以考虑创建一个不可变的类来包含这些数据。

<br/>

对数值及其因式分解结果进行缓存的不可变容器类：

```java
＠immutable
class OneValueCache {
	private final BigInteger lastNumber;
	private final BigInteger[] lastFactors;
	public OneValueCache (Biginteger i,Big Integer[] factors){
		lastNumber = i;
		lastFactors = Arrays.copyOf(tactors，factors.length);
	}
public Biginteger[] getFactors(Biginteger i) {
    if ((lastNumber == null || !LastNumber.equals(i))
    	return null;
    else
  	    return Arrays.copyOf(lastFactors， lastFactors.length);
}
```

​	对于在访问和更新多个相关变量时出现的竞争条件问题，可以通过将这些变量全部保存在一个不可变对象中来消除。如果是一个可变的对象，那么就必须使用锁来确保原子性。如果是一个不可变到象，那么当线程获得了对该对象的引用后，就不必担心另一个线程会修改对象的状态。如果要更新这些变量，那么可以创建一个新的容器对象，但其他使用原有对象的线程仍然会看到对象处于一致的状态。

<br/>

VolatileCachedFactorizer使用了OneValueCache 来保存缓存的数值及其因数，当一个线程将volatile 提供的cache 设置为引用一个新的OneValueCache 时，其他线程就会立即看到新缓存的数据。

```java
@ThreadSafe
public class VolatileCachedFactorizer implements Servlet{
  private Volatile OneValueCache cache = new OneValueCache(null,null);
  
  public void Service(ServletRequest req, ServletResponse resp){
    
    BigInteger i = extractFromRequest(req);
    BigInteger[] factors = cache.getFactors(i);//从缓存中获取数据
    
    if(factors == null){
      factors = factor(i);
      cache = new OneValueCache(i,factors);//更新缓存，因为使用了Volatile修饰，所以，一个线程更新，										其他线程就立马会看到
    }
    encodeIntoResponse(resp,factors);
  }
}
```

cache 相关的操作不会相互干扰，因为 OneValueCache 是不可变的，并且在每条相应的代码路经中只会访问它一次。通过使用包含多个状态变量的容器对象来维持不变性条件，并使用一个 volatile 类型的引用来确保可见性，使得Volatile Cached Factorizer 在没有显示地使用锁的情况下仍然是线程安全的。

<br/>

### 初始化安全性（针对不可变对象而言的）

由于不可变对象是一种非常重要的对象， 因此 Java 内存模型为不可变对象的共享提供了一种特殊的初始化安全性保证。

<br/>

​	即使在发布不可变对象的引用时没有使用同步，也仍然可以安全地访问该对象。为了维持这种初始化安全性的保证，必须满足不可变性的所有需求 ：状态不可修改，所有的城都是final 类型，以及正确的构造过程。

<br/>

**任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步 **

<br/>

这种保证还将延伸到被正确创建对象中所有final 类型的域。在没有额外同步的情况下，也可以安全地访问final 类型的域。然而，如果final 类型的域所指向的是可变对象，那么在访问这些域所指向的对象的状态时仍然需要同步

<br/>

### 安全发布对象的方式

要安全发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见，一个正确构造的对象可以通过以下方式来安全的发布

- 在静态初始化函数中初始化一个对象引用
- 将对象的引用保存到volatile类型的域或者AtomicReference对象中
- 将对象的引用保存到某个正确构造对象的final类型域中
- 将对象的引用保存到一个由锁保护的域中

<br/>

发布一个静态构造的对象，最简单和最安全的方式是使用静态的初始化器

```java
public static Holder holder = new Holder(42);
```

<br/>

### 事实不可变对象

如果对象从技术上来看是可变的，但其状态在发布后不会再改变，那么把这种对象称为“事实不可变对象（ Effectively Immutable Object)''， 这些对象不需要满足我们之前提出的的不可变性的严格定义。在这些对象发布后，程序只需将它们视为不可变对象即可。通过使用事实不可变对象，不仅可以简化开发过程，币且还能由于减少了同步而提高性能。

<br/>

**在没有额外同步的情况下，任何线程都可以安全的使用被安全发布的事实不可变对象 **

<br/>

​	例如：Date 本身是可变的，但如果将它作为不可变对象来使用，那么在多个接程之间共享 Date 对象时；就可以省去对锁的使用，假设需要维护一个Map 对象，其中保存了每位用的最近登录时间：

```java
public Map<String, Date> lastLogin = 
	Collections.synchronizedMap(new HashMap<String, Date>())；
```

​	如果Date 对象的值在被放入Map后就不会改变，那么 synchronizedMap 中的同步机制就足以使 Date 值被安全地发布，并且在访问这些 Date 值时不需要额外的同步。

<br/>

​	可以从业务上理解这个，在这个业务情况下，是不会有线程安全的，每次只会有一个线程去操作和用户对应的Date对象，哪怕同时有两个线程在读和修改，这两个操作也都是独立加锁的，只能等待一个线程修改完成之后，另外一个线程才能读取，这里不会有要进行原子性的复合操作。所以不会有线程安全问题。

<br/>

### 可变对象

对于可变对象，不仅在发布对象时需要使用同步，并且在每次对象访问时同样需要使用同步来确保后续修改操作的可见性。要安全地共享可变对象，这些对象就必须被安全地发布，并旦必须是线程安全的或者由某个锁保护起来。

<br/>

<br/>

## 总结：对象的发布取决于它的可变性

- 不可变对象可以通过任何机制来发布
- 事实不可变对象必须通过安全方式来发布（安全的发布方式指的就是通过同步来确保线程安全性）
- 可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某一个锁保护起来。

<br/>



<br/>

## 使用策略

**线程封闭 **：线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改

**只读共享 **：在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它，共享的只读对象包括不可变对象和事实不可变对象

**线程安全共享 **：线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步

**保护对象 **：被保护的对象只能通过持有特定的锁来访问，保护对象包括封装在其它线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象