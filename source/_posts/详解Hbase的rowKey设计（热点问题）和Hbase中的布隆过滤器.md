---
title: 详解Hbase的rowKey设计（热点问题）和Hbase中的布隆过滤器
tags:
  - Hbase
categories:
  - big-data
abbrlink: e1de3e9b
date: 2018-03-08 15:46:31
---

### 热点

大量的数据都涌向了一个或几个节点

{% asset_img h1.png %}

<br/>

hbase区域空间下的meta元数据表就是一个很好的示例：

{% asset_img h2.png %}

最后加一个hash值，让挨在一起的数据分到不同的region中，防止数据查询时都到一个节点上查询造成热点问题。

<br/>



### rowKey的设计原则

{% asset_img h3.png %}

<br/>

{% asset_img h4.png %}

<br/>

{% asset_img h5.png %}

<br/>

经常查询的数据要放在一起，没有错，但是不能量太大，否则，就会引发热点问题，此时就要把这些大量的数据拆到不同的节点上去。

<br/>

**也就是要在连续性和散列性之间做一个权衡**

<br/>

### 盐析

{% asset_img h6.png %}

1. 撒盐的时候会尽量均匀。
2. 分配的前缀种类数量要和你想使用数据分散到不同的region的数量一致。

<br/>

{% asset_img h7.png %}

<br/>

{% asset_img h8.png %}

<br/>

{% asset_img h9.png %}

<br/>



### 例子：电信公司通话记录存储

{% asset_img h10.png %}

<br/>

首先根据设备查看总共有多少个节点（服务器），假设有10个，就可以把盐析设置为00，01，02，03....10，为了以后更好的扩展，我们设置为000---999 ,即1000个节点，把他们做为前缀，加盐之后的rowKey就会根据随机生成的前缀分散到不同的region上，以避免热点，这是盐析原则。

<br/>

第二个是哈希原则，即我们可以把手机号取hashcode，再%1000，这样相同的手机号就会分到相同的region上，使得读是可以预测的，读取的时候查询相同的数据就可以直接读取出来，这样也充分利用了rowKey的排序的特点，把经常需要读取的数据放在了同一个节点上，提高了读取效率，根据通话的业务特点，很多用户会根据主叫和时间进行查询，那么我们就可以根据 （主叫+时间）% 1000 ， 作为加盐前缀。

<br/>

考虑为什么不能直接用时间做rowKey，如果用时间做rowkey，那么当交换机( 用户的通话记录都是通过交换机传输到Hbase中的 ) 向Hbase中存数据的时候，同一时间的数据存到同一个Region上，造成了热点问题。

<br/>

考虑为什么不能直接用主叫做rowKey，如果用主叫做rowkey，那么查询的时候，也会由于都是查询一个相同的手机号而造成查询的热点问题。

<br/>

### rowKey的二次索引问题

在按照上述电信公司通话记录 rowKey 设计后，rowKey就如左上角所示，那么在查询的时候，指定的startKey和endKey 要注意rowKey中的calltime是具体到分钟的，我们指定的 startKey和endKey 是具体到月份的，因为hash的时候hash的calltime是具体到月份的，问题就是那么怎么查询被叫，通话记录肯定是主叫被叫都要查询的，

{% asset_img h11.png %}

<br/>

问题的解决要通过   二次索引  

再新建一张被叫表（ColleeLog），rowKey只包含被叫号码，被叫时间，主叫号码，通话时长等常用信息，

{% asset_img h12.png %}

<br/>

上面的图就是二次索引，rowKey包含的是被叫号码，被叫时间，主叫号码，通话时长等常用信息，表中存储的值是主叫表（CallerLog）的rowKey，那么当我们要查询的一个号码作为被叫的时候，直接去通过 ColleeLog 表查询即可。 而且因为ColleeLog 表的rowKey 中包含了号码作为被叫时的常用信息，所以当不需要查询被叫号码的详细信息的时候，只查询ColleeLog  表即可。需要详细信息的时候，再通过查询出来的rowkey去查询CallerLog表即可。

<br/>

### 针对上例的第二种设计思路

{% asset_img h13.png %}

<br/>

只用一张表即可，比如说1给2打电话，会先在用1哈希的内个region上写一条记录，1 ->2 0 ，然后再通过协处理器在用2哈希的内个region上写一条记录，2 -> 1 1  （注意这里只增加常用信息，没有详细信息），也就是通过0，1 标志位来判断，是主叫还是被叫，0表示主叫，1表示被叫，

<br/>

这样做的好处就是查询一个用户的通话记录的时候，这个用户的所有信息都在同一个region区间上，无论是主叫还是被叫。

<br/>

这个方法要注意防止死循环的产生，因为当触发器插入记录的时候，可能会又激活了触发器，导致死循环。

<br/>

问题：当要查询当前手机号作为被叫的时候的详细信息怎么办呢？我们把当前手机号作为被叫号码插入hbase的时候，是没有插入详细信息的。

<br/>

可以在协处理器的preGetOP方法中进行处理，如果通过get获取到rowkey是被叫，就转化为主叫再get方法之前查询出来，



<br/>

### BloomFilter

{% asset_img h14.png %}

<br/>

布隆过滤器：如果所有的hash函数都返回no，一定不存在，即使不是都返回no，也有可能不存在。极大的提高了IO的效率。

<br/>

{% asset_img h15.png %}