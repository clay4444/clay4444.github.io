---
title: 并发编程实战(五)
categories:
  - 多线程编程
tags:
  - 并发编程实战读书笔记
abbrlink: c63c2ca9
date: 2018-02-27 10:12:13
---

## 第五章：基础构建模块

此章节最好和之前的多线程编程博客一同观看，各个容器的详细介绍和使用方式在这里不会再过多记录。

<br/>

### 同步容器类

包括Vector和HashTable这些同步的封装器类是由Collections.synchronizedXxx 等工厂方法创建的。这些类实现线程安全的方式是：将它们的状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态。

<br/>

不支持复合操作的原子性：例如 “迭代”，“若没有则添加‘，”条件运算“。。。。等

我们可以通过客户端加锁来解决不可靠迭代问题，但是要牺牲一些伸缩性，通过在迭代期间持有Vector的锁，可以防止其他线程在迭代期间修改Vector，然后，这同样会导致其他线程在迭代期间无法访问它，因此降低了并发性

```java
synchronized(vector){
  for(int i = 0; i < vector.size(); i++){
    doSomething(vector.get(i));
  }
}
```

<br/>

同步容器将所有对容器状态的访问都串行化，以实现他们的线程安全性。这种方法代价是严重降低并发性，当某个线程竟争容器的锁时，吞吐率将严重降低。

<br/>

### 选代器与ConcurrentModificationException

这种“及时失败”的迭代器并不是一种完备的处理机制，而只是“善意的”捕获并发错误，因此只能作为并发问题的预警指示器。

实现方式是：当计数器的变化与容器关联起来，如果在迭代期间计数器被修改，那么hasNext 或next 将抛出ConcurrentModificationException 。

<br/>

与迭代Vector 一样，要想避免出现ConcurrentModificationException ，就必须在迭代过程中持有容器的锁。

<br/>

迭代期间对容器加锁的危害：导致某个线程长时间等待，或者导致死锁，或者由于长时间等待导致锁的激烈竞争，极大的降低吞吐量和CPU的利用

<br/>

不加锁的解决办法：克隆容器，在副本上进行迭代。本质就是把副本封闭在线程内，使得其他线程不会在迭代期间对其进行修改，这样就可以避免抛出ConcurrentModificationException ，注意：在克隆过程中仍然需要对容器加锁。这种方式的好坏取决于多个因素，包括容器的大小，在每个元素上执行的工作，选代操作相对于容器其他操作的调用频率，以及在响应时间和吞吐量等方面的需求。

<br/>

### 隐藏迭代器

```java
public class HiddenIterator{
  @GuardedBy("this")
  private final Set<Integer> set = new HashSet<Integer>();
  
  public synchronized void add(Integer i){set.add(i);}
  public synchronized void remove(Integer i){set.remove(i);}
  
  public void addTenThing(){
    Random r = new Random();
    
    for(int i = 0; i < 10; i++){
      add(r.nextInt());
    }
    
    System.out.println("DEBUG: add ements to " + set);//注意这里将会进行迭代操作，这是会危害线程安全的。
  }
  
} 
```

编译器将字符串的连接操作转换为调用StringBuilder.append(Object），而这个方法又会调用容器的toString 方法，标准容器的to String 方法将迭代容器，并在每个元素上调用toString 来生成容器内容的格式化表示。

<br/>

add Ten Things 方法可能会抛出ConcurrentModificationException，因为在生成调试消息的过程中， to String 对容器进行迭代。当然，真正的问题在于Hiddenlteracor 不是线程安余的。在使用println 中的set 之前必续首先获取Hiddenlterator 的锁，但在调试代码和日志代码中远常会忽视这个要求。

<br/>

间接的迭代器：containsAll 、reinoveAll 和retainAll 等方法， 以及把容器作为参数的构造函数，都会对容器进行迭代。所有这些间接的迭代操作都可能抛出 ConcurrentModificationException

<br/>



### 并发容器

通过并发容器来代替同步容器，可以极大的提高伸缩性并降低风险。

<br/>

ConcurrentHashMap 与其他并发容器一起增强了同步容器类：他们提供的迭代器不会抛出ConcurrentModificationException ，因此不需要在迭代过程中到容器加锁。



<br/>

### ConcurrentHashMap

ConcurrentHashMap返回的迭代器具有弱一致性 (Weakly ），而并非“及时失败”，弱一致性的迭代器可以容忍并发的修改，当创建选代器时会遍历己有的元素，并可以（但是不保证）在迭代器被构造后将修改操作返回给容器。

<br/>

在ConcurrentHashMap 中没有实现对Map 加锁以提供独占访问，因此我们无法使用客户端加锁来创建新的原子操作，但是，一些些常见的复合操作，例如；如“若没有则添加”、“若相等则移除（ Remove-If-Equal) ”和“若相等则替换”〈Replace-If-Equal）等等，都已经实现为原子操作并且在ConcurrentMap 的接口中声明。如果你需要在现有的同步Map 中添加这样的功能，那么很可能就意味着应该考虑使用ConcurrentMap 了。

**只有当应用程序需要加锁Map 以进行独占坊问时，才应该放弃使用ConcummtHashMap **

<br/>



### CopyOnWriteArrayList

“写入时复制（Copy-On-Write）＂容器的线程安全性在于，只要正确的发布一个事实不可变的对象，那么再访问该对象时就不需要使用进一步的同步。

<br/>

在每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性。

<br/>

“写入时复制”容器返回的迭代器不会抛出ConcurrentModificationException，并且返回的元素与迭代器创建时元素完全一鼓，而不必考虑之后修改操作所带来的影响。

<br/>

仅当迭代操作远远多于修改操作时，才应该使用“ 写时复制”容器。否则，性能可能还不如加锁。

<br/>



### 阻塞队列与生产者消费者模式

- 该模式将“找出需要完成的工作”与“执行工作”这两个过程分离开来，并把工作项放入一个“待完成”列表中以便在随后处理，而不是找出后立即处理。
- 生产者一消费者模式能简化开发过程，因为它消除了生产者类和消费者类之间的代码依赖性，此外，该模式还将生产数据的过程与使用数据的过程解耦开来以简化工作负载的管理，因为这两个过程在处理数据的速率上有所不同。

<br/>

阻塞队列简化了消费者程序的编码，因为take 操作会一直阻塞直到有可用的数据。如果生产者不能尽快地产生工作项使消费者保持忙碌，那么消费者就只能一直等待，直到有工作可做。

<br/>

阻塞队列同样提供了一个offer 方法，如果数据项不能被添如队列中，那么将返回一个失败状态。这样你就能够创建更多灵活的策略来处现负荷过载的情况，倒如减轻负载，将多余的工作项序列化并写入磁盘，减少生产者线程的数量，或者通过某种方式来抑制生产者线程。

<br/>

**在构建高可靠的应用程序时，有界队列时一种强大的资源管理工具，他们能抑制并防止产生过多的工作项，使得应用程序在负荷过载的情况下变得更加强壮 **

<br/>

LinkedBlockingQueue   ArrayBlockingQueue  :  FIFO

<br/>

PriorityBlockingQueue：优先级，Comparable，Comparator

<br/>

SynchronousQueue： 实际上它不是一个真正的队列，因为它不会为队到中元素维护存储空间。与其他队列不同的是，它维护一组线程，这些线程在等待着担元素加入或移出队列，这种实现队列的方式看似很奇怪，但由于可以直接交付工作，从而降低了将数据从生产者移动到消费者的延迟。

因为SynchronousQueue 没有存储功能，因此 put 和take 会一直阻塞，直到有另一个线程巳经准备好参与到交付过程中。仅当有足够多的消费者，并且总是有一个消费者准备好获取交付的工作时，才适合使用同步队列。

<br/>

生产者一消费者模式同样能带来许多**性能优势 **。生产者和消费者可以井发地执行。如果一个是I/0 密集盟，另一个是CPU 密集型，那么并发执行的吞吐率要高于串行执行的吞吐率。如果生产者和消费者的并行度不同，那么将它们紧密耦合在一起会把整体并行度降低为二者中更小的井行度。

<br/>

生产者消费者设计模式和阻塞队列一起，促进了串行线程封闭，从而将对象所有权从生产者交付给消费者，**线程封闭对象 **只能由单个线程拥有。所以就是说 即使是可变对象，也可以安全的从消费者送到消费者，而不用担心

<br/>



### 双端队列与工作密取

​	在生产者一消费者设计中，所有消费者有一个共享的工作队到，而在工作密取设计中，每个消费者都有各自的双端队列。如果一个消费者完成了自己双端队列中的全部工作，那么它可以从其他消费者双端队列末尾秘密地获取功罪。密取工作模式比传统的生产者一消费者模式具有更高的可伸缩性，这是因为工作者线程不会在单个共享的任务队列上发生竞争。在大多数时候，它们都只是访问自己的双端队列，从而极大地减少了竞争。当工作者线程需要访问另一个队列时，它会从队到的尾部而不是从头部获取工作，因此进一步降低了队列上的竞争程度。

<br/>

​	工作密取非常适用于既是消费者也是生产者问题，当执行某个工作时可能导致出现更多的工作，常见的有爬虫程序，很多搜索图的算法等。

<br/>



### 阻塞方法与中断方法

阻塞操作与执行时间很长的普通操作的差别在于，被阻塞的线程必须等待某个不受它控制的事件发生后才能继续执行。例如等待IO操作。等待某个锁变得可用等。

<br/>

当某方法抛出Interrupted-Exception 时，表示该方法是一个阻塞方法，如果这个方法被中断，那么它将努力提前结束阻塞状态。

<br/>

Thread 提供了interrupt 方法，用于中断线程或者查询该线程是否已经被中断。每个线程都有一个布尔类型的属性，表示线程的中断状志，当中断线程时将设置这个状态。

<br/>

一个线程不能强制其他线程停止正在执行的操作而去执行其他的操作。当线程A 中断B 时， A 仅仅是要求B 在执行到某个可以暂停的地方停止正在执行的操作，前提是如果线程B 愿意停止下来。最常使用中断的情况就是取消某个操作。方法对中断请求的响应度越高，就越容易及时取消那些执行时问很长的操作。

<br/>

当在代码中调用了一个将抛出InterruptedException 异常的方法时，你自己的方法也就变成了一个阻塞方法，并且必须要处理对中断的响应。对于库代码来说，有到种基本选择：

- 传递lnterru ptedException：根本不捕获或者捕获后再次抛出
- 恢复中断，有时候不能抛出InterruptedExccption，例如当代码是Runnable 的一部分时。在这些情况下，必须捕获InterruptedException，并通过调用当前线程上的interrupt 方法恢复中断状态，这样在调用栈中更高层的代码将看到引发了一个中断。

```java
public class TaskRunnable implements Runnable{
  BlockingQueue<Task> queue;
  ....
   public void run(){
    try{
      processTask(queue.take());
    } catch(InterruptedException e){
     	//恢复被中断的状态
      Thread.currentThread().interrupt();
    }
  }
}
```

<br/>



### 同步工具类

同步工具类可以是任何一个对象，只要它根据其自身的状态来协调线程的控制流。阻塞队列可以作为同步工具类，其他类型的同步工具类还包括信号量（ Semaphore ）、栅栏（ Barrier)  以及闭锁 (Latch)。在平台类库 中还包含其他一些同步工具类的类，如果这些类还无法满足需要，那么可以创建自己的同步工具类。

<br/>

### 闭锁

闭锁是一种同步工具类，可以延迟线程的进度直到其到达终止状态 闭锁的作用相当于一扇门：在闭锁到达结束状态之前，这扇门一直是关闭的，并且没有任何线程能通过，当闭锁到达结束状态时，这扇门会打开并允许所有的线程通过。当闭锁到达结束状态后，将不会再改变状态，因此这扇门将永远保持打开状态。闭锁可以用来确保某些活动直到其地活动都完成后才继续执行，

例如

- 确保某个计算在其需要的所有资源都被初始化之后才继续执行
- 确保某个服务在其依赖的所有其他服务都已经启动之后才启动
- 等待直到某个操作的所有参与者

<br/>

闭锁状态包括一个计数器，该计数器被初始化为一个正数，表示需要等待的事件数量。countDown 方法递减计数器，表示有一个事件已经发生了，而 await 方法等待计数器达到零，这表示所有需要等待的事件都已经发生。如果计数器的值非零，那么await 会一直阻塞直至计数器为零，或者等待中的结程中断，或者等待超时。

<br/>

闭锁是一次性操作，一旦进入终止状态，就不能被重置。

<br/>

### FutureTask

Futureτask 表示的计算是通过Callable 来实现的，相当于一种可生成结果的Runnable

<br/>

3种状态：等待运行，正在运行，运行完成（包括正常结束，取消结束，和异常结束）

<br/>

Future.get() 的行为取决于任务的状态。如果任务巳经完成，那么get 会立即返回结果，否则get 将阻塞直到任务进入完成状态，然后返回结果或者抛出异常。FutureTask 将计算结果从执行计算的线程传递到获取这个结果的线程，FutureTask 的规范确保了这种传递过程能实现结果的安全发布。

<br/>

在Executor框架中表示异步任务。通过提前启动计算，可以减少等待结果需要的时间。

<br/>

```java
public class Preloader {
  private final FutureTask<ProductInfo> future =
    new FutureTask<ProductInfo>(new Callable<ProductInfo>() {
      @Override
      public ProductInfo call() throws Exception {
        return null;
      }
    });

  private final Thread thread = new Thread(future);

  public void start() {
    thread.start();
  }

  public ProductInfo get() throws DataLoadException,InterruptedException {

    try{
      
    }catch(ExecutionException e){
      Throwable cause = e.getCause();
      if(cause instanceof DataLoadException){
        throw (DataLoadException)cause;
      }else{
        throw launderThrowable(cause);
      }
    }
    
    return future.get();
  }
}
```

Preloader 创建了一个futureTask ，其中包含从数据库加载产品信息的任务， 以及一个执行运算的线程。由于在构造函数或静态初始化方站中启动线程并不是一种好方法，因此提供了一个start来启动线程。当程序随后需要Productlnfo 时，可以调用get 方站，如果数据已经加载，那么将返由这些数据，否则将等待加载完成后再返回。

<br/>



Callable 表示的任务可以抛出受栓查的或未受检查的异常，并且任何代码都可能抛出一个Error 无论任务代码抛出什么异常，都会被封装到一个ExecutionException 中，并在Future 中被重新抛出，这将使调用get 的代码变得复杂，因为它不仅需要处理可能出现的ExecutionException （以及未检查的CancellationException ），而且还由于ExecutionException 是作为一个Throwable 类返回的，因此处理起来并不容易。

<br/>

当get 方法抛出 ExecutionException 时，可能是以下三种情况之一： Callable 抛出的受检查异常，RuntimeException，以及Error。我们必须对每种情况进行单独处理，但我们将使用程序中的launderThrowable 辅助方法来封装一些复杂的异常处理逻辑，在调用launderThrowable 之前， Preloader 会首先检查已知的受检查异常，并重新抛出他们，剩下的是未检查异常， Preloader 将调用 launderThrowable 并抛出结果，如果Throwable 传递给launderThrowable 的是一个Error时，那么launderthrowable 将直接再次抛出它，如果不是

RuntimeException ，那么就说明是检查异常，那么将抛出一个illegalStateException 表示这是一个逻辑错误。剩下的RuntimeException, launderThrowable 将把它们返回给调用者，而调用者通常会重新抛出它们。

<br/>

~~~java

/**
如果Throwabel 是Error，那么抛出它，如果是RuntimeException，那么返回它，否则抛出
IllegalStateException。
**/
public static RuntimeException launderThrowable(Throwable t){
  if(t instanceof RuntimeException){  //未受检查的
    return (RuntimeException)t;
  }else if(t instanceof Error){
    throw (Error)t
  }else{
    throw new IllegalStateException("not unchecked", t);
  }
}
~~~



<br/>

### 信号量

（Semaphore）用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量.计数信号量还可以用来实现某种资源池，或者对容器施加边界。

<br/>

Semaphore 中管理着一组虚拟的许可（permit），许可的初始数量可通过构造函数来指定，在执行操作时可以首先获得许可〈只要还有剩余的许可），并在使用以后释放许可。如果没有许可，那么acquire 将阻塞直到有许可。

<br/>

Semaphore 可以用于实现资源池，例如数据库连接池。我们可以构造一个指定长度的资源池，当池为空时，请求资源将会失败，但你真正希望看到的行为是阻塞而不是失败，并且当池非空时解除阻塞。如果将Semaphore 的计数值初始化为池的大小，并在从池中获取一个资源之前首先提用acquire 方法获取一个许可，在将资源返回给池之后调用release 释敖即可，那么acquire 将一直阻塞直到资源池不为空。

<br/>

也可以使用Semaphore 将任何一种容器变成有界阻塞容器

```java
public class BoundedHashSet<T> {

  private final Set<T> set;

  private final Semaphore sem;

  public BoundedHashSet(int bound){
    this.set = Collections.synchronizedSet(new HashSet<T>());
    sem = new Semaphore(bound);
  }

  public boolean add(T o) throws InterruptedException{
    sem.acquire();
    boolean wasAdded = false;

    try {
      wasAdded = set.add(o);
      return wasAdded;
    }
    finally {
      if(!wasAdded){  //添加失败，释放，添加成功，不要释放
        sem.release();
      }
    }
  }

  public boolean remove(Object o){
    boolean wasRemoved = set.remove(o);
    if(wasRemoved){
      sem.release();
    }
    return wasRemoved;
  }
}
```



<br/>

### 栅栏

栅栏与闭锁的关键区别在于，所有线程必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其他线程。

<br/>

CyclicBarrier 可以使一定数量的参与方反复地在栅栏位置汇集，它在井行迭代算法中是非常有用， 这种算法通常将一个问题拆分成一系列相互独立的子问题。当线程到达栅栏位置时将调用wait 方法，这个方法通常将阻塞直到所有线程到达栅栏位置。如果所有线程都到达了栅栏位置，那么栅栏将打开，此时所有线程都被释放，而栅栏将被重置以便下次便用。如果时await的调用超时，或者await 阻塞的线程被中断，那么栅栏就被认为是打破了，所有阻塞的await 调用都将终止井抛出BrokenBarrierException，

<br/>

如果成功地通过栅栏，那么await 将为每个线程返回一个唯一的到达索引号，我们可以利用这个索引来“选举”产生一个领导线程，并在下一次迭代中由该领导线程执行一些特殊的工作。

<br/>

CyclicBarrier 还可以使你将一个栅栏操作传递给构造函数，这是一个Runnable，当成功通过栅栏时会〈在一个子任务线程中〉执行它，但在阻塞线程被释放之前是不能执行的。

<br/>

```java
public class CellularAutomata {

  private final Board mainBoard;
  private final CyclicBarrier barrier;
  private final Worker[] workers;

  public CellularAutomata(Board board){

    this.mainBoard = board;
    int count = Runtime.getRuntime().availableProcessors();
    this.barrier = new CyclicBarrier(count, new Runnable() {
      @Override
      public void run() {
        mainBoard.commentNewValues();
      }
    });

    this.workers = new Worker[count];

    for(int i = 0; i < count; i++){
      workers[i] = new Worker(mainboard.getSubBoard(count,i));
    }
  }

  private class Worker implements Runnable{

    private final Board board;
    public Worker(Board board){
      this.board = board;
    }

    @Override
    public void run() {

      while (!board.hasConverged()){
        for(int x = 0; x < board.getMaxX(); x++){
          for(int y = 0; y < board.getMaxX(); y++){
            board.setNewValue(x,y,computeValue(x,y));
          }
        }
      }
    }
  }
}
```



<br/>

### 构建缓存

```java
public interface Computable<A,V> {

  V compute(A arg) throws InterruptedException;
}
```

```java
public class ExpensiveFunction implements Computable<String, BigInteger>{

  @Override
  public BigInteger compute(String arg) throws InterruptedException {
    //在经过长时间的计算之后
    return new BigInteger(arg);
  }
}
```

```java
public class Memoizerl<A,V> implements Computable<A,V> {

  @GuardedBy("this")
  private final Map<A, V> cache = new HashMap<>();
  private final Computable<A,V> c;

  public Memoizerl(Computable<A,V> c){
    this.c = c;
  }

  @Override
  public synchronized V compute(A arg) throws InterruptedException {

    V result = cache.get(arg);
    if(result == null){
      result = c.compute(arg);
      cache.put(arg,result);
    }
    return result;
  }
}
```

HashMap 不是 线程安全的，因此要确保两个线程 不会同时访问 HashMap, Memoizerl 采用了一种保守的方法， 即对整个comput在方法进行同步。这种方式能确保线程安全性，但会带来一个明显的可伸缩性问题， 每次只有一个线程能够执行 compute. 如果另一个线程正在计算结果，那么其他调用compute 的线程可能被阻塞很长时间。如果有多个线程在排队等待还未计算出的结果，那么compute 方式的计算时间可能比没有“记忆”操作的计算时间更长

{% asset_img 五1.png %}

<br/>

改进：

```java
public class Memoizerl2<A,V> implements Computable<A,V> {

  @GuardedBy("this")
  private final Map<A, V> cache = new ConcurrentHashMap<>();
  private final Computable<A,V> c;

  public Memoizerl2(Computable<A,V> c){
    this.c = c;
  }

  @Override
  public V compute(A arg) throws InterruptedException {

    V result = cache.get(arg);
    if(result == null){
      result = c.compute(arg);
      cache.put(arg,result);
    }
    return result;
  }
}
```

多线程可以并发地访问它，但是当两个线程同时调用 compute 时存在一个漏洞，可能会导致计算得到相同的值。在使用memoization 的情况下，这只会带来低效，因为缓存的作用是避免相同的数据被计算多次。但对于更通用的缓存机制来说，这种情况将更为糟糕。对于只提供单次初始化的对象缓存来说，这个漏洞就会带来安全风险。

问题：

{% asset_img 五2.png %}

<br/>



改进：

```java
public class Memoizerl3<A,V> implements Computable<A,V> {

  private final Map<A, Future<V>> cache = new ConcurrentHashMap<>();

  private final Computable<A,V> c;

  public Memoizerl3(Computable<A,V> c){
    this.c = c;
  }

  @Override
  public V compute(A arg) throws InterruptedException {

    Future<V> f = cache.get(arg);

    if(f == null){
      Callable<V> eval = new Callable<V>() {
        @Override
        public V call() throws Exception {
          return c.compute(arg);
        }
      };
      FutureTask<V> ft = new FutureTask<V>(eval);
      f = ft;
      cache.put(arg,ft);//FutureTask也实现了Future接口，这里可能出现这个线程还没有put进去，又进来一个线程，此时仍然会出现计算两次的情况。这也是最终解决方案中需要判断两次f是否等于null的原因。
      ft.run();//在这里将调用c.compute()，FutureTask 实现了runnable接口，
    }
    try{
      return f.get();
    }catch (ExecutionException e){
      throw LaunderThrowable(e.getCause());
    }

  }
}
```

​	将用于缓存值的Map 重新定义为ConcurrentHashMap＜A，Future<V> >，替换原来的ConcurrentHashMap<A. V＞。Memoizer3 首先检查某个相应的计算是否已经开始（ Memoizer2 与之相反，它首先判断某个计算是否已经完成〉。如果还没有启动，那么就创建一个Futureτask，并拉册到Map 中，然后启动计算：如果已经启动，那么等待现有计算的结果。结果可能很快会得到，也可能还在边算过程中，但这对于Future.get 的调用者来说是透明的。

<br/>

问题：

仍然存在两个线程计算出相同值的漏洞。

由于compute 方法中的if 代码块仍然是非原子（nonatomic）的“先检查再执行”操作，因此两个线程仍又可能在同一时间内调用compute 来计算相同的值，

{% asset_img 五3.png %}

复合操作（“若没有则添加”〉是在底层的Map 对象上执行的，而这个对象无法通过加锁来确保原子性。

<br/>

Memoizer 的最终实现

```java
public class Memoizerl<A,V> implements Computable<A,V> {

  private final Map<A, Future<V>> cache = new ConcurrentHashMap<>();

  private final Computable<A,V> c;

  public Memoizerl(Computable<A,V> c){
    this.c = c;
  }

  @Override
  public V compute(A arg) throws InterruptedException {

    while(true){
      Future<V> f = cache.get(arg);

      if(f == null){
        Callable<V> eval = new Callable<V>() {
          @Override
          public V call() throws Exception {
            return c.compute(arg);
          }
        };

        FutureTask<V> ft = new FutureTask<V>(eval);
        f = cache.putIfAbsent(arg,ft);//因为多个线程可能同时到达这里，那么第二个线程就应该返回空。
        							//这样做是为了防止重复值的计算。
        if(f == null){//这里为什么还要判断一下呢？
          f = ft;
          ft.run();//如果f不为null了，就说明比它先进来的线程已经计算完了，它就不用算了。是null才需要计算，
        }
      }

      try {
        return f.get();
      }catch (CancellationException e){
        cache.remove(arg,f);  //计算错误要移除。
      }catch (ExecutionException e){
        throw LaunderThrowable(e.getCause());
      }
    }
  }
}
```

<br/>

当缓存的是Future 而不是值时，将导致缓存污染 ( Cache Pollution）问题：如果某个计算被取消或者失败，那么在计算这个错果时将指明计算过程被取消或者失散。为了避免这种情况，如果Memoizer 发现计算被取消，那么将花Future 从缓存中移除。如果检测到RuntimeException，那么也会移除Future，这样将来的计算才可能成功。

<br/>

在因式分解servlet 中使用Memoizer 来缓存结果

不仅高效，可扩展性更好。

```java
public class Factorizer implements Servlet{

  private final Computable<BigInteger,BigInteger> c = new Computable<BigInteger, BigInteger>() {
    @Override
    public BigInteger compute(BigInteger arg) throws InterruptedException {
      return factor(arg);
    }
  };
  @Override
  public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {

    try {
      BigInteger i = extractFromRequest(req);
      encodeIntoResposne(resp,cache.compute(i));
    }catch (InterruptedException e){
      encodeError(resp,"'factorization interrupted");
    }
  }
}
```



<br/>

<br/>

## 总结：

1. 可变状态是至关重要的，所有的并发问题都可以归结为对并发状态的访问，可变状态越少，就越容易确保线程安全性。
2. 尽量将于声明为final类型，除非需要它们是可变的。
3. 不可变对象一定是线程安全的，不可变对象能极大的降低并发编程的复杂性，他们更为简单而且安全，可以任意共享而无须使用加锁或保护性复制等机制。
4. 封装有助于管理复杂性，在编写线程安全的程序时，虽然可以将所有数据都保存在全局变量中，但为什么要这么做？将数据封装在对象中，更易于维持不变性条件，将同步机制封装在对象中，更易于遵循同步策略。
5. 用锁来保护每一个可变变量。
6. 当保护同一个不变性条件中的所有变量时，要使用同一个锁。
7. 在执行复合操作时，要持有锁。
8. 如果从多个线程中访问同一个可变变量时没有同步机制，那么程序会出现问题。
9. 不要故作聪明的推断出不需要使用同步。
10. 在设计过程中考虑线程安全，或者在文档中明确的指出它不是线程安全的。
11. 将同步策略文档化。

