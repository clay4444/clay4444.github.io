---
title: 算法进阶第一课
categories:
  - leetcode
abbrlink: 3fcd1ef8
date: 2019-03-10 11:11:29
---

### kmp

两个字符串 str1，str2，str1中存在一个子串，和str2相同，返回子串的第一个index，

时间复杂度 O(N)

<br/>

子序列：可以不连续，

子串 / 子数组：必须连续，

<br/>

笨办法：

一个一个的匹配。时间复杂度 O(N*M) ，N是str1的长度，M是str2的长度；

{% asset_img picture1.jpg %}

<br/>

时间复杂度高的原因是：考察从str1中的任何一个点去匹配str2的时候，每个这个过程都是完全独立的，

kmp这个算法就是想办法加速这个过程；

<br/>

基本概念的建设：

一个字符之前的字符串最长前缀和最长后缀的匹配长度

限定：前缀不能取最后一个字符，后缀不能取第一个字符；

例如：图示表示b位置的最长前缀和最长后缀的匹配长度为3，此时abc=abc

{% asset_img picture2.jpg %}

<br/>

第一步假设有一个方法，参数传递一个字符串，返回一个字符串长度的数组，数组每个index的值就是：这个字符

之前的字符串最长前缀和最长后缀的匹配长度，根据str2生成这样一个next 数组；

{% asset_img picture3.jpg %}

<br/>

假设str1中i位置开始和str2匹配，假设到某一个位置，不匹配了，这个位置再str1中记为x，在str2中记为y，接下来笨办法要做的是str1从i+1位置开始，继续和str2匹配，而kmp的做法是：在next数组中找到y位置对应的之前字符串的最长前缀和最长后缀的匹配长度，然后从y位置往前推最长后缀这么长，再对应到str1数组中，找到str1中j点，然后把str2往后推一段距离（看图示，推到0位置和str1中的j位置匹配），从j位置开始匹配，又因为图中四个涂黑的位置都是相等的（都是最长后缀），所以从str1的x位置和str2的z位置开始往后匹配即可；

{% asset_img picture4.jpg %}

<br/>

举例图示：

{% asset_img picture5.jpg %}

<br/>

{% asset_img picture6.jpg %}

<br/>

{% asset_img picture7.jpg %}

<br/>

本质：

这样推动str2的原因是我们没有否定从str1的j位置开始，str1可以匹配到str2，因为内四个涂黑的位置都是相等的，所以可以从str1的x位置开始匹配，我们否定的只是str1的i位置到j位置，中间的位置，都是不能匹配出str2的；为什么呢？

看图示：假设从k位置（str1的i位置到j位置）开始匹配，可以匹配到str2，那么从k位置到x位置之间的这个字符串（绿1），肯定和str2开始这么长的位置完全一致（绿2），又因为开始的时候，str1和str2是从x位置和y位置开始不匹配的，那么绿1和绿3应该一致，那么绿2和lv3就应该完全一致，那么说明又找到了**更长的**str2中y位置的之前字符串最长前缀和最长后缀的匹配长度，之间求出来的最长匹配长度是红1和红2，这在之前求出的结果是正确的情况下是不可能的。

{% asset_img picture8.jpg %}

<br/>

next数组的求法：

0位置-1，1位置如果和0位置相等，就是1，否则是0；

现在假设求a位置的最长后缀，而且已知b位置的最长后缀为4，那么就看前面第一个最长后缀的下一个字符，如果和b相等，那么a位置的最长后缀长度就等于b位置的最长后缀长度+1，也就是5，注意：如果不相等，结果也不等于b位置的最长后缀；

{% asset_img picture9.jpg %}

<br/>

原因：

假设对a来说，最长后缀长度为6，那么第二个最长后缀的结尾部分是b，因为b是a前面一个字符，那么第一个最长后缀的结尾部分是b，那么中间两个小圈的长度就是5，那么按照这种说法，b的最长后缀长度就是5，而不是4，所以之前求的就是错误的，所以：i位置的最长后缀长度最多就是i-1位置的最长后缀长度+1，不可能存在更长的；因为如果存在更长的，我们就可以反推i-1位置的求出来的结果是错误的；

{% asset_img picture10.jpg %}

<br/>

如果i-1的第一个最长后缀的下一个字符不等于b，b位置的最长后缀是多少呢？

{% asset_img picture11.jpg %}

先看b位置的第一个最长后缀的下一个字符是否和b相等，相等，结果就是b位置的最长后缀长度+1，不相等，就看c位置的第一个最长后缀的下一个字符是否和b相等，相等，结果就是c位置的最长后缀长度+1，不相等就继续往下找，直到找不到，就是0；

<br/>

举例：为0的例子

{% asset_img picture12.jpg %}

<br/>

举例：不为0的例子

{% asset_img picture13.jpg %}

<br/>

代码：

```java
public class Code_01_KMP {

	public static int getIndexOf(String s, String m) {
		if (s == null || m == null || m.length() < 1 || s.length() < m.length()) {
			return -1;
		}
		char[] ss = s.toCharArray();
		char[] ms = m.toCharArray();
		int si = 0;    // 指向str1
		int mi = 0;    // 指向str2
		int[] next = getNextArray(ms);
		//注意整个过程中，si是一直往后走的，而 且每次判断si开始是否包含str2的时候，并没有每次遍历str2，
		//而只是在ss[si] != ms[mi]的时候，进行跳数组的操作，相等的时候，是没有尝试匹配的，
		//原因查看当时的解析即可；
		while (si < ss.length && mi < ms.length) { //si指向str1，mi指向str2
			if (ss[si] == ms[mi]) {  //相等，同时++
				si++;
				mi++;
			} else{
				if (next[mi] == -1) {   //next 数组中0位置我们定为-1，因为0位置前面不可能有最长后缀
					//mi往前跳的时候，是根据next数组中对应位置的值来跳的，=-1，说明没得跳了，已经指向str2的0位置了；
					//mi已经指向第一个字符了，还是配不上，说明si之后不可能匹配到整个str2，si++，检查下一个字符是否能够匹配
					si++;
				} else {
					mi = next[mi];   // 能往前就往前跳; 其实这就是str2往后推的逻辑概念
				}
			}
		}
		return mi == ms.length ? si - mi : -1;
	}

	/**
	 * 求解next数组
	 */
	public static int[] getNextArray(char[] ms) {
		if (ms.length == 1) {
			return new int[] { -1 };
		}
		int[] next = new int[ms.length];
		next[0] = -1;
		next[1] = 0;
		int pos = 2; //来到的位置
		int cn = 0;   // 跳到的位置
		while (pos < next.length) {  // pos不断增加，每一个位置都要求出来，
			if (ms[pos - 1] == ms[cn]) {  //如果当前跳到的位置和前一个字符是一致的，i位置的最长后缀长度就是i-1位置最长后缀长度+1
				next[pos++] = ++cn;  //cn其实就是第一个最长后缀的下一个字符，所以跳到cn就表示第一个最长后缀的长度就是cn，那么pos位置的最长后缀长度就是:cn+1
			} else if (cn > 0) {  //不相等，就再往前跳
				cn = next[cn];  //next[cn]就表示cn位置的最长后缀长度，也就是跳到第一个最长后缀的下一个字符，
			} else {
				next[pos++] = 0; //cn <= 0，说明跳到头了；pos位置的最长后缀长度就是0；
			}
		}
		return next;
	}

	public static void main(String[] args) {
		String str = "abcabcababaccc";
		String match = "ababa";
		System.out.println(getIndexOf(str, match));
	}
}
```

<br/>

### 应用：大字符串的生成

原始字符ABCABC，生成一个大字符串，只能在后面添加字符，要求生成的大字符是长度最短的，还要包含两个原始串，开头的位置不能一样，例如：对于abcabc来说，abcabcabc是最符合的，包含两个abcabc，且两个原串的开头位置不一样，且是符合条件的大串中最短的；

<br/>

解法：

对原始字符串求next数组，多求最后一位的最长后缀长度，然后从原串中以求出来的最长后缀长度为index截断，取后面的子串，拼接在原串的后面，就是最终的结果；

<br/>

代码：

```java
public class Code_02_KMP_ShortestHaveTwice {

	public static String answer(String str) {
		if (str == null || str.length() == 0) {
			return "";
		}
		char[] chas = str.toCharArray();
		if (chas.length == 1) {
			return str + str;
		}
		if (chas.length == 2) {
			return chas[0] == chas[1] ? (str + String.valueOf(chas[0])) : (str + str);
		}
		int endNext = endNextLength(chas);
		return str + str.substring(endNext);
	}

	/**
	 * @param chas 原串
	 * @return  多出来的内一位对应的最长后缀长度
	 */
	public static int endNextLength(char[] chas) {
		int[] next = new int[chas.length + 1]; //长度+1，因为要求最后一位后面的位置的最长后缀长度
		next[0] = -1;
		next[1] = 0;
		int pos = 2; 	//求哪个位置的最长后缀；
		int cn = 0;		// 跳到的位置，也就是第一个最长后缀的下一个位置；
		while (pos < next.length) {
			if (chas[pos - 1] == chas[cn]) {
				next[pos++] = ++cn;
			} else if (cn > 0) {
				cn = next[cn];
			} else {
				next[pos++] = 0;
			}
		}
		return next[next.length - 1];
	}

	public static void main(String[] args) {
		String test1 = "a";
		System.out.println(answer(test1));

		String test2 = "aa";
		System.out.println(answer(test2));

		String test3 = "ab";
		System.out.println(answer(test3));

		String test4 = "abcdabcd";
		System.out.println(answer(test4));

		String test5 = "abracadabra";
		System.out.println(answer(test5));
	}
}
```

<br/>

### 应用：树包含问题

两颗树，判断t1中是否有一棵子树，和t2完全一致；

{% asset_img picture14.jpg %}

图中的情况应该返回false，因为要子树就应该要全部的子节点；

<br/>

解法：

把t1序列化成一个字符串s1，t2序列化成一个字符串s2，然后判断s2是否是s1的字符串(KMP)，如果是，则t1包含t2；

<br/>

代码

```java
public class Code_03_KMP_T1SubtreeEqualsT2 {

	public static class Node {
		public int value;
		public Node left;
		public Node right;

		public Node(int data) {
			this.value = data;
		}
	}

	public static boolean isSubtree(Node t1, Node t2) {
		String t1Str = serialByPre(t1);
		String t2Str = serialByPre(t2);
		return getIndexOf(t1Str, t2Str) != -1;
	}

	public static String serialByPre(Node head) {
		if (head == null) {
			return "#!";
		}
		String res = head.value + "!";
		res += serialByPre(head.left);
		res += serialByPre(head.right);
		return res;
	}

	// KMP
	public static int getIndexOf(String s, String m) {
		if (s == null || m == null || m.length() < 1 || s.length() < m.length()) {
			return -1;
		}
		char[] ss = s.toCharArray();
		char[] ms = m.toCharArray();
		int[] nextArr = getNextArray(ms);
		int index = 0;
		int mi = 0;
		while (index < ss.length && mi < ms.length) {
			if (ss[index] == ms[mi]) {
				index++;
				mi++;
			} else if (nextArr[mi] == -1) {
				index++;
			} else {
				mi = nextArr[mi];
			}
		}
		return mi == ms.length ? index - mi : -1;
	}

	public static int[] getNextArray(char[] ms) {
		if (ms.length == 1) {
			return new int[] { -1 };
		}
		int[] nextArr = new int[ms.length];
		nextArr[0] = -1;
		nextArr[1] = 0;
		int pos = 2;
		int cn = 0;
		while (pos < nextArr.length) {
			if (ms[pos - 1] == ms[cn]) {
				nextArr[pos++] = ++cn;
			} else if (cn > 0) {
				cn = nextArr[cn];
			} else {
				nextArr[pos++] = 0;
			}
		}
		return nextArr;
	}

	public static void main(String[] args) {
		Node t1 = new Node(1);
		t1.left = new Node(2);
		t1.right = new Node(3);
		t1.left.left = new Node(4);
		t1.left.right = new Node(5);
		t1.right.left = new Node(6);
		t1.right.right = new Node(7);
		t1.left.left.right = new Node(8);
		t1.left.right.left = new Node(9);

		Node t2 = new Node(2);
		t2.left = new Node(4);
		t2.left.right = new Node(8);
		t2.right = new Node(5);
		t2.right.left = new Node(9);

		System.out.println(isSubtree(t1, t2));
	}
}
```

<br/>

<br/>

### Manacher算法：马拉车算法

一个字符串中找到最长回文子串；

121，1221，

<br/>

暴力解法：

从i位置向两边扩，如果i-1位置和i+1位置相等，就继续往两边扩，例如12321，从3开始向两边扩，得到正确结果5，但是如果是偶回文，1221，这种解法得到的结果是0，但正确结果是4

解决办法：

向两边位置和每两个字符之间都插入一个特殊符号#，再按照这种解法去做，然后把最后的结果/2，就是最终的结果，#这个特殊符号其实可以是任意字符，和之前的字符重复也没事，因为它是作为虚轴出现的，虚轴每次都是和虚轴对应的，实轴每次都和实轴对应，不可能出现虚轴和实轴对应的情况；

{% asset_img picture15.jpg %}

<br/>

时间复杂度：

O(N^2)， 

<br/>

Manacher

注意：马拉车算法默认也要在每个字符和两边中间加上特殊符号；

时间复杂度：

O(N) 

<br/>

回文直径：从一个位置向两边扩充的范围，就是回文直径；

三个概念：

1. 回文半径数组：准备一个数组，负责记录以每个位置为中心的情况下能够扩出来的一个回文半径的长度(这个数组就是我们要求的数组)；然后查看后面的结果是否能用前面的结果进行加速；

2. 所有回文半径中最靠右的位置： 每个字符对应的最长回文串，到达的最右边的位置；这个位置叫做所有回文半径中的回文右边界；

{% asset_img picture16.jpg %}

到图中的3位置时，回文右边界到达了最右边的0位置，之后再往右走，也没有超过最右边的0位置，所以回文右边界就是最右边的0位置；

3. 回文右边界的中心 ：和回文右边界的概念是对应的；这个中心就指的是以哪个字符作为中心扩充到的最右边界，

回文右边界永远记录的是能够扩到最右边的位置，回文右边界的中心指的是取得这个最右边的位置的时候，**最早的**中心在哪里，

下图中R就是回文右边界的位置，C就是回文右边界的中心；

{% asset_img picture17.jpg %}

<br/>

解法：

求以i位置为中心，最多能向两边扩多少，

1. 可能性1，i位置不在回文右边界之前；如下图所示，此时直接暴力往右边扩充回文右边界即可；

{% asset_img picture18.jpg %}

i在0位置时，R在-1位置，此时R直接扩充到0位置，i在1位置时，R直接扩充到2位置；i到了2位置时，R也在2位置，此时不属于情况1了；

2. 可能性2，i在回文右边界之前，再找到回文右边界在左边的对称点记为L，那么i位置肯定在C位置和R位置中间，因为i在R后面，说明肯定是i位置之前的一个字符产生的回文右边界R，否则i位置不可能在R里面；注意：此时正在计算i位置的回文右边界，不要想以i位置为C位置能到更右边；再找到i位置以C位置为原点的对称点i'位置，情况2说的就是i’位置产生的最长回文字符串彻底的在L和R中间；例子如下：

{% asset_img picture19.jpg %}

此时i位置的回文子串不用向两边扩；直接知道答案，和i'一样，

{% asset_img picture20.jpg %}

图中x和x'，y和y‘，小L和小L'，小R和小R'  等都是关于C点对称的，已知小L到小R是i‘位置的最长回文子串，所以小L‘到小R’也是i位置的最长回文子串，因为L到R是一个大的回文串，红1和红2是这个大串中相对应的两串，又因为红1和红2是彻底关于C位置对称的，所以红2是红1的逆序，回文串就是正序和逆序相等，所以红2也是一个回文串，然后证明红2不可能扩充的更大了，看图示，Y一定不等于X，否则红1可以扩的更大，最后得出结论X’不等于Y‘，所以红2是i位置的最长回文子串；

<br/>

3. 可能性3，还是上图的拓扑范围，但是i'自己的回文范围小L到小R，L到R中间没有包住，此时i位置的最长回文串长度半径就是i到R，如下图所示：

{% asset_img picture21.jpg %}

设定L’关于i‘位置和L点对称，R’关于i位置和R对称，所以红1、2、3、4都相等（因为L和R关于C对称，i和i’关于C对称，所以红1等于红4）。L‘关于C位置和R’对称（想一下就明白了，是回文串，所以C两边对应位置的数字都是对称的），又因为i‘的最长回文串是小L到小R，红1和红1长度又相等，所以绿1肯定是一个回文串，因为L到R是一个大的回文串，所以绿2也是一个回文串，x和x‘是L和R两边各延伸出的一个字符，所以x不等于x’，因为c位置的最长回文子串是L到R，这是已知的，又因为i‘的最长回文子串左边界超过了L，所以x和y’肯定相等，y‘和y相等（因为关于C点对称），所以x和y不相等，所以i位置的最长回文子串半径就是i位置到R位置；

<br/>

4. 可能性4，i’的回文半径左边界正好和L重叠，从i到R中间的肯定是属于回文子串的，但是R之后的还是不知道，需要再去遍历验证；

<br/>

其实只有两种情况，即i在R内部和在R外部，只不过i在R内部的情况又细分了三种情况（根据i‘的回文半径所在的范围细分的，因为i在R内部的时候，回文半径的情况需要根据i’的回文半径情况进行分析），即情况2、3、4；

<br/>

复杂度分析

{% asset_img picture22.jpg %}

情况二、三的复杂度都是O(1)，情况一、四，都是针对R进行操作的，而且R只可能向右边扩，不能回退，所以及时情况一、四发生了，R的变化范围也就是从0到原串长度，所以是O(N) 的复杂度

<br/>

三种可能情况举例示意图

{% asset_img picture23.jpg %}

<br/>

代码

```java
public class Code_04_Manacher {

	//给原串加上特殊字符#
	public static char[] manacherString(String str) {
		char[] charArr = str.toCharArray();
		char[] res = new char[str.length() * 2 + 1];
		int index = 0;
		for (int i = 0; i != res.length; i++) {
			res[i] = (i & 1) == 0 ? '#' : charArr[index++];
		}
		return res;
	}

	public static int maxLcpsLength(String str) {
		if (str == null || str.length() == 0) {
			return 0;
		}
		char[] charArr = manacherString(str);
		int[] pArr = new int[charArr.length];  //回文半径数组
		int index = -1; //C 位置
		int pR = -1;  //回文右边界
		int max = Integer.MIN_VALUE;
		for (int i = 0; i != charArr.length; i++) {  //以i位置为中心的回文串
			//2 * index - i就是i'的位置，pArr[2 * index - i]：i位置的回文半径，
			// i > pR,说明是情况1，i位置不在回文右边界之前，i位置的回文半径就先置为1，下面在继续往外扩；
			//如果是情况2，i'位置的回文半径在L和R内部，那么pArr[2 * index - i] < pR - i，那么i位置的回文半径就是i'位置的回文半径
			//如果是情况3，i'位置的回文半径在L外部，那么pArr[2 * index - i] > pR - i,那么i位置的回文半径就是i到R的长度；
			//pR > i:情况2，3，4； pR < i:情况1，
			pArr[i] = pR > i ? Math.min(pArr[2 * index - i], pR - i) : 1;

			//不管是哪种情况，都往外扩一下，i + pArr[i] < charArr.length 左边不越界，i - pArr[i] > -1 右边不越界
			//当然这里可以写成4个if else，但是代码会很长；所以这里直接扩，只是情况2，3扩一下会直接停；
			while (i + pArr[i] < charArr.length && i - pArr[i] > -1) {
				if (charArr[i + pArr[i]] == charArr[i - pArr[i]]) //扩出来的两个值相等，
					pArr[i]++;  // 回文半径 ++
				else {
					break;
				}
			}
			if (i + pArr[i] > pR) {  //扩出来的区域超过了R，
				pR = i + pArr[i]; 	//新的回文右边界
				index = i;			// C位置；
			}
			max = Math.max(max, pArr[i]); // 记录全局最大值
		}
		return max - 1;
	}

	public static void main(String[] args) {
		String str1 = "abc1234321ab";
		System.out.println(maxLcpsLength(str1));
	}
}
```

<br/>

<br/>

### 应用：一个字符串只能向后面添加字符，如何让它变成回文串，且要求添加的最短；

abc12321

abc12321cba

<br/>

解法

求必须包含最后一个字符的情况下，最长回文子串是多少，然后把不是的部分，逆序过来，填在原串部分，就是答案；

<br/>

Manacher算法的改写

在进行计算的过程中，当R到达字符串右边界的时候，这时C正好就是第一个让R到达右边界的字符，然后找到R关于C点的对称点L，L到R形成的子串就是**包含最后一个字符的最长回文字符串**（这正好就是我们要求的），然后把L之前的字符串逆序过来，放在原串的后面，就是最终的结果，

也就是算法不是计算到最后停，而是只要回文右边界R到达字符串结尾，就停；

{% asset_img picture24.jpg %}

<br/>

代码

```java
public class Code_05_Manacher_ShortestEnd {

	public static char[] manacherString(String str) {
		char[] charArr = str.toCharArray();
		char[] res = new char[str.length() * 2 + 1];
		int index = 0;
		for (int i = 0; i != res.length; i++) {
			res[i] = (i & 1) == 0 ? '#' : charArr[index++];
		}
		return res;
	}

	public static String shortestEnd(String str) {
		if (str == null || str.length() == 0) {
			return null;
		}
		char[] charArr = manacherString(str);
		int[] pArr = new int[charArr.length];
		int index = -1;
		int pR = -1;
		int maxContainsEnd = -1;
		for (int i = 0; i != charArr.length; i++) {
			pArr[i] = pR > i ? Math.min(pArr[2 * index - i], pR - i) : 1;
			while (i + pArr[i] < charArr.length && i - pArr[i] > -1) {
				if (charArr[i + pArr[i]] == charArr[i - pArr[i]])
					pArr[i]++;
				else {
					break;
				}
			}
			if (i + pArr[i] > pR) {
				pR = i + pArr[i];
				index = i;
			}
			if (pR == charArr.length) {  //最右边界到了最右边，直接break；
				maxContainsEnd = pArr[i];
				break;
			}
		}
		char[] res = new char[str.length() - maxContainsEnd + 1];
		for (int i = 0; i < res.length; i++) {
			res[res.length - 1 - i] = charArr[i * 2 + 1];
		}
		return String.valueOf(res);
	}

	public static void main(String[] args) {
		String str2 = "abcd123321";
		System.out.println(shortestEnd(str2));
	}
}
```

<br/>

### BFPRT 算法

解决的问题：

求一个无序数组中第k小的数：

<br/>

时间复杂度

O(N)

<br/>

一种足够优良并且容易理解的解法：

快排partition的过程，总共1000个数字，先随机选择一个数字作为划分值，最后的划分结果是500到600是等于区域，假如我们要取得就是第550小数字，那么这一次就找到了，假如要取第300小的数字，就在左边的partition继续划分，假如要取第800小的数字，就在右边的partition继续划分；总会找到；

{% asset_img picture25.jpg %}

这个算法的时间复杂度

O(N)，和快排的不一样，因为快排需要对两侧继续递归处理，但是这个只需要处理一侧，

这个时间复杂度也是基于随机选择的内个数字的情况（可能打在正中间，此时剩余两部分各占N/2，也可能每次都打偏，这时时间复杂度就是O(N^2)）来求得长期期望得到的；退到过程可以忽略；

<br/>

bfprt是严格O(N)，而上面partition是基于概率的；

bfprt和上面的过程其实是非常相似的，整体过程都一致，只是获取划分值的时候，不是随机选择的，就这么一个区别

<br/>

解法：

1. 分组，每五个数字一组
2. 每个小组之间排序，跨组不保证有序，5个数字排序O(1)，总共N/5 组，所以这一步的时间复杂度是O(N)
3. 每个组中取得中位数，组成一个新的数组，长度N/5，时间复杂度是O(N)
4. 递归调用bfprt算法（参数是一个arr，一个k: 第k大的数），把第三步形成的新数组传进去，找的数是这个新数组的中位数(new_arr / 2)；这一步要做的事就是找到所有组的中位数中的中位数，而bfprt的功能是找到一个数组中第k小的数字，10个数字，中位数就是第5小的数字，12个数字，中位数就是第六小的数字；所以传参就是(new_arr / 2)，这时正好返回结果就是new_arr这个新数组的中位数：记为number。这时一个递归的过程，时间复杂度是T(N/5)
5. 下面的过程就用第四步的返回结果number进行划分，小于num的放左边，大于number的放右边；时间复杂度是O(N)
6. 查看命中了没有；没有命中，继续选择一侧走；

{% asset_img picture26.jpg %}

<br/>

问题：为什么选择这样一个值？

这个算法要做到的目的就是：按照最差情况估计，时间复杂度要做到O(N)，那么就要看第五步partition的规模，因为第一个解法有可能出现O(N^2)的原因就是随机取得划分值有可能打偏，那么再来看这个解法，我们要按照最差情况估计左侧规模和右侧规模的大小，左侧的规模意味着有多少个数字比number小，那么左侧最差情况就是选择的number划分值， 即便是最差的情况，最多有多少个数比number小，也就是左侧能够达到的最大规模；同理，右侧最多有多少个数比number要大。要求左侧最多有多少个数字比number小，求最多有多少个数字比num小可以转化为求至少有多少个数字比num大，如何估计至少有多少个数字比num要大呢？看下图示例：

{% asset_img picture27.jpg %}

总工有N个数，所有的中位数组成的数组（粉框）长度就是N/5，假设中间的数字蓝框正好是新数组的中位数，那就意味着会有N/10个数比蓝框要大（两个黄色的框），这是因为蓝框是中位数；又因为黄框是每个组中的中位数，所以这两个黄框所在的组中，又各自有两个数字比黄框的数要大，所以总共就至少有3N/10个数比蓝框要大；注意这里是**至少**有3N/10个数比蓝框要大；因为在两个黄框的所属组中， 比黄框小的数也有可能比蓝框数字要大，比如下面的情况：黄框圈住的数字都比7要大

{% asset_img picture28.jpg %}

<br/>

得证：至少有3N/10个数比num大，所以最多有7N/10个数比num小，所以最差划分的规模就是7N/10

<br/>

整体时间复杂度总结

{% asset_img picture29.jpg %}

算法导论第九章都在证明圈住的公式的结果就是O(N)

<br/>

代码：

```java
public class Code_06_BFPRT {

	// O(N*logK)
	public static int[] getMinKNumsByHeap(int[] arr, int k) {
		if (k < 1 || k > arr.length) {
			return arr;
		}
		int[] kHeap = new int[k];
		for (int i = 0; i != k; i++) {
			heapInsert(kHeap, arr[i], i);
		}
		for (int i = k; i != arr.length; i++) {
			if (arr[i] < kHeap[0]) {
				kHeap[0] = arr[i];
				heapify(kHeap, 0, k);
			}
		}
		return kHeap;
	}

	public static void heapInsert(int[] arr, int value, int index) {
		arr[index] = value;
		while (index != 0) {
			int parent = (index - 1) / 2;
			if (arr[parent] < arr[index]) {
				swap(arr, parent, index);
				index = parent;
			} else {
				break;
			}
		}
	}

	public static void heapify(int[] arr, int index, int heapSize) {
		int left = index * 2 + 1;
		int right = index * 2 + 2;
		int largest = index;
		while (left < heapSize) {
			if (arr[left] > arr[index]) {
				largest = left;
			}
			if (right < heapSize && arr[right] > arr[largest]) {
				largest = right;
			}
			if (largest != index) {
				swap(arr, largest, index);
			} else {
				break;
			}
			index = largest;
			left = index * 2 + 1;
			right = index * 2 + 2;
		}
	}

	// O(N)
	public static int[] getMinKNumsByBFPRT(int[] arr, int k) {
		if (k < 1 || k > arr.length) {
			return arr;
		}
		int minKth = getMinKthByBFPRT(arr, k);
		int[] res = new int[k];
		int index = 0;
		for (int i = 0; i != arr.length; i++) {
			if (arr[i] < minKth) {
				res[index++] = arr[i];
			}
		}
		for (; index != res.length; index++) {
			res[index] = minKth;
		}
		return res;
	}

	public static int getMinKthByBFPRT(int[] arr, int K) {
		int[] copyArr = copyArray(arr);
		return bfprt(copyArr, 0, copyArr.length - 1, K - 1);
	}

	public static int[] copyArray(int[] arr) {
		int[] res = new int[arr.length];
		for (int i = 0; i != res.length; i++) {
			res[i] = arr[i];
		}
		return res;
	}

	//bfprt 算法本体，在begin和end范围内求第i小的数字；
	public static int bfprt(int[] arr, int begin, int end, int i) {
		if (begin == end) {
			return arr[begin];
		}
		//求划分值，5个值一组，求所有中位数的中位数，
		int pivot = medianOfMedians(arr, begin, end);
		//partition过程，返回等于区域
		int[] pivotRange = partition(arr, begin, end, pivot);
 		//命中直接返回，否则递归处理
		if (i >= pivotRange[0] && i <= pivotRange[1]) {
			return arr[i];
		} else if (i < pivotRange[0]) {
			return bfprt(arr, begin, pivotRange[0] - 1, i);
		} else {
			return bfprt(arr, pivotRange[1] + 1, end, i);
		}
	}

	public static int medianOfMedians(int[] arr, int begin, int end) {
		int num = end - begin + 1;
		int offset = num % 5 == 0 ? 0 : 1;
		int[] mArr = new int[num / 5 + offset];
		for (int i = 0; i < mArr.length; i++) {
			int beginI = begin + i * 5;
			int endI = beginI + 4;
			mArr[i] = getMedian(arr, beginI, Math.min(end, endI));
		}
		return bfprt(mArr, 0, mArr.length - 1, mArr.length / 2);
	}

	public static int[] partition(int[] arr, int begin, int end, int pivotValue) {
		int small = begin - 1;
		int cur = begin;
		int big = end + 1;
		while (cur != big) {
			if (arr[cur] < pivotValue) {
				swap(arr, ++small, cur++);
			} else if (arr[cur] > pivotValue) {
				swap(arr, cur, --big);
			} else {
				cur++;
			}
		}
		int[] range = new int[2];
		range[0] = small + 1;
		range[1] = big - 1;
		return range;
	}

	public static int getMedian(int[] arr, int begin, int end) {
		insertionSort(arr, begin, end);
		int sum = end + begin;
		int mid = (sum / 2) + (sum % 2);
		return arr[mid];
	}

	public static void insertionSort(int[] arr, int begin, int end) {
		for (int i = begin + 1; i != end + 1; i++) {
			for (int j = i; j != begin; j--) {
				if (arr[j - 1] > arr[j]) {
					swap(arr, j - 1, j);
				} else {
					break;
				}
			}
		}
	}

	public static void swap(int[] arr, int index1, int index2) {
		int tmp = arr[index1];
		arr[index1] = arr[index2];
		arr[index2] = tmp;
	}

	public static void printArray(int[] arr) {
		for (int i = 0; i != arr.length; i++) {
			System.out.print(arr[i] + " ");
		}
		System.out.println();
	}

	public static void main(String[] args) {
		int[] arr = { 6, 9, 1, 3, 1, 2, 2, 5, 6, 1, 3, 5, 9, 7, 2, 5, 6, 1, 9 };
		// sorted : { 1, 1, 1, 1, 2, 2, 2, 3, 3, 5, 5, 5, 6, 6, 6, 7, 9, 9, 9 }
		printArray(getMinKNumsByHeap(arr, 10));
		printArray(getMinKNumsByBFPRT(arr, 10));
	}
}
```