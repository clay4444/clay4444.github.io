---
title: 算法基础第八课
categories:
  - leetcode
abbrlink: 5a6a5509
date: 2019-02-26 10:07:11
---

### n 的阶乘

<br/>

代码：

```java
public class Code_01_Factorial {

    /**
     * 递归
     */
	public static long getFactorial1(int n) {
		if (n == 1) {
			return 1L;
		}
		return (long) n * getFactorial1(n - 1);
	}

    /**
     * 第一种方法：我知道怎么试。
     */
	public static long getFactorial2(int n) {
		long result = 1L;
		for (int i = 1; i <= n; i++) {
			result *= i;
		}
		return result;
	}

	public static void main(String[] args) {
		int n = 5;
		System.out.println(getFactorial1(n));
		System.out.println(getFactorial2(n));
	}
}
```

<br/>

### 汉诺塔

目标：把左边的杆上的盘子借助中间的杆，移动到右边的杆上；

要求：任何时刻不能违反小压大的原则； 

题目：给定一个N层的盘子，打印所有移动的步骤；

<br/>

{% asset_img picture12.jpg %}

 <br/>

代码：

```java
/**
 * 汉诺塔问题
 *
 * 第一步：把1~（n-1）从from移动到help上去。
 * 第二步：把单独的n移动到to上去。
 * 第三步：把1~（n-1）从help移动到to上去。
 */
public class Code_02_Hanoi {

	public static void hanoi(int n) {
		if (n > 0) {
			func(n, "left", "right", "mid");
		}
	}

    /**
     * @param N：N层
     * @param from
     * @param to
     * @param help
     */
	public static void func(int N,String from, String to,String help){
        if(N == 1){
            System.out.println("Move 1 from " + from + "to" + to);
        }else{
            //第一步：把1~（n-1）从from移动到help上去，可以借助的杆是to
            process(N-1,from,help,to);
            //第二步：把单独的n移动到to上去。
            System.out.println("Move " + N + " form " + from + "to" + to);
            //第三步：把1~（n-1）从help移动到to上去。
            process(N-1,help,to,from);
        }
    }

	public static void moveLeftToRight(int N) {
		if (N == 1) {
			System.out.println("move 1 from left to right");
		}
		moveLeftToMid(N - 1);
		System.out.println("move " + N + "from left to right");
		moveMidToRight(N - 1);
	}

	public static void moveRightToLeft(int N) {

	}

	public static void moveLeftToMid(int N) {
		if (N == 1) {
			System.out.println("move 1 from left to mid");
		}
		moveLeftToRight(N - 1);
		System.out.println("move " + N + "from left to mid");
		moveRightToMid(N - 1);
	}

	public static void moveMidToLeft(int N) {

	}

	public static void moveRightToMid(int N) {

	}

	public static void moveMidToRight(int N) {
		if (N == 1) {
			System.out.println("move 1 from mid to right");
		}
		moveMidToLeft(N - 1);
		System.out.println("move " + N + "from mid to right");
		moveLeftToRight(N - 1);
	}

	public static void main(String[] args) {
		int n = 3;
		hanoi(n);
	}
}
```

<br/>

###  打印一个字符串的全部子序列，包括空

{% asset_img picture1.jpg %}

每一个位置都有两个选择，要不要a，要不要b，。。。。

<br/>

代码

```java
/**
 * 打印一个字符串的所有子序列
 * 打算怎么尝试
 * 图片：穷尽所有的子序列
 * 树形图：每个字符串的位置都会有两个决策：1.要当前的字符，2.不要当前的字符
 * 这样就可以穷尽所有的子序列情况。
 */
public class Code_03_Print_All_Subsquences {

	public static void printAllSubsquence(String str) {
		char[] chs = str.toCharArray();
		process(chs, 0);
	}

	public static void process(char[] chs, int i) {
		if (i == chs.length) {
			System.out.println(String.valueOf(chs));
			return;
		}
		process(chs, i + 1);
		char tmp = chs[i];
		chs[i] = 0;
		process(chs, i + 1);
		chs[i] = tmp;
	}
	
	public static void function(String str) {
		char[] chs = str.toCharArray();
		process(chs, 0, new ArrayList<Character>());
	}
	
	public static void process(char[] chs, int i, List<Character> res) {
		if(i == chs.length) {
			printList(res);
		}
		List<Character> resKeep = copyList(res);
		resKeep.add(chs[i]);
		process(chs, i+1, resKeep);
		List<Character> resNoInclude = copyList(res);
		process(chs, i+1, resNoInclude);
	}
	
	public static void printList(List<Character> res) {
		// ...;
	}
	
	public static List<Character> copyList(List<Character> list){
		return null;
	}

    /**
     * 打印所有的子序列
     * res: 就是上级扔给我的字符串
     */
	public static void printAllSub(char[] str, int i,String res){

	    if(i == str.length){
            System.out.println(res);
            return;
        }

        /**
         * 每一步两条路都要走。要么不要当前的字符，要么要当前的字符。
         */
        printAllSub(str,i+1,res);//不要当前字符
        printAllSub(str,i+1,res+str[i]);//要当前字符
    }

	public static void main(String[] args) {
		String test = "abc";
		//printAllSubsquence(test);
        printAllSub(test.toCharArray(),0,"");
	}
}
```

<br/><br/>

### 打印全排列

<br/>

{% asset_img picture2.jpg %}

<br/>

```java
public class Code_04_Print_All_Permutations {

	public static void printAllPermutations1(String str) {
		char[] chs = str.toCharArray();
		process1(chs, 0);
	}

    /**
     * 等于0的时候：把0位置处的字符换位置
     * 等于1的时候：把1位置处的字符和后续换位置
     * 等于2的时候：其实就可以返回了，但是也可以想象成把3位置处的字符和后续换位置
     * 图示：字符串的全排列问题。
     * @param chs
     * @param i
     */
	public static void process1(char[] chs, int i) {
		if (i == chs.length-1) {
			System.out.println(String.valueOf(chs));
		}
		for (int j = i; j < chs.length; j++) {
			swap(chs, i, j);
			process1(chs, i + 1);
			swap(chs, i, j);//换位置之后，最后记得换回来，供下一次的循环使用。
		}
	}

	public static void printAllPermutations2(String str) {
		char[] chs = str.toCharArray();
		process2(chs, 0);
	}

	public static void process2(char[] chs, int i) {
		if (i == chs.length) {
			System.out.println(String.valueOf(chs));
		}
		HashSet<Character> set = new HashSet<>();
		for (int j = i; j < chs.length; j++) {
			if (!set.contains(chs[j])) {
				set.add(chs[j]);
				swap(chs, i, j);
				process2(chs, i + 1);
				swap(chs, i, j);
			}
		}
	}

	public static void swap(char[] chs, int i, int j) {
		char tmp = chs[i];
		chs[i] = chs[j];
		chs[j] = tmp;
	}

	public static void main(String[] args) {
		String test1 = "abc";
		printAllPermutations1(test1);
		System.out.println("======");
		printAllPermutations2(test1);
		System.out.println("======");

		String test2 = "acc";
		printAllPermutations1(test2);
		System.out.println("======");
		printAllPermutations2(test2);
		System.out.println("======");
	}
}
```

<br/>

### 母牛的数量

母牛每年生一只母牛，新出生的母牛三年后也能每年生一只母牛，假设不会死，求N年后，母牛的数量

{% asset_img picture3.jpg %}

今年的牛=去年的牛+3年前的牛的数目(只有三年前的牛成熟了可以新生牛)

<br/>

代码：

```java
/**
 * 母牛生牛问题
 * F(n) = F(n-1) + F(n-3)
 * 今年的牛数量 = 去年的牛数量 + 三年前牛的数量(因为三年前的牛已经可以生牛了)
 * 假设所有的牛都不会死。
 */
public class Code_05_Cow {

	public static int cowNumber1(int n) {
		if (n < 1) {
			return 0;
		}
		if (n == 1 || n == 2 || n == 3) {
			return n;
		}
		return cowNumber1(n - 1) + cowNumber1(n - 3);
	}

	public static int cowNumber2(int n) {
		if (n < 1) {
			return 0;
		}
		if (n == 1 || n == 2 || n == 3) {
			return n;
		}
		int res = 3;
		int pre = 2;
		int prepre = 1;
		int tmp1 = 0;
		int tmp2 = 0;
		for (int i = 4; i <= n; i++) {
			tmp1 = res;
			tmp2 = pre;
			res = res + prepre;
			pre = tmp1;
			prepre = tmp2;
		}
		return res;
	}

	public static void main(String[] args) {
		int n = 20;
		System.out.println(cowNumber1(n));
		System.out.println(cowNumber2(n));
	}
}
```

<br/>

### 最小路径和

二维数组，数组中的每个数都是正数，要求从左上角走到右下角，

每一步只能向右或者向下，沿途经过的数字要累加起来，

返回最小的路径和，

<br/>

暴力递归：

```java
public static int walk(int[][] matrix, int i, int j) {
    if(i == matrix.length && j == matrix[0].length){
        return matrix[i][j];
    }

    if(i == matrix.length - 1){ //如果到达最后一行，那么只能向右走。
        return matrix[i][j] + walk(matrix,i,j+1);
    }
    if(j == matrix[0].length){//如果到达最后一列了，那么只能向下走。
        return matrix[i][j] + walk(matrix,i+1,j);
    }

    int right = walk(matrix,i,j+1);//right-> 右边位置到右下角的最短路径和。
    int down = walk(matrix,i+1,j); //left-> 下边位置到右下角的最短路径和。

    return matrix[i][j] + Math.min(right,down);
}
```

<br/>

复杂度高的原因：

产生了很多重复计算

{% asset_img picture4.jpg %}

<br/>

无后效性问题：

与到达这个状态的路径没有关系，只要这个状态的参数定了，返回值一定固定，例如：从(0,0) 到 (1,1)，不管是先往左再往下，还是先往下再往右， (1,1) 到右下角的点的最短路劲和，是完全固定的；

例如 汉诺塔问题，就是有后效性问题，因为问题本身就是要打印所有的步骤，所以每次做的选择都会影响最后的结果

<br/>

如果做出来的尝试函数，可变参数固定了，返回值一定是确定的，就是无后效性问题，这种问题一定可以改为动态规划；

<br/>

对于这道题来说，参数固定，返回值就固定，i，j的变化范围就是这张二维表行和列的变化范围，那么我们函数的所有返回值一定可以装在这张二维表里（因为i，j固定了，函数最终的结果就固定了，所以我们把i，j的所有可能性列出来，那么最终的结果一定属于所有的可能性）。

<br/>

先标出我们想要的状态 (0,0)，然后看哪些状态的值是不需要依赖其他状态的，也就是看basecase ( 也就是右下角 )，那么最右下角的状态就确定了，就是matrix 二维表 右下角的值，还有，最下一行的值也可以全部填上，最右一列的值也可以全部填上，最下一行的每个值等于 右边的值加上当前值，所以可以从右往左填上，最右一列同理

{% asset_img picture5.jpg %}

<br/>

所有这样类型的题都是这样的套路：

1. 把需要的位置点出来
2.  回到basecase ，把不被依赖的位置设置好；对于这道题，就是把最下一行和最右一列设置好
3. 然后分析一个普遍位置是怎么依赖的；根据函数可知，一个位置的状态需要右边的状态和下边的状态；
4. 最后根据basecase ( 最右下角的点 )  往上一直递推到我们想要的状态即可；

<br/>

**最重要的：写出尝试版本**

然后看参数固定，结果是否固定，如果是：那么一定可以改成动态规划，再按照上面的套路去做；

<br/>

不要背什么转移方程，转移方程就是递归来的，其实动态规划本质就是一个空间换时间的概念；所以学会怎么去尝试是最重要的；

也可以理解为搭积木的过程，找到我们最终想要的积木，找到一开始的地基，中间一块积木依赖哪些位置的积木，依次搭过去，搭到终止位置，就找到了我们想要的积木；

<br/>

dp代码

```java
public class Code_07_MinPath {

    public static int minPath1(int[][] matrix) {
        return process1(matrix, matrix.length - 1, matrix[0].length - 1);
    }

    /**
     * 从(i,j) 出发，到达最右下角位置，最短路径和是多少？
     * @param matrix：
     * @param i：行
     * @param j：列
     * @return
     */
    public static int process1(int[][] matrix, int i, int j) {
        int res = matrix[i][j];
        if (i == 0 && j == 0) {
            return res;
        }
        if (i == 0 && j != 0) {
            return res + process1(matrix, i, j - 1);
        }
        if (i != 0 && j == 0) {
            return res + process1(matrix, i - 1, j);
        }
        return res + Math.min(process1(matrix, i, j - 1), process1(matrix, i - 1, j));
    }

    public static int minPath2(int[][] m) {
        if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) {
            return 0;
        }
        int row = m.length;
        int col = m[0].length;
        int[][] dp = new int[row][col];
        dp[0][0] = m[0][0];
        for (int i = 1; i < row; i++) {
            dp[i][0] = dp[i - 1][0] + m[i][0];
        }
        for (int j = 1; j < col; j++) {
            dp[0][j] = dp[0][j - 1] + m[0][j];
        }
        for (int i = 1; i < row; i++) {
            for (int j = 1; j < col; j++) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + m[i][j];
            }
        }
        return dp[row - 1][col - 1];
    }

    // for test
    public static int[][] generateRandomMatrix(int rowSize, int colSize) {
        if (rowSize < 0 || colSize < 0) {
            return null;
        }
        int[][] result = new int[rowSize][colSize];
        for (int i = 0; i != result.length; i++) {
            for (int j = 0; j != result[0].length; j++) {
                result[i][j] = (int) (Math.random() * 10);
            }
        }
        return result;
    }


    /**
     * 从(i,j)出发，到达最右下角位置，最短路径和是多少？
     * 暴力递归的方式
     * 缺点：会有很多的重复计算。
     * @param matrix：
     * @param i：行
     * @param j：列
     * @return
     *
     * 无后效性问题：
     * 只要状态的参数定了，返回值一定确定。
     * 有后效性问题：
     * 汉诺塔问题：要求就是打印所有的步骤，之前做出的选择，必然会影响着解，所以是有后效性的。
     *
     * 这里(i,j)确定了，那么解就确定了。
     * 那么所有的 (i,j) 的返回结果就会出现在一张二维表里。
     *
     * 高度套路：
     * 最重要的：写出尝试版本
     * 然后分析可变参数，哪几个可变参数可以代表返回值的状态，可变参数是几维的，就是一张几维表，
     * 然后看看终止状态是哪一个，在表中点出来，然后回到base case中，把完全不依赖的位置的值，设置好，
     * 然后一个普遍位置，看看它需要哪些位置，逆着回去，就是填表的顺序。
     */
    public static int walk(int[][] matrix, int i, int j) {
        if(i == matrix.length && j == matrix[0].length){
            return matrix[i][j];
        }

        if(i == matrix.length - 1){ //如果到达最后一行，那么只能向右走。
            return matrix[i][j] + walk(matrix,i,j+1);
        }
        if(j == matrix[0].length){//如果到达最后一列了，那么只能向下走。
            return matrix[i][j] + walk(matrix,i+1,j);
        }

        int right = walk(matrix,i,j+1);//right-> 右边位置到右下角的最短路径和。
        int down = walk(matrix,i+1,j); //left-> 下边位置到右下角的最短路径和。

        return matrix[i][j] + Math.min(right,down);
    }


    public static void main(String[] args) {
        int[][] m = {{1, 3, 5, 9}, {8, 1, 3, 4}, {5, 0, 6, 1}, {8, 8, 4, 0}};
        System.out.println(minPath1(m));
        System.out.println(minPath2(m));

        m = generateRandomMatrix(6, 7);
        System.out.println(minPath1(m));
        System.out.println(minPath2(m));
    }
}
```

<br/>

<br/>

### 数组arr，整数aim，任意选择arr中的数字，能不能累加得到aim，返回true或者false；

<br/>

假设都是正数

f(x,y) ：x代表位置，y代表累加和，那么开始的状态就是 f(0,0)。每个位置有两个选择，要对应这个位置的数组中的数，还是不要这个位置数组中的数字，和求子序列一样；最终的状态图如下：

叶节点是我们要的所有的最终决定；

{% asset_img picture6.jpg %}

<br/>

暴力递归

```java
/**
     * 和子序列的树形图一致，
     * 图示：数组中的元素相加能不能得到aim
     * @param arr
     * @param index   第几层
     * @param sum     当前形成的和
     * @param aim
     * @return
     */
public static boolean isSum(int[] arr,int index,int sum, int aim){

    if(index == arr.length){
        return sum == aim;
    }

    return isSum(arr,index+1,sum,aim) || isSum(arr,index+1,sum+arr[index],aim);
}
```

<br/>

后效性分析：

看函数，arr，aim 固定不变，index和sum变化，但是index和sum 的结果来源于后续的计算结果，和之前的计算过程无关，比如数组为：3,2,5,……，第一种情况，要3，2，不要5，那么产生的状态为f(3,5)，第二种情况，只要5，不要3，2，产生的状态仍然是 f(3,5)，虽然到达的路径不同，但是 f(3,5) 返回的值肯定是不变的，因为这个值只和它之后的计算结果有关系；递归是往下走的，肯定是无后效性问题的；

<br/>

**dp思路**：

函数只有 index和sum变化 ，也就是说只有index和sum变化的时候会影响最终值，那么最终值得变化范围肯定能用 index和sum形成的二维表装下。可以把index和sum想象成自变量，最终值想象成因变量；

<br/>

i的变化范围是0到arr的长度，sum的变化范围是0到数组所有数的和；

<br/>

要的是(0,0) 状态的值，根据basecase，哪些位置的值可以确定？：最后一行 (N,aim) 的值可以确定是true，最后一行其他值都是false（aim一定小于sum，否则函数直接返回false）

{% asset_img picture7.jpg %}

<br/>

剩下的就是分析普通位置的值的变化，然后递推 的推出(0,0) 位置的值

分析函数可知：(i,sum) 的值只和 它下一行的两个位置的值有关系：(i+1,sum) 和 ( i+1,sum+a ): a是arr[i] 的值；

所以基本的套路就是，倒数第一行推出倒数第二行，倒数第二行推出倒数第三行。。。。 最后推出第一行；

{% asset_img picture8.jpg %}

<br/>

案例：

{% asset_img picture9.jpg %}

<br/>

**所有无后效性问题的递归都可以用这种套路解决，谨记！！！！！！！！**

**尝试是很重要的！！！ 尝试方法写出来，优化的套路完全一致！！！**

<br/>

代码：

~~~~java
/**
 * 数组中的元素几个数字相加能不能得到aim
 */
public class Code_08_Money_Problem {
	public static boolean money1(int[] arr, int aim) {
		return process1(arr, 0, 0, aim);
	}

	public static boolean process1(int[] arr, int i, int sum, int aim) {
		if (sum == aim) {
			return true;
		}
		// sum != aim
		if (i == arr.length) {
			return false;
		}
		return process1(arr, i + 1, sum, aim) || process1(arr, i + 1, sum + arr[i], aim);
	}

	public static boolean money2(int[] arr, int aim) {
		boolean[][] dp = new boolean[arr.length + 1][aim + 1];
		for (int i = 0; i < dp.length; i++) {
			dp[i][aim] = true;
		}
		for (int i = arr.length - 1; i >= 0; i--) {
			for (int j = aim - 1; j >= 0; j--) {
				dp[i][j] = dp[i + 1][j];
				if (j + arr[i] <= aim) {
					dp[i][j] = dp[i][j] || dp[i + 1][j + arr[i]];
				}
			}
		}
		return dp[0][0];
	}

    /**
     * 和子序列的树形图一致，
     * 图示：数组中的元素相加能不能得到aim
     * @param arr
     * @param index   第几层
     * @param sum     当前形成的和
     * @param aim
     * @return
     */
	public static boolean isSum(int[] arr,int index,int sum, int aim){
	    if(index == arr.length){
	        return sum == aim;
        }

	    return isSum(arr,index+1,sum,aim) || isSum(arr,index+1,sum+arr[index],aim);
    }

	public static void main(String[] args) {
		int[] arr = { 1, 4, 8 };
        int aim = 12;
//		System.out.println(money1(arr, aim));
//		System.out.println(money2(arr, aim));
        isSum(arr,0,0,aim);
	}
}
~~~~

<br/>

<br/>

###   问题：01背包 

给定两个数组w和v，两个数组长度相等，w[i]表示第i件商品的 重量，v[i]表示第i件商品的价值。 

再给定一个整数bag，要求你挑选商品的重量加起来一定不能超 过bag，返回满足这个条件下，你能获得的最大价值。 

<br/>

递归思路：

{% asset_img picture10.jpg %}

<br/>

dp思路

{% asset_img picture11.jpg %}

<br/>

代码：

~~~~java
public class Code_09_Knapsack {

	public static int maxValue1(int[] c, int[] p, int bag) {
		return process1(c, p, 0, 0, bag);
	}

	/**
	 * 从两个数组的i位置开始，一直选到最后，能够获得的最大收益
	 * @return
	 */
	public static int process1(int[] c, int[] p, int i, int cost, int bag) {
		if (cost > bag) {  //减枝的策略，递归的过程中，如果之前的选择已经大于了bag，就不用继续往下选了；
			return Integer.MIN_VALUE;
		}
		if (i == c.length) {
			return 0; //返回0是因为到最后了，之前的选择不会影响后面的结果，最后没的可选了，返回的收益肯定是0；
		}
		return Math.max(process1(c, p, i + 1, cost, bag), p[i] + process1(c, p, i + 1, cost + c[i], bag));
	}

	public static int maxValue2(int[] c, int[] p, int bag) {
		int[][] dp = new int[c.length + 1][bag + 1];
		for (int i = c.length - 1; i >= 0; i--) {
			for (int j = bag; j >= 0; j--) {
				dp[i][j] = dp[i + 1][j];
				if (j + c[i] <= bag) {
					dp[i][j] = Math.max(dp[i][j], p[i] + dp[i + 1][j + c[i]]);
				}
			}
		}
		return dp[0][0];
	}

	public static void main(String[] args) {
		int[] c = { 3, 2, 4, 7 };
		int[] p = { 5, 6, 3, 19 };
		int bag = 11;
		System.out.println(maxValue1(c, p, bag));
		System.out.println(maxValue2(c, p, bag));
	}
}
~~~~

<br/>

### 题目：逆序一个栈

给你一个栈，请你逆序这个栈，不能申请额外的数据结构，只能 使用递归函数。如何实现？

<br/>

思路：

首先实现一个g函数：功能是实现移除并返回栈底元素，其余元素的位置不变；此函数的过程如下，其实就是每次弹出栈顶元素，然后再判断栈此时是否空了，如果空了，说明弹出的元素就是栈底元素，直接返回，如果此时栈不为空，就用一个变量记住弹出的元素，然后继续调用这个函数，去获取last元素，然后再把弹出的元素重新放回栈中，这样一来，函数返回的时候是从底部往上返回的，也就是之前先弹出的元素，放回的时候，最后才放回去，所以这样并没有改变栈中其他元素的顺序，而且也返回了栈底的元素；

{% asset_img picture13.jpg %}

<br/>

主函数实现的功能如下：

每次调用上面提到的g函数，每次取出栈最底部的元素，但是函数此时不直接结束，而是保存这个栈底元素，然后继续调用这个函数，去获取此时栈底元素，直到栈为空了，返回，也就是：把栈中的元素按照从栈底往栈顶的顺序取出来，然后递归子过程往上返回的时候，把之前取出来的栈底元素重新放进栈中；

也就是按照从栈顶到栈底的顺序重新压入栈；

{% asset_img picture14.jpg %}

<br/>

代码

~~~~java
public class Code_06_ReverseStackUsingRecursive {

	public static void reverse(Stack<Integer> stack) {
		if (stack.isEmpty()) {
			return;
		}
		int i = getAndRemoveLastElement(stack);
		reverse(stack);
		stack.push(i);
	}

	public static int getAndRemoveLastElement(Stack<Integer> stack) {
		int result = stack.pop();
		if (stack.isEmpty()) {
			return result;
		} else {
			int last = getAndRemoveLastElement(stack);
			stack.push(result);
			return last;
		}
	}

	public static void main(String[] args) {
		Stack<Integer> test = new Stack<Integer>();
		test.push(1);
		test.push(2);
		test.push(3);
		test.push(4);
		test.push(5);
		reverse(test);
		while (!test.isEmpty()) {
			System.out.println(test.pop());
		}
	}
}
~~~~

<br/>

<br/>

### 问题：直方图容器装水

给定一个数组代表一个容器， 比如[3,1,2,4]， 

代表0位置是一个宽度为1，高度为3的直方图。 

代表1位置是一个宽度为1，高度为1的直方图。 

代表2位置是一个宽度为1，高度为2的直方图。

代表3位置是一个宽度为1，高度为4的直方图。 

所有直方图的底部都在一条水平线上，且紧靠着。 把这个图想象成一个容器，这个容器可以装3格的水。 

给定一个没有负数的数组arr，返回能装几格水？

<br/>

要求

时间复杂度 O(N)，空间复杂度O(1)

<br/>

思路：

跳出一直找波谷，然后相加，求得结果的思路，这种思路有局限性，即：两边有两个非常大的波峰；

{% asset_img picture15.jpg %}

<br/>

思路是求每个位置可以容纳多少格水，假设当前位置是5，左边最大值是10，右边最大值是20，那么这个位置一定可以容纳5格水；所以标准简化为：每个位置取左边最大值和右边最大值，两个中的较小的值，减去当前位置的数，是正数，当前位置就能容纳这么多水，负数，说明这个位置不能容纳水；

<br/>

解法一：

求每个位置能够容纳多少格水，然后相加，求的过程中，每个位置需要遍历一遍，求max左和max右，所以时间复杂度O(N^2)，

<br/>

优化：**预处理数组**，**很重要的技巧**，

生成一个和原数组一样长的数组，每个位置的值代表从0开始到这个位置的最大值，生成的逻辑也很简单，之前的数大，拷贝之前的，否则，拷贝原数组当前位置的；

再生成一个同样长度的数组，每个位置的值代表从i位置到N-1位置的最大值，生成的逻辑变成从后往前生成即可；

{% asset_img picture16.jpg %}

<br/>

此时再求每个位置可以容纳多少格水的时候，直接查询左边最大值和右边最大值即可；时间复杂度O(N)，空间复杂度O(N)；

<br/>

解法二：双指针

L位置从1开始，R位置从N-2位置开始，max左是0位置的值，max右是N-1位置的值， 然后L和R从左右两边同时往中间缩，缩的过程中，比较max左和max右的值，如果max右的值更大，说明对于L位置来说，瓶颈肯定是max左的值，用max左减去L位置的值，就是L位置可以装的水量，然后L往右移动。如果max左边的值更大，同理可以求出R位置的值，然后R往左移动。当L和R撞上的时候，就得出所有结果；

相等的时候，先结算L和先结算R都是一样的，甚至可以同时结算L和R；

<br/>

代码

~~~~java
public class Code_01_WaterProblem {

	public static int getWater1(int[] arr) {
		if (arr == null || arr.length < 3) {
			return 0;
		}
		int value = 0;
		for (int i = 1; i < arr.length - 1; i++) {
			int leftMax = 0;
			int rightMax = 0;
			for (int l = 0; l < i; l++) {
				leftMax = Math.max(arr[l], leftMax);
			}
			for (int r = i + 1; r < arr.length; r++) {
				rightMax = Math.max(arr[r], rightMax);
			}
			value += Math.max(0, Math.min(leftMax, rightMax) - arr[i]);
		}
		return value;
	}

	public static int getWater2(int[] arr) {
		if (arr == null || arr.length < 3) {
			return 0;
		}
		int n = arr.length - 2;
		int[] leftMaxs = new int[n];
		leftMaxs[0] = arr[0];
		for (int i = 1; i < n; i++) {
			leftMaxs[i] = Math.max(leftMaxs[i - 1], arr[i]);
		}
		int[] rightMaxs = new int[n];
		rightMaxs[n - 1] = arr[n + 1];
		for (int i = n - 2; i >= 0; i--) {
			rightMaxs[i] = Math.max(rightMaxs[i + 1], arr[i + 2]);
		}
		int value = 0;
		for (int i = 1; i <= n; i++) {
			value += Math.max(0, Math.min(leftMaxs[i - 1], rightMaxs[i - 1]) - arr[i]);
		}
		return value;
	}

	public static int getWater3(int[] arr) {
		if (arr == null || arr.length < 3) {
			return 0;
		}
		int n = arr.length - 2;
		int[] rightMaxs = new int[n];
		rightMaxs[n - 1] = arr[n + 1];
		for (int i = n - 2; i >= 0; i--) {
			rightMaxs[i] = Math.max(rightMaxs[i + 1], arr[i + 2]);
		}
		int leftMax = arr[0];
		int value = 0;
		for (int i = 1; i <= n; i++) {
			value += Math.max(0, Math.min(leftMax, rightMaxs[i - 1]) - arr[i]);
			leftMax = Math.max(leftMax, arr[i]);
		}
		return value;
	}

	public static int getWater4(int[] arr) {
		if (arr == null || arr.length < 3) {
			return 0;
		}
		int value = 0;
		int leftMax = arr[0];
		int rightMax = arr[arr.length - 1];
		int l = 1;
		int r = arr.length - 2;
		while (l <= r) {
			if (leftMax <= rightMax) {
				value += Math.max(0, leftMax - arr[l]);
				leftMax = Math.max(leftMax, arr[l++]);
			} else {
				value += Math.max(0, rightMax - arr[r]);
				rightMax = Math.max(rightMax, arr[r--]);
			}
		}
		return value;
	}

	public static int[] generateRandomArray() {
		int[] arr = new int[(int) (Math.random() * 98) + 2];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = (int) (Math.random() * 200) + 2;
		}
		return arr;
	}

	public static void main(String[] args) {
		for (int i = 0; i < 1000000; i++) {
			int[] arr = generateRandomArray();
			int r1 = getWater1(arr);
			int r2 = getWater2(arr);
			int r3 = getWater3(arr);
			int r4 = getWater4(arr);
			if (r1 != r2 || r3 != r4 || r1 != r3) {
				System.out.println("What a fucking day! fuck that! man!");
			}
		}

		HashMap<String, String> map = new HashMap<String, String>();

		for (Entry<String, String> entry : map.entrySet()) {
			System.out.println(entry.getKey() + " , " + entry.getValue());
		}
	}
}
~~~~

<br/>

<br/>

### 子数组的最大累加和

给定一个数组arr，返回所有子数组的累加和中，最大的累加和

子数组的级别：O(N^2)

<br/>

思路：

准备两个变量，一个cur：记录累加一个数之后的结果，如果累加完变为负数，cur直接变为0。另外一个变量max：记录cur变化中的最大值，每次变化的时候，如果变大了，就记录，但是从负数变为0的时候不记录；最终返回max，就是子数组的最大累加和

<br/>

原理：

假设都是负数，那么cur每次加上一个数，都会回滚成0，但是也会记录max，所以此时结果是正确的；

假设有正数，假设长方形是整体数组，椭圆形是累加和为最大值的最长子数组，也就是L到R中间的位置，此时会有以下两个结论：

1. 0到L位置中间的任意位置k，从k到L-1位置的累加和肯定是负数，因为它如果是正数或者是0，那么L到R就不是累加和为最大值的最长子数组了，而应该是k到R位置；
2. L和R中间的一个位置z，L到z位置的累加和一定不是负数，因为如果是负，L到R的子数组就不是最大累加和了，z到R一定更大；

{% asset_img picture17.jpg %}

<br/>

cur在从左往右加的时候，在加L位置的时候，肯定是先回滚到0，然后再加L的，因为从k到L-1位置的累加和肯定是负数。在cur加上L位置上数之后，从L位置一直加到R位置，肯定是不会回滚到0的，因为L到z位置的累加和一定不是负数，所以max一定不会错过答案； 

<br/>

代码

~~~~java
public class Code_02_SubArrayMaxSum {

	public static int maxSum(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		int max = Integer.MIN_VALUE;
		int cur = 0;
		for (int i = 0; i != arr.length; i++) {
			cur += arr[i];
			max = Math.max(max, cur);
			cur = cur < 0 ? 0 : cur;
		}
		return max;
	}

	public static void printArray(int[] arr) {
		for (int i = 0; i != arr.length; i++) {
			System.out.print(arr[i] + " ");
		}
		System.out.println();
	}

	public static void main(String[] args) {
		int[] arr1 = { -2, -3, -5, 40, -10, -10, 100, 1 };
		System.out.println(maxSum(arr1));

		int[] arr2 = { -2, -3, -5, 0, 1, 2, -1 };
		System.out.println(maxSum(arr2));

		int[] arr3 = { -2, -3, -5, -1 };
		System.out.println(maxSum(arr3));
	}
}
~~~~

<br/>

<br/>

### 问题：字符串循环右移问题

想想一个字符串其实是个循环数组，可以循环右移。

比如”abc”， 向右循环右移一位，得到”cab”， 

向右循环右移两位，得到“bca”， 

向右循环右移三位，得到“abc”，

给定两个字符串str1和str2，判断str2是不是由str1循环右移得到的。

<br/>

过程：

先判断长度是否相等，不相等，直接返回false，相等，把两个str1拼接在一起，然后查看形成的新字符串是否包含str2，如果包含，返回true，不包含，返回false；

<br/>

原理：

新字符串中任何一个长度为k的字符串都是str1的循环子串，也就是说这个新字符串包含了所有的循环子串；

<br/>

代码

~~~~java
public class Code_04_IsRotation {

	public static boolean isRotation(String a, String b) {
		if (a == null || b == null || a.length() != b.length()) {
			return false;
		}
		String b2 = b + b;
		return getIndexOf(b2, a) != -1;
	}

	// KMP Algorithm
	public static int getIndexOf(String s, String m) {
		if (s.length() < m.length()) {
			return -1;
		}
		char[] ss = s.toCharArray();
		char[] ms = m.toCharArray();
		int si = 0;
		int mi = 0;
		int[] next = getNextArray(ms);
		while (si < ss.length && mi < ms.length) {
			if (ss[si] == ms[mi]) {
				si++;
				mi++;
			} else if (next[mi] == -1) {
				si++;
			} else {
				mi = next[mi];
			}
		}
		return mi == ms.length ? si - mi : -1;
	}

	public static int[] getNextArray(char[] ms) {
		if (ms.length == 1) {
			return new int[] { -1 };
		}
		int[] next = new int[ms.length];
		next[0] = -1;
		next[1] = 0;
		int pos = 2;
		int cn = 0;
		while (pos < next.length) {
			if (ms[pos - 1] == ms[cn]) {
				next[pos++] = ++cn;
			} else if (cn > 0) {
				cn = next[cn];
			} else {
				next[pos++] = 0;
			}
		}
		return next;
	}

	public static void main(String[] args) {
		String str1 = "yunzuocheng";
		String str2 = "zuochengyun";
		System.out.println(isRotation(str1, str2));
	}
}
~~~~

<br/>

<br/>

### 求一个字符串向右循环右移k位后的结果

给定一个字符串str，和一个整数k，返回str向右循环右移k位后的结果

<br/>

过程：

假设一个数组长度为5，

向右循环右移3位：就是把前两个字符和后三个字符串互换位置；

<br/>

如何前后两个子串互换位置？

前字符串逆序，后字符串逆序，然后整体逆序；

<br/>

代码

~~~~java
public class Code_05_RotateString {

	public static void rotateWord(char[] chas) {
		if (chas == null || chas.length == 0) {
			return;
		}
		reverse(chas, 0, chas.length - 1);
		int l = -1;
		int r = -1;
		for (int i = 0; i < chas.length; i++) {
			if (chas[i] != ' ') {
				l = i == 0 || chas[i - 1] == ' ' ? i : l;
				r = i == chas.length - 1 || chas[i + 1] == ' ' ? i : r;
			}
			if (l != -1 && r != -1) {
				reverse(chas, l, r);
				l = -1;
				r = -1;
			}
		}
	}

	public static void reverse(char[] chas, int start, int end) {
		char tmp = 0;
		while (start < end) {
			tmp = chas[start];
			chas[start] = chas[end];
			chas[end] = tmp;
			start++;
			end--;
		}
	}

	public static void rotate1(char[] chas, int size) {
		if (chas == null || size <= 0 || size >= chas.length) {
			return;
		}
		reverse(chas, 0, size - 1);
		reverse(chas, size, chas.length - 1);
		reverse(chas, 0, chas.length - 1);
	}

	public static void rotate2(char[] chas, int size) {
		if (chas == null || size <= 0 || size >= chas.length) {
			return;
		}
		int start = 0;
		int end = chas.length - 1;
		int lpart = size;
		int rpart = chas.length - size;
		int s = Math.min(lpart, rpart);
		int d = lpart - rpart;
		while (true) {
			exchange(chas, start, end, s);
			if (d == 0) {
				break;
			} else if (d > 0) {
				start += s;
				lpart = d;
			} else {
				end -= s;
				rpart = -d;
			}
			s = Math.min(lpart, rpart);
			d = lpart - rpart;
		}
	}

	public static void exchange(char[] chas, int start, int end, int size) {
		int i = end - size + 1;
		char tmp = 0;
		while (size-- != 0) {
			tmp = chas[start];
			chas[start] = chas[i];
			chas[i] = tmp;
			start++;
			i++;
		}
	}

	public static void main(String[] args) {
		char[] chas1 = { 'd', 'o', 'g', ' ', 'l', 'o', 'v', 'e', 's', ' ', 'p',
				'i', 'g' };
		System.out.println(String.valueOf(chas1));
		rotateWord(chas1);
		System.out.println(String.valueOf(chas1));

		char[] chas2 = { '1', '2', '3', '4', '5', 'A', 'B', 'C' };
		System.out.println(String.valueOf(chas2));
		rotate1(chas2, 5);
		System.out.println(String.valueOf(chas2));
		rotate2(chas2, 3);
		System.out.println(String.valueOf(chas2));
	}
}
~~~~

