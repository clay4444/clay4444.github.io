---
title: 算法基础第八课
date: 2019-02-26 10:07:11
categories:
  - leetcode
---

### n 的阶乘

<br/>

代码：

```java
public class Code_01_Factorial {

    /**
     * 递归
     */
	public static long getFactorial1(int n) {
		if (n == 1) {
			return 1L;
		}
		return (long) n * getFactorial1(n - 1);
	}

    /**
     * 第一种方法：我知道怎么试。
     */
	public static long getFactorial2(int n) {
		long result = 1L;
		for (int i = 1; i <= n; i++) {
			result *= i;
		}
		return result;
	}

	public static void main(String[] args) {
		int n = 5;
		System.out.println(getFactorial1(n));
		System.out.println(getFactorial2(n));
	}
}
```

<br/>

### 汉诺塔

 <br/>

代码：

```java
/**
 * 汉诺塔问题
 *
 * 第一步：把1~（n-1）从from移动到help上去。
 * 第二步：把单独的n移动到to上去。
 * 第三步：把1~（n-1）从help移动到to上去。
 */
public class Code_02_Hanoi {

	public static void hanoi(int n) {
		if (n > 0) {
			func(n, n, "left", "mid", "right");
		}
	}

	public static void func(int rest, int down, String from, String help, String to) {
		if (rest == 1) {
			System.out.println("move " + down + " from " + from + " to " + to);
		} else {
			func(rest - 1, down - 1, from, to, help);
			func(1, down, from, help, to);
			func(rest - 1, down - 1, help, from, to);
		}
	}

    /**
     * @param N：N层
     * @param from
     * @param to
     * @param help
     */
	public static void process(int N,String from, String to,String help){
        if(N == 1){
            System.out.println("Move 1 from " + from + "to" + to);
        }else{
            process(N-1,from,help,to);
            System.out.println("Move " + N + " form " + from + "to" + to);
            process(N-1,help,to,from);
        }
    }


	public static void moveLeftToRight(int N) {
		if (N == 1) {
			System.out.println("move 1 from left to right");
		}
		moveLeftToMid(N - 1);
		System.out.println("move " + N + "from left to right");
		moveMidToRight(N - 1);
	}

	public static void moveRightToLeft(int N) {

	}

	public static void moveLeftToMid(int N) {
		if (N == 1) {
			System.out.println("move 1 from left to mid");
		}
		moveLeftToRight(N - 1);
		System.out.println("move " + N + "from left to mid");
		moveRightToMid(N - 1);
	}

	public static void moveMidToLeft(int N) {

	}

	public static void moveRightToMid(int N) {

	}

	public static void moveMidToRight(int N) {
		if (N == 1) {
			System.out.println("move 1 from mid to right");
		}
		moveMidToLeft(N - 1);
		System.out.println("move " + N + "from mid to right");
		moveLeftToRight(N - 1);
	}

	public static void main(String[] args) {
		int n = 3;
		hanoi(n);
	}
}
```

<br/>

###  打印一个字符串的全部子序列，包括空

{% asset_img picture1.jpg %}

每一个位置都有两个选择，要不要a，要不要b，。。。。

<br/>

代码

```java
/**
 * 打印一个字符串的所有子序列
 * 打算怎么尝试
 * 图片：穷尽所有的子序列
 * 树形图：每个字符串的位置都会有两个决策：1.要当前的字符，2.不要当前的字符
 * 这样就可以穷尽所有的子序列情况。
 */
public class Code_03_Print_All_Subsquences {

	public static void printAllSubsquence(String str) {
		char[] chs = str.toCharArray();
		process(chs, 0);
	}

	public static void process(char[] chs, int i) {
		if (i == chs.length) {
			System.out.println(String.valueOf(chs));
			return;
		}
		process(chs, i + 1);
		char tmp = chs[i];
		chs[i] = 0;
		process(chs, i + 1);
		chs[i] = tmp;
	}
	
	public static void function(String str) {
		char[] chs = str.toCharArray();
		process(chs, 0, new ArrayList<Character>());
	}
	
	public static void process(char[] chs, int i, List<Character> res) {
		if(i == chs.length) {
			printList(res);
		}
		List<Character> resKeep = copyList(res);
		resKeep.add(chs[i]);
		process(chs, i+1, resKeep);
		List<Character> resNoInclude = copyList(res);
		process(chs, i+1, resNoInclude);
	}
	
	public static void printList(List<Character> res) {
		// ...;
	}
	
	public static List<Character> copyList(List<Character> list){
		return null;
	}

    /**
     * 打印所有的子序列
     * res: 就是上级扔给我的字符串
     */
	public static void printAllSub(char[] str, int i,String res){

	    if(i == str.length){
            System.out.println(res);
            return;
        }

        /**
         * 每一步两条路都要走。要么不要当前的字符，要么要当前的字符。
         */
        printAllSub(str,i+1,res);//不要当前字符
        printAllSub(str,i+1,res+str[i]);//要当前字符
    }

	public static void main(String[] args) {
		String test = "abc";
		//printAllSubsquence(test);
        printAllSub(test.toCharArray(),0,"");
	}
}
```

<br/><br/>

### 打印全排列

<br/>

{% asset_img picture2.jpg %}

<br/>

```java
public class Code_04_Print_All_Permutations {

	public static void printAllPermutations1(String str) {
		char[] chs = str.toCharArray();
		process1(chs, 0);
	}

    /**
     * 等于0的时候：把0位置处的字符换位置
     * 等于1的时候：把1位置处的字符和后续换位置
     * 等于2的时候：其实就可以返回了，但是也可以想象成把3位置处的字符和后续换位置
     * 图示：字符串的全排列问题。
     * @param chs
     * @param i
     */
	public static void process1(char[] chs, int i) {
		if (i == chs.length-1) {
			System.out.println(String.valueOf(chs));
		}
		for (int j = i; j < chs.length; j++) {
			swap(chs, i, j);
			process1(chs, i + 1);
			swap(chs, i, j);//换位置之后，最后记得换回来，供下一次的循环使用。
		}
	}

	public static void printAllPermutations2(String str) {
		char[] chs = str.toCharArray();
		process2(chs, 0);
	}

	public static void process2(char[] chs, int i) {
		if (i == chs.length) {
			System.out.println(String.valueOf(chs));
		}
		HashSet<Character> set = new HashSet<>();
		for (int j = i; j < chs.length; j++) {
			if (!set.contains(chs[j])) {
				set.add(chs[j]);
				swap(chs, i, j);
				process2(chs, i + 1);
				swap(chs, i, j);
			}
		}
	}

	public static void swap(char[] chs, int i, int j) {
		char tmp = chs[i];
		chs[i] = chs[j];
		chs[j] = tmp;
	}

	public static void main(String[] args) {
		String test1 = "abc";
		printAllPermutations1(test1);
		System.out.println("======");
		printAllPermutations2(test1);
		System.out.println("======");

		String test2 = "acc";
		printAllPermutations1(test2);
		System.out.println("======");
		printAllPermutations2(test2);
		System.out.println("======");
	}
}
```

<br/>

### 母牛的数量

母牛每年生一只母牛，新出生的母牛三年后也能每年生一只母牛，假设不会死，求N年后，母牛的数量

{% asset_img picture3.jpg %}

今年的牛=去年的牛+3年前的牛的数目(只有三年前的牛成熟了可以新生牛)

<br/>

代码：

```java
/**
 * 母牛生牛问题
 * F(n) = F(n-1) + F(n-3)
 * 今年的牛数量 = 去年的牛数量 + 三年前牛的数量(因为三年前的牛已经可以生牛了)
 * 假设所有的牛都不会死。
 */
public class Code_05_Cow {

	public static int cowNumber1(int n) {
		if (n < 1) {
			return 0;
		}
		if (n == 1 || n == 2 || n == 3) {
			return n;
		}
		return cowNumber1(n - 1) + cowNumber1(n - 3);
	}

	public static int cowNumber2(int n) {
		if (n < 1) {
			return 0;
		}
		if (n == 1 || n == 2 || n == 3) {
			return n;
		}
		int res = 3;
		int pre = 2;
		int prepre = 1;
		int tmp1 = 0;
		int tmp2 = 0;
		for (int i = 4; i <= n; i++) {
			tmp1 = res;
			tmp2 = pre;
			res = res + prepre;
			pre = tmp1;
			prepre = tmp2;
		}
		return res;
	}

	public static void main(String[] args) {
		int n = 20;
		System.out.println(cowNumber1(n));
		System.out.println(cowNumber2(n));
	}
}
```

<br/>

### 最小路径和

二维数组，数组中的每个数都是正数，要求从左上角走到右下角，

每一步只能向右或者向下，沿途经过的数字要累加起来，

返回最小的路径和，

<br/>

暴力递归：

```java
public static int walk(int[][] matrix, int i, int j) {
    if(i == matrix.length && j == matrix[0].length){
        return matrix[i][j];
    }

    if(i == matrix.length - 1){ //如果到达最后一行，那么只能向右走。
        return matrix[i][j] + walk(matrix,i,j+1);
    }
    if(j == matrix[0].length){//如果到达最后一列了，那么只能向下走。
        return matrix[i][j] + walk(matrix,i+1,j);
    }

    int right = walk(matrix,i,j+1);//right-> 右边位置到右下角的最短路径和。
    int down = walk(matrix,i+1,j); //left-> 下边位置到右下角的最短路径和。

    return matrix[i][j] + Math.min(right,down);
}
```

<br/>

复杂度高的原因：

产生了很多重复计算

{% asset_img picture4.jpg %}

<br/>

无后效性问题：

与到达这个状态的路径没有关系，只要这个状态的参数定了，返回值一定固定，例如：从(0,0) 到 (1,1)，不管是先往左再往下，还是先往下再往右， (1,1) 到右下角的点的最短路劲和，是完全固定的；

例如 汉诺塔问题，就是有后效性问题，因为问题本身就是要打印所有的步骤，所以每次做的选择都会影响最后的结果

<br/>

如果做出来的尝试函数，可变参数固定了，返回值一定是确定的，就是无后效性问题，这种问题一定可以改为动态规划；

<br/>

对于这道题来说，参数固定，返回值就固定，i，j的变化范围就是这张二维表行和列的变化范围，那么我们函数的所有返回值一定可以装在这张二维表里（因为i，j固定了，函数最终的结果就固定了，所以我们把i，j的所有可能性列出来，那么最终的结果一定属于所有的可能性）。

<br/>

先标出我们想要的状态 (0,0)，然后看哪些状态的值是不需要依赖其他状态的，也就是看basecase ( 也就是右下角 )，那么最右下角的状态就确定了，就是matrix 二维表 右下角的值，还有，最下一行的值也可以全部填上，最右一列的值也可以全部填上，最下一行的每个值等于 右边的值加上当前值，所以可以从右往左填上，最右一列同理

{% asset_img picture5.jpg %}

<br/>

所有这样类型的题都是这样的套路：

1. 把需要的位置点出来
2.  回到basecase ，把不被依赖的位置设置好；对于这道题，就是把最下一行和最右一列设置好
3. 然后分析一个普遍位置是怎么依赖的；根据函数可知，一个位置的状态需要右边的状态和下边的状态；
4. 最后根据basecase ( 最右下角的点 )  往上一直递推到我们想要的状态即可；

<br/>

**最重要的：写出尝试版本**

然后看参数固定，结果是否固定，如果是：那么一定可以改成动态规划，再按照上面的套路去做；

<br/>

不要背什么转移方程，转移方程就是递归来的，其实动态规划本质就是一个空间换时间的概念；所以学会怎么去尝试是最重要的；

也可以理解为搭积木的过程，找到我们最终想要的积木，找到一开始的地基，中间一块积木依赖哪些位置的积木，依次搭过去，搭到终止位置，就找到了我们想要的积木；

<br/>

dp代码

```java
public class Code_07_MinPath {

    public static int minPath1(int[][] matrix) {
        return process1(matrix, matrix.length - 1, matrix[0].length - 1);
    }

    /**
     * 从(i,j) 出发，到达最右下角位置，最短路径和是多少？
     * @param matrix：
     * @param i：行
     * @param j：列
     * @return
     */
    public static int process1(int[][] matrix, int i, int j) {
        int res = matrix[i][j];
        if (i == 0 && j == 0) {
            return res;
        }
        if (i == 0 && j != 0) {
            return res + process1(matrix, i, j - 1);
        }
        if (i != 0 && j == 0) {
            return res + process1(matrix, i - 1, j);
        }
        return res + Math.min(process1(matrix, i, j - 1), process1(matrix, i - 1, j));
    }

    public static int minPath2(int[][] m) {
        if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) {
            return 0;
        }
        int row = m.length;
        int col = m[0].length;
        int[][] dp = new int[row][col];
        dp[0][0] = m[0][0];
        for (int i = 1; i < row; i++) {
            dp[i][0] = dp[i - 1][0] + m[i][0];
        }
        for (int j = 1; j < col; j++) {
            dp[0][j] = dp[0][j - 1] + m[0][j];
        }
        for (int i = 1; i < row; i++) {
            for (int j = 1; j < col; j++) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + m[i][j];
            }
        }
        return dp[row - 1][col - 1];
    }

    // for test
    public static int[][] generateRandomMatrix(int rowSize, int colSize) {
        if (rowSize < 0 || colSize < 0) {
            return null;
        }
        int[][] result = new int[rowSize][colSize];
        for (int i = 0; i != result.length; i++) {
            for (int j = 0; j != result[0].length; j++) {
                result[i][j] = (int) (Math.random() * 10);
            }
        }
        return result;
    }


    /**
     * 从(i,j)出发，到达最右下角位置，最短路径和是多少？
     * 暴力递归的方式
     * 缺点：会有很多的重复计算。
     * @param matrix：
     * @param i：行
     * @param j：列
     * @return
     *
     * 无后效性问题：
     * 只要状态的参数定了，返回值一定确定。
     * 有后效性问题：
     * 汉诺塔问题：要求就是打印所有的步骤，之前做出的选择，必然会影响着解，所以是有后效性的。
     *
     * 这里(i,j)确定了，那么解就确定了。
     * 那么所有的 (i,j) 的返回结果就会出现在一张二维表里。
     *
     * 高度套路：
     * 最重要的：写出尝试版本
     * 然后分析可变参数，哪几个可变参数可以代表返回值的状态，可变参数是几维的，就是一张几维表，
     * 然后看看终止状态是哪一个，在表中点出来，然后回到base case中，把完全不依赖的位置的值，设置好，
     * 然后一个普遍位置，看看它需要哪些位置，逆着回去，就是填表的顺序。
     */
    public static int walk(int[][] matrix, int i, int j) {
        if(i == matrix.length && j == matrix[0].length){
            return matrix[i][j];
        }

        if(i == matrix.length - 1){ //如果到达最后一行，那么只能向右走。
            return matrix[i][j] + walk(matrix,i,j+1);
        }
        if(j == matrix[0].length){//如果到达最后一列了，那么只能向下走。
            return matrix[i][j] + walk(matrix,i+1,j);
        }

        int right = walk(matrix,i,j+1);//right-> 右边位置到右下角的最短路径和。
        int down = walk(matrix,i+1,j); //left-> 下边位置到右下角的最短路径和。

        return matrix[i][j] + Math.min(right,down);
    }


    public static void main(String[] args) {
        int[][] m = {{1, 3, 5, 9}, {8, 1, 3, 4}, {5, 0, 6, 1}, {8, 8, 4, 0}};
        System.out.println(minPath1(m));
        System.out.println(minPath2(m));

        m = generateRandomMatrix(6, 7);
        System.out.println(minPath1(m));
        System.out.println(minPath2(m));
    }
}
```

<br/>

<br/>

### 数组arr，整数aim，任意选择arr中的数字，能不能累加得到aim，返回true或者false；

<br/>

假设都是正数

f(x,y) ：x代表位置，y代表累加和，那么开始的状态就是 f(0,0)。每个位置有两个选择，要对应这个位置的数组中的数，还是不要这个位置数组中的数字，和求子序列一样；最终的状态图如下：

叶节点是我们要的所有的最终决定；

{% asset_img picture6.jpg %}

<br/>

暴力递归

```java
/**
     * 和子序列的树形图一致，
     * 图示：数组中的元素相加能不能得到aim
     * @param arr
     * @param index   第几层
     * @param sum     当前形成的和
     * @param aim
     * @return
     */
public static boolean isSum(int[] arr,int index,int sum, int aim){

    if(index == arr.length){
        return sum == aim;
    }

    return isSum(arr,index+1,sum,aim) || isSum(arr,index+1,sum+arr[index],aim);
}
```

<br/>

后效性分析：