---
title: 数据结构之树
categories:
  - 数据结构
abbrlink: 6c17d6bd
date: 2018-01-21 16:07:55
---

# 树

#### 结点的度

¨结点拥有的子树数称为结点的度。度为0的结点称为叶子结点或终端结点，度不为0的结点称为非终端结点或分支结点。除根结点以外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。

#### 层次与深度

节点的层次从根开始定义，根为第一层，根的孩子为第二层，若某节点在第i层，则其子树就在第i+1层，其双亲在同一层的节点互为堂兄弟，

树中节点的最大层次称为树的深度或高度，当前树的深度为4

{% asset_img 树的层次与深度.png %}

```java
/**
 * @return  二叉树的高度
 */
public int getHight(){
  return getHight(root);
}

private int getHight(TreeNode node) {

  if(node == null){
    return 0;
  }else{
    int i = getHight(node.leftChild);
    int j = getHight(node.rightChild);
    return (i>j)? (i+1) : (j+1);
  }
}
```
{% asset_img 函数的递归调用.png %}

<br/>

### 有序与无序树

如果将树中节点的各子树看成从左到右是有次序的，不能互换的，则称该树为有序树，否则称为无序树，

### 森林

森林是m (m>=0) 棵互不相交的树的集合。

### 树的存储结构

简单的顺序存储不能满足树的实现

结合顺序存储和链式存储来实现

### 三种表示方法

双亲表示法

孩子表示法

孩子兄弟表示法



#### 双亲表示法

在每个节点中，附设一个指示器指示其双亲节点到链表中的位置。

是链式存储结构

找父亲比较容易，但是找孩子比较复杂，算法的复杂度较高

{% asset_img 树的双亲表示法.png %}

<br/>

#### 孩子表示法

方案1. 数据域和指针域，指针域用数组存储，存储每个孩子的地址，找孩子比较方便，找父亲复杂，还有可能造成空间浪费。

方案2. 也是数据域和指针域，但是在数据域上加一个数字，表示有几个孩子，虽然解决了存储空间浪费的问题，但是没有解决找父亲困难的问题。

最终方案.  把每个结点的孩子结点排列起来，以单链表作为存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空，然后n个头指针又组成一个线性表，采用顺序存储结构，存放在一个一维数组中，其实就是散列链表。

{% asset_img 树的散列链表存储方式.png %}

<br/>

#### 孩子兄弟表示法

任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟

{% asset_img 树的孩子兄弟表示法.png %}

<br/>

### 二叉树

二叉树是n (n>=0) 个节点的有限集合，该集合或者为空集(称为空二叉树)，或者由一个根节点和两棵互不相交的，分别称为根节点的左子树和右子树的二叉树组成。

### 特殊二叉树

#### 斜树

所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树，

线性表结构其实可以理解为树的一种树表达形式

#### 满二叉树

在一棵二叉树中，如果所有的分支节点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树

#### 完全二叉树

对一棵具有n个节点的二叉树按层序编号，如果编号为i (1<= i <= n) 的节点与同样深度的满二叉树中编号为i的节点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。

{% asset_img 完全二叉树.png %}

### 判断完全二叉树

完全二叉树：叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树

### 二叉树的性质

性质1：在二叉树的第i层上至多有2的i-1次方个结点（i>=1）。 数学归纳法证明

性质2：深度为k的二叉树至多有2的k次方-1个结点（k>=1）。  等比数列通项公式证明

性质3：对任何一颗二叉树T，如果其终端结点数为n0,度为2的  结点  数为n2，则n0 = n2+1.

性质4：具有n个结点的完全二叉树深度为[以2为底n的对数]+1 ([x]表示不  大于  x的最大整数)。

性质5：如果对一颗有n个结点的完全二叉树（其深度为[log2n]+1）  的结点按层序编号（从第1层到第[log2n]+1层，每层从左到  右），对任意一个结点i(1<=i<=n)有：

1）.如果i=1,则结点i是二叉树的根，无双亲；如果i>1,则其双亲是结  点[i/2]

2）.如果2i>n,则结点i无左孩子（结点i为叶子结点）；否则其左孩  子是结点2i。

3）.如果2i+1>n,则结点i无右孩子；否则其右孩子是结点2i+1。

~~~java
/**
 * 树的节点数目
 * @author clay
 */
public int size(){
  return getSize(root);
}

private int getSize(TreeNode node) {

  if(node == null){
    return 0;
  }else{
    return 1+getSize(node.leftChild) + getSize(node.rightChild);
  }
}
~~~

<br/>

### 性质三的证明

设n为总节点数，n1为度为1的节点数，n2为度为2的节点数，n0为终端节点数，

用代数表达就是分支线总数=n-1=n1+2n2，因为刚才我们有等式n=n0+n1+n2，所以可推导出n0+n1+n2-1=n1+2n2，结论就是n0=n2+1

**1. n=n0+n1+n2    n表示二叉树中的节点总个数,n1表示度数为1的节点个数**

**2.n-1=2n2+n1      通过观察二叉树我们可知，除了根节点之外，其余的任何节点都有一个入口分支，其他节点都有一个入口分支，那么节点的总分支数等于节点个数减一，度数为2的节点有2个出口分支，度数为一的有1个出口分支，度数为0的节点没有出口分支 所以总的分支个数为 2n2+n1**

<br/>

### 性质四的证明

 推导过程根据性质 2: 假设深度为k 的满二叉树的节点个数一定为2的k次方-1，那么n=2的k次方-1推得满二叉树的度数为k=log2(n+1);

 完全二叉树是具有n个节点的二叉树，若按层序编号那么其编号与同样深度的满二叉树的节点编号在二叉树的位置相同，那么他就是完全二叉树，也就是说他的叶子几点只可能出现在最下边的两层，他的深度等于满二叉的深度，但他的节点一定少于等于满二叉树的节点个数，但一定多于2的k-1次方-1,2的k-1次方-1是深度数为k-1层的满二叉树的节点个数，那么n就满足2的k-1次方-1<n<=2的k次方-1,由于n为整数那么n<=2的k次方-1可以推出n<=2的k次方 ,n>2的k-1次方-1可以推出 n>=2的k-1次方,所以2的k-1次方<n<=2的k次方  ,即可得k-1<=log2 n<k 而k作为整数因此k=[log2 n]+1

<br/>

### 二叉树的顺序存储结构

####  完全二叉树

{% asset_img 完全二叉树顺序存储.png %}

#### 一般二叉树

{% asset_img 一般二叉树顺序存储.png %}

#### 二叉树的二叉链表存储方式

{% asset_img 二叉树的二叉链表存储方式.png %}

<br/>

### 二叉树的遍历

(记住顺序是以中字作为分别的，前序中在前边，中序中字在中间，后序中字在后边)

#### 前序遍历（中左右）

规则是若二叉树为空，则空操作返回，否则先访问跟结点，然后前序遍历左子树，再前序遍历右子树

```java
/**
 * 前序遍历
 */
public void preOrder(TreeNode node){
  if(node == null){
    return;
  }else{
    System.out.println(node.data);
    preOrder(node.leftChild);
    preOrder(node.rightChild);
  }
}
```
{% asset_img 利用出栈顺序实现前序遍历.png %}

```java
/**
 * 栈实现先序遍历
 * @param node
 */
public void nonRecOrder(TreeNode node){
  if(node == null){
    return;
  }
  Stack<TreeNode> stack = new Stack<>();
  stack.push(node);
  while(!stack.isEmpty()){
    //出栈和进栈
    TreeNode n = stack.pop();//弹出根节点
    System.out.println("nonRecOrder data: " + n.getData());
    //压入子节点
    if(n.rightChild != null){
      stack.push(n.rightChild);
    }
    if(n.leftChild != null){
      stack.push(n.leftChild);
    }
  }
}
```
#### 中序遍历（左中右）

规则是若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树

```java
/**
 * 中序遍历
 */
public void midOrder(TreeNode node){
  if(node == null){
    return;
  }else{
    preOrder(node.leftChild);
    System.out.println(node.data);
    preOrder(node.rightChild);
  }
}
```
#### 后序遍历（左右中）

规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层，按从左到右的顺序对结点逐个访问

```java
/**
 * 后序遍历
 */
public void postOrder(TreeNode node){
  if(node == null){
    return;
  }else{
    preOrder(node.leftChild);
    preOrder(node.rightChild);
    System.out.println(node.data);
  }
}
```
<br/>

### 完整代码

~~~~java
public class BinaryTree {
  private TreeNode  root = null;

  public BinaryTree(){
    root = new TreeNode(1, "A");
  }

  /**
	 * 构建二叉树
	 *         A
	 *     B       C
	 * D      E        F
	 */
  public void createBinaryTree(){
    TreeNode nodeB = new TreeNode(2, "B");
    TreeNode nodeC = new TreeNode(3, "C");
    TreeNode nodeD = new TreeNode(4, "D");
    TreeNode nodeE = new TreeNode(5, "E");
    TreeNode nodeF = new TreeNode(6, "F");
    root.leftChild = nodeB;
    root.rightChild = nodeC;
    nodeB.leftChild = nodeD;
    nodeB.rightChild = nodeE;
    nodeC.rightChild = nodeF;
  }

  /**
	 * 求二叉树的高度
	 * @author Administrator
	 *
	 */
  public int getHeight(){
    return getHeight(root);
  }

  private int getHeight(TreeNode node) {
    if(node == null){
      return 0;
    }else{
      int i = getHeight(node.leftChild);
      int j = getHeight(node.rightChild);
      return (i<j)?j+1:i+1;
    }
  }

  /**
	 * 获取二叉树的结点数
	 * @author Administrator
	 *
	 */
  public int getSize(){
    return getSize(root);
  }


  private int getSize(TreeNode node) {
    if(node == null){
      return 0;
    }else{
      return 1+getSize(node.leftChild)+getSize(node.rightChild);
    }
  }

  /**
	 * 前序遍历——迭代
	 * @author Administrator
	 *
	 */
  public void preOrder(TreeNode node){
    if(node == null){
      return;
    }else{
      System.out.println("preOrder data:"+node.getData());
      preOrder(node.leftChild);
      preOrder(node.rightChild);
    }
  }

  /**
	 * 前序遍历——非迭代
	 */

  public void nonRecOrder(TreeNode node){
    if(node == null){
      return;
    }
    Stack<TreeNode> stack = new Stack<TreeNode>();
    stack.push(node);
    while(!stack.isEmpty()){
      //出栈和进栈
      TreeNode n = stack.pop();//弹出根结点
      //压入子结点
      System.out.println("nonRecOrder data"+n.getData());
      if(n.rightChild!=null){
        stack.push(n.rightChild);

      }
      if(n.leftChild!=null){
        stack.push(n.leftChild);
      }
    }
  }
  /**
	 * 中序遍历——迭代
	 * @author Administrator
	 *
	 */
  public void midOrder(TreeNode node){
    if(node == null){
      return;
    }else{
      midOrder(node.leftChild);
      System.out.println("midOrder data:"+node.getData());
      midOrder(node.rightChild);
    }
  }

  /**
	 * 后序遍历——迭代
	 * @author Administrator
	 *
	 */
  public void postOrder(TreeNode node){
    if(node == null){
      return;
    }else{
      postOrder(node.leftChild);
      postOrder(node.rightChild);
      System.out.println("postOrder data:"+node.getData());
    }
  }
  public class TreeNode{
    private int index;
    private String data;
    private TreeNode leftChild;
    private TreeNode rightChild;


    public int getIndex() {
      return index;
    }


    public void setIndex(int index) {
      this.index = index;
    }


    public String getData() {
      return data;
    }


    public void setData(String data) {
      this.data = data;
    }


    public TreeNode(int index,String data){
      this.index = index;
      this.data = data;
      this.leftChild = null;
      this.rightChild = null;
    }
  }


  public static void main(String[] args){
    BinaryTree binaryTree = new BinaryTree();
    binaryTree.createBinaryTree();
    int height = binaryTree.getHeight();
    System.out.println("treeHeihgt:"+height);
    int size = binaryTree.getSize();
    System.out.println("treeSize:"+size);
    //		binaryTree.preOrder(binaryTree.root);
    //		binaryTree.midOrder(binaryTree.root);
    //		binaryTree.postOrder(binaryTree.root);
    binaryTree.nonRecOrder(binaryTree.root);
  }
}
	
~~~~

