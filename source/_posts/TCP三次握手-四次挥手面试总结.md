---
title: TCP三次握手-四次挥手面试总结
categories:
  - 计算机网络
abbrlink: 767c3cbc
date: 2018-06-02 20:05:28
---

### 三次握手

{% asset_img 11.png %}

三次握手的过程如下：

- 客户端A 发送SYN（seq = x）报文给服务器B，然后进入SYN_SENT状态；
- B收到SYN报文，回应一个SYN（seq = y） ACK （ACK = x + 1）报文，进入SYN_RCVD状态；
- A收到SYN报文后，回应一个ACK（ACK = y + 1），进入ESTABLISHED状态；B收到ACK报文后，进入ESTABLISHED状态

三次握手后，A和B成功地建立了连接，可以开始传输数据了~

 <br/>

### 四次挥手

{% asset_img 22.png %}

四次挥手的过程如下： 

- 客户端A上的某个进程，主动关闭连接，发送FIN（seq = u）报文给B，然后进入FIN_WAIT_1状态；
- B收到FIN报文，回应一个ACK （ACK = u + 1）报文，进入CLOSED_WAIT状态；A收到FIN报文，进入FIN_WAIT_2状态；
- B向A发送FIN（seq = v）报文，进入LAST_ACK状态；
- A收到FIN报文后，向B发送ACK(ACK = v + 1)报文，进入TIME_WAIT状态

四次挥手后，A和B成功地断开了连接~ 

 <br/>

### 为什么要采用三次握手，两次不行吗？ 

​	现在假设出现一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络节点长时间滞留了，以致延误到连接释放以后的某个时间才到达B，本来这是一个早已失效的报文段，但B收到此失效的连接请求后，就误以为是A又发出一次新的连接请求，于是就向A发出确认报文段，同意建立连接，假定不采用三次握手，那么只要B发出确认，新的连接就建立了，

​	由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据，但B却以为新的传输连接已经建立了，并一直等待A来发出数据，B的许多资源就这样白白浪费了，

​	采用三次握手的方法可以防止上述现象的发生，假如在刚才的情况下，A不会向B的确认发出确认，B由于收不到确认，就知道A并没有要求建立连接，

​	

 <br/>

### 为什么A在TIME_WAIT状态必须等待2MSL的时间？

​	为了保证A发送的最后一个ACK报文能够达到B，这个ACK报文段有可能丢失，因而使得处在LAST_ACK状态的B收不到对自己发送的 FIN +ACK 报文段的确认。B会超时重传这个FIN + ACK报文段，而A就在2MSL时间内收到这个重传的FIN + ACK 报文段，接着A重传一次确认，重新启动2MSL定时器，最后，A和B都正常进入到CLOSED状态，如果A在TIME_WAIT状态不等待一段时间，而是在发送完ACK报文段后立即释放连接，那么就无法收到B重传的FIN + ACK报文段，因而也不会再发送一次确认报文段，这样，B就无法按照正常步骤进入CLOSED状态。

 <br/>

### 保活计时器： 

设想有这样的情况：客户端已主动与服务器建立了TCP连接，但后来客户端的主机突然出现故障。

通常设为2小时。若2小时没有收到客户端的数据，服务器就发送一个探测报文段，以后则每隔75分钟发送一次。若一连发送10个探测报文段后仍无客户端的响应，服务器就认为客户端出现了故障，接着就关闭这个连接。

 <br/>

### 为什么连接的时候是三次握手，关闭的时候却是四次握手？

答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

 <br/>

### 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。 