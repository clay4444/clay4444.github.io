---
title: 策略模式详解
categories:
  - 设计模式
abbrlink: 148c5e8e
date: 2017-12-07 09:16:10
---



###  通过鸭子游戏看策略模式的原理

<br/>

#### 没有使用策略模式的情况下：

超类: 鸭子

~~~java
public abstract class Duck {

  public Duck(){
  }

  public void Quack(){
    System.out.println("~~gaga~~");
  }

  public abstract void display();

  public void swim(){
    System.out.println("~~ i am swim ~~");
  }
}
~~~

绿头鸭：

~~~java
public class GreenHeadDuck extends Duck{

  @Override
  public void display(){
    System.out.println("**green head **");
  }
}
~~~

红头鸭：

~~~java
public class RedHeadDuck extends Duck{

  public void display() {
    System.out.println("**red head**");
  }
}
~~~

<br/>

#### 新需求：鸭子会飞

修改超类 鸭子为：

~~~java
public abstract class Duck {

  ...;
  public void fly(){
    System.out.println("~~ i am fly ~~");
  }
}
~~~

<br/>

#### 由此导致的问题：

超类的fly方法让所有的子类都会飞了，这是不科学的。

引申：对类的局部改动，尤其超类的局部改动，会影响其他部分，影响会有溢出效应

<br/>

#### 解决方法：

继续用OO原理来解决，覆盖：

~~~java
public class GreenHeadDuck extends Duck{
  ...;
  public void fly(){
    System.out.println("~~ no fly~~");
  }
}
~~~

<br/>

#### 新的问题：

又有新的需求，石头鸭子：会填坑，

~~~java
public class StoneDuck extends Duck{
  ....;
}
~~~

超类挖的一个坑，每个子类都要来填，增加工作量，复杂度O(N^2) ,不是好的设计方式

<br/>

#### 最后的设计方案：

飞行为族接口：

~~~java
public interface FlyBehavior {

  void fly();
}
~~~

飞行为族实现：

~~~java
public class GoodFlyBehavivor implements FlyBehavior {

    public void fly() {
        System.out.println("i can fly a long distance ");
    }
}
~~~

叫行为族接口

~~~java
public interface QuackBehavivor {

  void quack();
}
~~~

叫行为族实现：

~~~java
public class GaGaQuackBehavivor implements QuackBehavivor{
  public void quack() {

    System.out.println("~~GaGa..~~");
  }
}
~~~

鸭子的最终实现：

```java
public abstract class Duck {

  FlyBehavior flyBehavior;
  QuackBehavivor quackBehavivor;

  public Duck(){
  }

  public void Quack(){
    quackBehavivor.quack();
  }

  public abstract void display();

  public void swim(){
    System.out.println("~~ i am swim ~~");
  }

  public void fly(){
    flyBehavior.fly();
  }
}
```

绿头鸭：

~~~java
public class GreenHeadDuck extends Duck{

  public GreenHeadDuck() {
    flyBehavior = new GoodFlyBehavivor();
    quackBehavivor = new GaGaQuackBehavivor();
  }

  @Override
  public void display(){
    System.out.println("**green head **");
  }
}
~~~

测试类：

```java
public class StrategyMain {

  public static void main(String[] args) {

    Duck greenDuck = new GreenHeadDuck();
    greenDuck.fly();
    greenDuck.Quack();
    greenDuck.display();
  }
}
```

<br/>

结果：

{% asset_img 1.png %}

<br/>

#### 实现的原理

具体的行为就不是在类里面实现，而是通过行为族，直接用new一个行为族的对象来进行实现，这样行为的展现方式就变成组合了。就是用行为族里面的对象展现它的行为，而不是具体把行为代码写在类的对象中。

### 策略模式：

分别封装行为接口，实现算法族，超类里放置行为接口对象，在子类里面具体设定行为对象，原则就是：分离变化部分，封装接口，基于接口编程各种功能，此模式让行为算法的变化独立于算法的使用者。