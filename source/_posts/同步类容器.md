---
title: 同步类容器
categories:
  - 多线程编程
abbrlink: bdf654d1
date: 2017-07-19 12:03:55
---

## 同步类容器

- 总结：同步类容器是线程安全的，但是只是每个单个的方法保持着安全性，即添加方法，获取方法，它实现的方式无非就是在每个这样的方法上加上synchronized锁，这样只是保证了每个独立方法的线程安全性，但是没有若是复合操作的话，比如遍历，根据指定的index访问元素，如果在这期间，其他线程修改或者删除了某个(或者是确定的一个)，那么还是会有线程安全问题的，而且每次只能有一个线程访问容器的状态，很显然不能满足高并发的需求； 这里还有一点需要注意的是：抛出ConcurrentModificationException这个异常的情况是当一个线程正在用迭代器遍历的时候，被其他线程修改了其元素的值，产生这个异常的原因和堆这个异常的处理方法在第七篇笔记中有详细的说明。

<br/>

- 同步类容器都是线程安全的，但在某些场景下可能需要加锁来保护复合操作。复合类操作如：迭代(反复访问元素，遍历完容器中的所有元素)、跳转(根据指定的顺序找到当前元素的下一个元素)、以及条件运算。这些复合操作在多线程并发的修改容器时，可能会表现出意外的行为，最经典的便是ConcurrentModificationException，原因是当容器迭代的过程中，被并发的修改了内容，这是由于早期迭代器设计的时候并没有考虑并发修改的问题。

<br/>

- 同步类容器：如古老的Vector/HashTable。这些容器的同步功能其实都是有JDK的Collections.syncronized等工厂方法区创建实现的。其底层的机制无非就是用传统的synchronized关键字对每个公用的方法都进行同步，使得每次只能有一个线程访问容器的状态。这很明显不满足我们今天互联网时代高并发的需求，在保证线程安全的同时，也必须有足够好的性能。
- 实例代码

```java
//线程任务类，获取集合中的最后一个元素
class GetLast implements Runnable{

  private Vector<Integer> list;

  public GetLast(Vector<Integer> list) {
    this.list = list;
  }
  @Override
  public void run() {
    while(true){
      try{
        Test.getLast(list);
      }catch(Exception e){
        e.printStackTrace();
        System.out.println(e.getMessage() + " --- in class GetLast");
        break;
      }

    }

  }

}
//线程任务类，删除&添加元素
class DeleteAndAdd implements Runnable{

  private Vector<Integer> list;

  public DeleteAndAdd(Vector<Integer> list) {
    this.list = list;
  }
  @Override
  public void run() {
    while(true){
      try{
        Test.deleteAndAdd(list);
      }catch(Exception e){
        e.printStackTrace();
        System.out.println(e.getMessage() + " --- in class DeleteAndAdd");
        break;
      }

    }

  }

}

public class Test {

  //获取最后一个元素
  public static  Integer getLast(Vector<Integer> list){
    //这里根据list.size()得到最后一个元素的索引
    //换句话说，这条语句已经检查认为在集合list中存在索引为list.size() - 1的元素
    int lastIndex = list.size() - 1;

    if(lastIndex < 0) return null;

    //返回指定索引处的元素
    return list.get(lastIndex);
  }

  //删除元素，添加元素
  public static  void deleteAndAdd(Vector<Integer> list){
    int lastIndex = list.size() - 1;
    if(lastIndex < 0) return;
    list.remove(lastIndex);
    list.add(3);
  }

  public static void main(String[] args) {
    Vector<Integer> vector = new Vector<Integer>();
    vector.add(1);
    vector.add(2);

    ExecutorService exec = Executors.newCachedThreadPool();

    GetLast gl = new GetLast(vector);
    DeleteAndAdd daa = new DeleteAndAdd(vector);

    exec.execute(gl);
    exec.execute(daa);

  }
}
```

- 分析：运行以上程序，很快发现在getLast中抛出了java.lang.ArrayIndexOutOfBoundsException异常，原因在于getLast方法不是原子操作，调用size方法和get方法之间，其它线程执行了remove操作，导致容器大小变小，索引访问越界，抛出异常。若想得到正确结果，可修改代码，对getLast和deleteAndAdd方法里的操作加锁（因为Vector内部是通过自身对象作为锁的，所以这里同样以Vector对象作为锁），使之成为原子操作，如下代码：

~~~~java
//获取最后一个元素
public static  Integer getLast(Vector<Integer> list){
  synchronized(list){
    //这里根据list.size()得到最后一个元素的索引
    //换句话说，这条语句已经检查认为在容器list中存在索引为list.size() - 1的元素
    int lastIndex = list.size() - 1;

    if(lastIndex < 0) return null;

    //返回指定索引处的元素
    return list.get(lastIndex);
  }
}

//删除元素，添加元素
public static  void deleteAndAdd(Vector<Integer> list){
  synchronized(list){
    int lastIndex = list.size() - 1;
    if(lastIndex < 0) return;
    list.remove(lastIndex);
    list.add(3);
  }
}
~~~~

- 另外，在对vector的元素遍历时（for循环方式），其它线程删除了容器中的一个元素，也会抛出异常java.lang.ArrayIndexOutOfBoundsException异常，原因与上面提到的getLast方法一样，在访问最后一个元素的时候越界了；

```java
for(int i = 0; i < vector.size(); i++){
  System.out.println(vector.get(i));
}
```

- 一个可行的修改方式同样是对容器加锁，但代价较大，导致其它线程在迭代期间不能访问容器，降低了并发性；

~~~~java
synchronized(vector){
  for(int i = 0; i < vector.size(); i++){
    System.out.println(vector.get(i));
  }
}
~~~~

