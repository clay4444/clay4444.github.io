---
title: 算法进阶第三课
categories:
  - leetcode
abbrlink: 42c55172
date: 2019-03-22 12:46:16
---

### Morris 遍历

经典二叉树的遍历不管是递归还是非递归，都避免不了额外空间复杂度O(h)，递归是程序帮我们压栈，非递归是我们自己压栈，因为当我们遍历左子树或者右子树的时候，我们希望遍历完一遍后，还回到当前节点，所以这个过程是省不掉的；

<br/>

morris遍历

时间复杂度O(N)，空间复杂度O(1)

指向null也是会占用空间的，morris遍历就是利用这些剩余空间来完成遍历的，相当于是修改原来二叉树的结构，让我们可以回去，这一种统一思路叫做线索二叉树；

<br/>

标准：

当前节点记为cur，

1. 如果CUR没有左孩子，CUR向右移动，CUR = cur.right
2. 如果CUR有左孩子，找到左子树最右节点，记为mostright
   1. 如果mostright的右指针指向空，让它指向CUR，然后CUR向左移动，CUR = cur.left
   2. 如果mostright的右指针指向CUR，让它指回空，然后CUR向右移动，CUR = cur.right

<br/>

本质

只要一个节点有左子树，morris遍历就能回到他两次，而且当第二次到达这个节点的时候，左子树上的所有节点，一定都已经遍历完了；

如果一个节点没有左子树，那么只到达这个节点一次；

{% asset_img picture1.jpg %}

<br/>

递归版本的遍历

```java
	/**
     * 使用递归的方式实现二叉树的先序、中序、后序遍历
     * 将打印置于不同位置可以实现不同的遍历效果
     */
public static void process(Node head) {
    if (head == null) {
        return;
    }
    // 1
    //System.out.println(head.value);
    process(head.left);
    // 2
    //System.out.println(head.value);
    process(head.right);
    // 3
    //System.out.println(head.value);
}
```

递归版的遍历就是：

无论怎样，只要这个节点不空，我就可以来到这个节点三次， 这就是递归版的遍历；

<br/>

morris遍历就是高度向这个过程致敬，如果这个节点有左子树，我可以来到我自己当前节点两次，如果没有左子树， 只能来到当前节点一次，但是在遍历右子树的时候，无法再第三次回到自己的过程，就是morris遍历；那么它是如何标记是第一次来到这个节点还是第二次来到这个节点呢？ **其实就是利用左子树上最右节点的右指针指向谁这件事情来标记是第一次来到这个节点还是第二次来到这个节点**。

<br/>

如果左子树最右的节点是指向空的，我就知道是第一次来到这个节点，此时就让左子树最右的节点的右指针指向当前节点，也就是记录下这个节点，方便下次回到这个节点。还因为是第一次来到这个节点，所以需要处理左子树，所以当前节点向左移动；

<br/>

如果左子树最右的节点是指向cur的，我就知道是第二次来到这个节点了，所以让它重新指回空，因为已经第二次回到当前节点了，此后都不会再回到当前节点了；因为已经是第二次来到这个节点了，所以就让当前节点向右移动；

<br/>

递归版的遍历是记录下每个函数跑的行号这件事情来区分整件事情的，是利用函数体内部的信息来区分是第几次来到这个节点的，而morris不能记录这样的信息，所以它只能利用左子树最右孩子的右指针是否指向自己这件事情来判断是第一次来到这个节点还是第二次；

<br/>

递归版本的最本质的遍历过程：

{% asset_img picture2.jpg %}

我们把打印的时机放到第一次来到这个函数的时候，就是先序。第二次，就是中序，第三次，就是后序，但其实最本质的打印还是如图所示的打印；先序、中序、后序，只是把打印时机放在不同的地方，而产生的结果；

<br/>

morris遍历同理，我们把打印时机放在第一次来到这个节点的时候，就打印，就是先序遍历，把打印时机放在第二次来到这个节点的时候，就是中序遍历。

<br/>

morris的后序遍历：

只关注能够第二次来到的节点，当第二次来到这个节点的时候，逆序打印这个节点左子树的右边界，整个打印完之后，在整个函数退出之前，单独打印整棵的右边界，就是后序遍历；

<br/>

那此时如何打印整棵树的右边界呢？此时不能使用栈，因为morris的要求是额外空间复杂度O(1)；拓扑图如下：

{% asset_img picture3.jpg %}

使用链表的逆序操作，实现打印，然后再还原回去；

 <br/>

时间复杂度：

还是O(N)

{% asset_img picture4.jpg %}

整棵树是可以被左边界分解的，而且左边界是固定的，也就是N个，在morris的过程中，也就是找左子树的最右边的值的时候，会产生遍历，但是也仅仅只是会产生两次，所以时间复杂度O(N)；

<br/>

代码

```java
public class Code_01_MorrisTraversal {

    /**
     * 使用递归的方式实现二叉树的先序、中序、后序遍历
     * 将打印置于不同位置可以实现不同的遍历效果
     */
    public static void process(Node head) {
        if (head == null) {
            return;
        }
        // 1
        //System.out.println(head.value);
        process(head.left);
        // 2
        //System.out.println(head.value);
        process(head.right);
        // 3
        //System.out.println(head.value);
    }

    public static class Node {
        public int value;
        Node left;
        Node right;

        public Node(int data) {
            this.value = data;
        }
    }

    /**
     * Morris遍历实现二叉树的中序遍历
     * 去掉打印，就是标准的实现；
     */
    public static void morrisIn(Node head) {
        if (head == null) {
            return;
        }
        Node cur = head;
        Node mostRight = null;
        while (cur != null) {
            mostRight = cur.left;
            if (mostRight != null) {
                while (mostRight.right != null && mostRight.right != cur) { //找到左子树最右节点
                    mostRight = mostRight.right;
                }
                if (mostRight.right == null) {//说明是第一次到达当前节点
                    mostRight.right = cur;
                    cur = cur.left;
                    continue;
                } else {
                    mostRight.right = null;
                }
            }
            //如果有左子树，要把左子树处理完了，再去打印，因为中序打印的顺序是左中右，
            System.out.print(cur.value + " ");//将打印语句放在第二次到达有左子树的当前节点
            cur = cur.right;
        }
        System.out.println();
    }

    /**
     * Morris遍历的先序遍历
     */
    public static void morrisPre(Node head) {
        if (head == null) {
            return;
        }
        Node cur = head;
        Node mostRight = null;
        while (cur != null) {
            mostRight = cur.left; //左子树第一个节点
            if (mostRight != null) {
                while (mostRight.right != null && mostRight.right != cur) {
                    mostRight = mostRight.right;
                }
                if (mostRight.right == null) { //当cur的左子树的最右节点是null的时候，就是第一次来到这个节点的时候；
                    mostRight.right = cur;
                    System.out.print(cur.value + " "); //所以，此时直接打印；
                    cur = cur.left;
                    continue;
                } else {
                    mostRight.right = null;
                }
            } else {// 如果一个节点没有左子树，说明只到这个节点一次，所以直接打印；
                System.out.print(cur.value + " ");
            }
            cur = cur.right;
        }
        System.out.println();
    }

    /**
     * Morris遍历的后序遍历
     */
    public static void morrisPos(Node head) {
        if (head == null) {
            return;
        }
        Node cur = head;
        Node mostRight = null;
        while (cur != null) {
            mostRight = cur.left;
            if (mostRight != null) {  //大if
                while (mostRight.right != null && mostRight.right != cur) {
                    mostRight = mostRight.right;
                }
                if (mostRight.right == null) {
                    mostRight.right = cur;
                    cur = cur.left;
                    continue;
                } else {
                    mostRight.right = null;
                    //首先它在大的if里，说明这个节点可以回到自己两次，
                    //其实是在第二次来到这个节点的时机，把打印时机放在了这里；
                    printEdge(cur.left); //逆序打印左子树的右边界
                }
            }
            cur = cur.right;
        }
        printEdge(head);//函数返回之前，单独打印整棵树的右边界；
        System.out.println();
    }

    public static void printEdge(Node head) {
        Node tail = reverseEdge(head);
        Node cur = tail;
        while (cur != null) {
            System.out.print(cur.value + " ");
            cur = cur.right;
        }
        reverseEdge(tail);
    }

    public static Node reverseEdge(Node from) {
        Node pre = null;
        Node next = null;
        while (from != null) {
            next = from.right;
            from.right = pre;
            pre = from;
            from = next;
        }
        return pre;
    }

    // for test -- print tree
    public static void printTree(Node head) {
        System.out.println("Binary Tree:");
        printInOrder(head, 0, "H", 17);
        System.out.println();
    }

    public static void printInOrder(Node head, int height, String to, int len) {
        if (head == null) {
            return;
        }
        printInOrder(head.right, height + 1, "v", len);
        String val = to + head.value + to;
        int lenM = val.length();
        int lenL = (len - lenM) / 2;
        int lenR = len - lenM - lenL;
        val = getSpace(lenL) + val + getSpace(lenR);
        System.out.println(getSpace(height * len) + val);
        printInOrder(head.left, height + 1, "^", len);
    }

    public static String getSpace(int num) {
        String space = " ";
        StringBuffer buf = new StringBuffer("");
        for (int i = 0; i < num; i++) {
            buf.append(space);
        }
        return buf.toString();
    }

    public static void main(String[] args) {
        Node head = new Node(4);
        head.left = new Node(2);
        head.right = new Node(6);
        head.left.left = new Node(1);
        head.left.right = new Node(3);
        head.right.left = new Node(5);
        head.right.right = new Node(7);
        printTree(head);
        morrisIn(head);
        morrisPre(head);
        morrisPos(head);
        printTree(head);
    }
}
```

<br/>

<br/>

### 搜索二叉树

对于任何一个节点，左子树都比它小，右子树都比它大，就是搜索二叉树，

<br/>

如何判断是否是搜索二叉树：

二叉树中序遍历后，是升序排列的，就是搜索二叉树，否则就不是

使用非递归版本的中序遍历过程，在遍历的过程中，用一个变量记录上一个值，在打印的时候，进行比较，比上一个值小，说明肯定不是搜索二叉树

<br/>

平衡性：

平衡二叉搜索树查找的时间复杂度是O(logN)，和这棵二叉树的高度有关

一棵非常不平衡的二叉搜索树查找的时间复杂度可能是O(N)。

<br/>

平衡性可能和给定数字的顺序有关：

例如1，2，3，4，5  如果按照这个顺序插入，会是一棵非常不平衡的二叉树，但是我们实际上，还是希望保持平衡性，所以衍生出了几种树。

<br/>

删除操作：

如果没有左子树或者没有右子树，此时直接用相应的左子树或者右子树往上顶即可；

如果左子树和右子树都存在的话，此时就用右子树最左边的节点顶替要删除的节点即可，然后用最左节点的右子树父节点顶替之前的最左边的节点；例如：

{% asset_img picture6.jpg %}

此时要删除5节点

{% asset_img picture7.jpg %}

<br/>

代码：

```java
public class AbstractBinarySearchTree {

	/** Root node where whole tree starts. */
	public Node root;

	/** Tree size. */
	protected int size;

	/**
	 * Because this is abstract class and various trees have different
	 * additional information on different nodes subclasses uses this abstract
	 * method to create nodes (maybe of class {@link Node} or maybe some
	 * different node sub class).
	 * 
	 * @param value
	 *            Value that node will have.
	 * @param parent
	 *            Node's parent.
	 * @param left
	 *            Node's left child.
	 * @param right
	 *            Node's right child.
	 * @return Created node instance.
	 */
	protected Node createNode(int value, Node parent, Node left, Node right) {
		return new Node(value, parent, left, right);
	}

	/**
	 * Finds a node with concrete value. If it is not found then null is
	 * returned.
	 * 
	 * @param element
	 *            Element value.
	 * @return Node with value provided, or null if not found.
	 */
	public Node search(int element) {
		Node node = root;
		while (node != null && node.value != null && node.value != element) {
			if (element < node.value) {
				node = node.left;
			} else {
				node = node.right;
			}
		}
		return node;
	}

	/**
	 * Insert new element to tree.
	 * 
	 * @param element
	 *            Element to insert.
	 */
	public Node insert(int element) {
		if (root == null) {
			root = createNode(element, null, null, null);
			size++;
			return root;
		}

		Node insertParentNode = null;
		Node searchTempNode = root;
		while (searchTempNode != null && searchTempNode.value != null) {
			insertParentNode = searchTempNode;
			if (element < searchTempNode.value) {
				searchTempNode = searchTempNode.left;
			} else {
				searchTempNode = searchTempNode.right;
			}
		}

		Node newNode = createNode(element, insertParentNode, null, null);
		if (insertParentNode.value > newNode.value) {
			insertParentNode.left = newNode;
		} else {
			insertParentNode.right = newNode;
		}

		size++;
		return newNode;
	}

	/**
	 * Removes element if node with such value exists.
	 * 
	 * @param element
	 *            Element value to remove.
	 * 
	 * @return New node that is in place of deleted node. Or null if element for
	 *         delete was not found.
	 */
	public Node delete(int element) {
		Node deleteNode = search(element);
		if (deleteNode != null) {
			return delete(deleteNode);
		} else {
			return null;
		}
	}

	/**
	 * Delete logic when node is already found.
	 * 
	 * @param deleteNode
	 *            Node that needs to be deleted.
	 * 
	 * @return New node that is in place of deleted node. Or null if element for
	 *         delete was not found.
	 */
	protected Node delete(Node deleteNode) {
		if (deleteNode != null) {
			Node nodeToReturn = null;
			if (deleteNode != null) {
				if (deleteNode.left == null) {
					nodeToReturn = transplant(deleteNode, deleteNode.right);
				} else if (deleteNode.right == null) {
					nodeToReturn = transplant(deleteNode, deleteNode.left);
				} else {
					Node successorNode = getMinimum(deleteNode.right);
					if (successorNode.parent != deleteNode) {
						transplant(successorNode, successorNode.right);
						successorNode.right = deleteNode.right;
						successorNode.right.parent = successorNode;
					}
					transplant(deleteNode, successorNode);
					successorNode.left = deleteNode.left;
					successorNode.left.parent = successorNode;
					nodeToReturn = successorNode;
				}
				size--;
			}
			return nodeToReturn;
		}
		return null;
	}

	/**
	 * Put one node from tree (newNode) to the place of another (nodeToReplace).
	 * 
	 * @param nodeToReplace
	 *            Node which is replaced by newNode and removed from tree.
	 * @param newNode
	 *            New node.
	 * 
	 * @return New replaced node.
	 */
	private Node transplant(Node nodeToReplace, Node newNode) {
		if (nodeToReplace.parent == null) {
			this.root = newNode;
		} else if (nodeToReplace == nodeToReplace.parent.left) {
			nodeToReplace.parent.left = newNode;
		} else {
			nodeToReplace.parent.right = newNode;
		}
		if (newNode != null) {
			newNode.parent = nodeToReplace.parent;
		}
		return newNode;
	}

	/**
	 * @param element
	 * @return true if tree contains element.
	 */
	public boolean contains(int element) {
		return search(element) != null;
	}

	/**
	 * @return Minimum element in tree.
	 */
	public int getMinimum() {
		return getMinimum(root).value;
	}

	/**
	 * @return Maximum element in tree.
	 */
	public int getMaximum() {
		return getMaximum(root).value;
	}

	/**
	 * Get next element element who is bigger than provided element.
	 * 
	 * @param element
	 *            Element for whom descendand element is searched
	 * @return Successor value.
	 */
	// TODO Predecessor
	public int getSuccessor(int element) {
		return getSuccessor(search(element)).value;
	}

	/**
	 * @return Number of elements in the tree.
	 */
	public int getSize() {
		return size;
	}

	/**
	 * Tree traversal with printing element values. In order method.
	 */
	public void printTreeInOrder() {
		printTreeInOrder(root);
	}

	/**
	 * Tree traversal with printing element values. Pre order method.
	 */
	public void printTreePreOrder() {
		printTreePreOrder(root);
	}

	/**
	 * Tree traversal with printing element values. Post order method.
	 */
	public void printTreePostOrder() {
		printTreePostOrder(root);
	}

	/*-------------------PRIVATE HELPER METHODS-------------------*/

	private void printTreeInOrder(Node entry) {
		if (entry != null) {
			printTreeInOrder(entry.left);
			if (entry.value != null) {
				System.out.println(entry.value);
			}
			printTreeInOrder(entry.right);
		}
	}

	private void printTreePreOrder(Node entry) {
		if (entry != null) {
			if (entry.value != null) {
				System.out.println(entry.value);
			}
			printTreeInOrder(entry.left);
			printTreeInOrder(entry.right);
		}
	}

	private void printTreePostOrder(Node entry) {
		if (entry != null) {
			printTreeInOrder(entry.left);
			printTreeInOrder(entry.right);
			if (entry.value != null) {
				System.out.println(entry.value);
			}
		}
	}

	protected Node getMinimum(Node node) {
		while (node.left != null) {
			node = node.left;
		}
		return node;
	}

	protected Node getMaximum(Node node) {
		while (node.right != null) {
			node = node.right;
		}
		return node;
	}

	protected Node getSuccessor(Node node) {
		// if there is right branch, then successor is leftmost node of that
		// subtree
		if (node.right != null) {
			return getMinimum(node.right);
		} else { // otherwise it is a lowest ancestor whose left child is also
			// ancestor of node
			Node currentNode = node;
			Node parentNode = node.parent;
			while (parentNode != null && currentNode == parentNode.right) {
				// go up until we find parent that currentNode is not in right
				// subtree.
				currentNode = parentNode;
				parentNode = parentNode.parent;
			}
			return parentNode;
		}
	}

	// -------------------------------- TREE PRINTING
	// ------------------------------------

	public void printTree() {
		printSubtree(root);
	}

	public void printSubtree(Node node) {
		if (node.right != null) {
			printTree(node.right, true, "");
		}
		printNodeValue(node);
		if (node.left != null) {
			printTree(node.left, false, "");
		}
	}

	private void printNodeValue(Node node) {
		if (node.value == null) {
			System.out.print("<null>");
		} else {
			System.out.print(node.value.toString());
		}
		System.out.println();
	}

	private void printTree(Node node, boolean isRight, String indent) {
		if (node.right != null) {
			printTree(node.right, true, indent + (isRight ? "        " : " |      "));
		}
		System.out.print(indent);
		if (isRight) {
			System.out.print(" /");
		} else {
			System.out.print(" \\");
		}
		System.out.print("----- ");
		printNodeValue(node);
		if (node.left != null) {
			printTree(node.left, false, indent + (isRight ? " |      " : "        "));
		}
	}

	public static class Node {
		public Node(Integer value, Node parent, Node left, Node right) {
			super();
			this.value = value;
			this.parent = parent;
			this.left = left;
			this.right = right;
		}

		public Integer value;
		public Node parent;
		public Node left;
		public Node right;

		public boolean isLeaf() {
			return left == null && right == null;
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + ((value == null) ? 0 : value.hashCode());
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			Node other = (Node) obj;
			if (value == null) {
				if (other.value != null)
					return false;
			} else if (!value.equals(other.value))
				return false;
			return true;
		}

	}
}
```

<br/>

<br/>

### AVL树

平衡性高度严苛，任意一个节点左子树和右子树高度差不超过1，通过各种旋转操作，实现平衡性，而且代价还不会特别高，不管是查找，增加，还是删除，都还是logN的级别；

但是调整的频率可能会很高，可能插入一个数就需要调整一次；

<br/>

代码

```java
public class AVLTree extends AbstractSelfBalancingBinarySearchTree {

    /**
     * @see trees.AbstractBinarySearchTree#insert(int)
     * 
     *      AVL tree insert method also balances tree if needed. Additional
     *      height parameter on node is used to track if one subtree is higher
     *      than other by more than one, if so AVL tree rotations is performed
     *      to regain balance of the tree.
     */
    @Override
    public Node insert(int element) {
        Node newNode = super.insert(element);
        rebalance((AVLNode)newNode);
        return newNode;
    }

    /**
     * @see trees.AbstractBinarySearchTree#delete(int)
     */
    @Override
    public Node delete(int element) {
        Node deleteNode = super.search(element);
        if (deleteNode != null) {
            Node successorNode = super.delete(deleteNode);
            if (successorNode != null) {
                // if replaced from getMinimum(deleteNode.right) then come back there and update heights
                AVLNode minimum = successorNode.right != null ? (AVLNode)getMinimum(successorNode.right) : (AVLNode)successorNode;
                recomputeHeight(minimum);
                rebalance((AVLNode)minimum);
            } else {
                recomputeHeight((AVLNode)deleteNode.parent);
                rebalance((AVLNode)deleteNode.parent);
            }
            return successorNode;
        }
        return null;
    }
    
    /**
     * @see trees.AbstractBinarySearchTree#createNode(int, trees.AbstractBinarySearchTree.Node, trees.AbstractBinarySearchTree.Node, trees.AbstractBinarySearchTree.Node)
     */
    @Override
    protected Node createNode(int value, Node parent, Node left, Node right) {
        return new AVLNode(value, parent, left, right);
    }

    /**
     * Go up from inserted node, and update height and balance informations if needed.
     * If some node balance reaches 2 or -2 that means that subtree must be rebalanced.
     * 重新调整平衡性；
     * @param node Inserted Node.
     */
    private void rebalance(AVLNode node) {
        while (node != null) {// while 循环，就证明了，会一直往上找，修改沿途的所有父节点的高度；
            
            Node parent = node.parent;
            
            int leftHeight = (node.left == null) ? -1 : ((AVLNode) node.left).height;
            int rightHeight = (node.right == null) ? -1 : ((AVLNode) node.right).height;
            int nodeBalance = rightHeight - leftHeight;
            // rebalance (-2 means left subtree outgrow, 2 means right subtree)
            if (nodeBalance == 2) {
                if (node.right.right != null) {
                    node = (AVLNode)avlRotateLeft(node);
                    break;
                } else {
                    node = (AVLNode)doubleRotateRightLeft(node);
                    break;
                }
            } else if (nodeBalance == -2) {  //左树的高度超了，
                if (node.left.left != null) {  //说明是LL型
                    node = (AVLNode)avlRotateRight(node);  //右旋操作
                    break;
                } else {
                    node = (AVLNode)doubleRotateLeftRight(node);
                    break;
                }
            } else {
                updateHeight(node);
            }
            
            node = (AVLNode)parent;
        }
    }

    /**
     * Rotates to left side.
     */
    private Node avlRotateLeft(Node node) {
        Node temp = super.rotateLeft(node);
        
        updateHeight((AVLNode)temp.left);
        updateHeight((AVLNode)temp);
        return temp;
    }

    /**
     * Rotates to right side.
     */
    private Node avlRotateRight(Node node) {
        Node temp = super.rotateRight(node);

        updateHeight((AVLNode)temp.right);
        updateHeight((AVLNode)temp);
        return temp;
    }

    /**
     * Take right child and rotate it to the right side first and then rotate
     * node to the left side.
     */
    protected Node doubleRotateRightLeft(Node node) {
        node.right = avlRotateRight(node.right);
        return avlRotateLeft(node);
    }

    /**
     * Take right child and rotate it to the right side first and then rotate
     * node to the left side.
     */
    protected Node doubleRotateLeftRight(Node node) {
        node.left = avlRotateLeft(node.left);
        return avlRotateRight(node);
    }
    
    /**
     * Recomputes height information from the node and up for all of parents. It needs to be done after delete.
     */
    private void recomputeHeight(AVLNode node) {
       while (node != null) {
          node.height = maxHeight((AVLNode)node.left, (AVLNode)node.right) + 1;
          node = (AVLNode)node.parent;
       }
    }
    
    /**
     * Returns higher height of 2 nodes. 
     */
    private int maxHeight(AVLNode node1, AVLNode node2) {
        if (node1 != null && node2 != null) {
            return node1.height > node2.height ? node1.height : node2.height;
        } else if (node1 == null) {
            return node2 != null ? node2.height : -1;
        } else if (node2 == null) {
            return node1 != null ? node1.height : -1;
        }
        return -1;
    }

    /**
     * Updates height and balance of the node.
     * 更新高度，左子树的高度和右子树的高度的最大值+1
     * @param node Node for which height and balance must be updated.
     */
    private static final void updateHeight(AVLNode node) {
        int leftHeight = (node.left == null) ? -1 : ((AVLNode) node.left).height;
        int rightHeight = (node.right == null) ? -1 : ((AVLNode) node.right).height;
        node.height = 1 + Math.max(leftHeight, rightHeight);
    }

    /**
     * Node of AVL tree has height and balance additional properties. If balance
     * equals 2 (or -2) that node needs to be re balanced. (Height is height of
     * the subtree starting with this node, and balance is difference between
     * left and right nodes heights).
     * 
     * @author Ignas Lelys
     * @created Jun 30, 2011
     * 
     */
    protected static class AVLNode extends Node {
        public int height;  // 多了一个高度属性；

        public AVLNode(int value, Node parent, Node left, Node right) {
            super(value, parent, left, right);
        }
    }
}
```

<br/>

<br/>

### 红黑树

平衡性没有那么严苛，

1. 每一个节点染上色，头节点必然黑，叶子节点必然黑；
2. 相邻的不能出现两个连续的红色节点；
3. 以同一个节点作为父节点的任何一条链，要求黑色的数量，相差不能超过1；

<br/>

这样造成的结果就是，任一节点，最长的链不会超过最短的链的两倍；

例如一个链都是黑色，这是最短的情况，最长的情况就是能插多少红色就插多少红色，但是红色又不能相邻，所以只能隔一个黑色插一个，所以最长的链不会超过最短的链的两倍；

<br/>

代码

```java
public class RedBlackTree extends AbstractSelfBalancingBinarySearchTree {

    protected enum ColorEnum {
        RED,
        BLACK
    };

    protected static final RedBlackNode nilNode = new RedBlackNode(null, null, null, null, ColorEnum.BLACK);

    /**
     * @see trees.AbstractBinarySearchTree#insert(int)
     */
    @Override
    public Node insert(int element) {
        Node newNode = super.insert(element);
        newNode.left = nilNode;
        newNode.right = nilNode;
        root.parent = nilNode;
        insertRBFixup((RedBlackNode) newNode);
        return newNode;
    }
    
    /**
     * Slightly modified delete routine for red-black tree.
     * 
     * {@inheritDoc}
     */
    @Override
    protected Node delete(Node deleteNode) {
        Node replaceNode = null; // track node that replaces removedOrMovedNode
        if (deleteNode != null && deleteNode != nilNode) {
            Node removedOrMovedNode = deleteNode; // same as deleteNode if it has only one child, and otherwise it replaces deleteNode
            ColorEnum removedOrMovedNodeColor = ((RedBlackNode)removedOrMovedNode).color;
        
            if (deleteNode.left == nilNode) {
                replaceNode = deleteNode.right;
                rbTreeTransplant(deleteNode, deleteNode.right);
            } else if (deleteNode.right == nilNode) {
                replaceNode = deleteNode.left;
                rbTreeTransplant(deleteNode, deleteNode.left);
            } else {
                removedOrMovedNode = getMinimum(deleteNode.right);
                removedOrMovedNodeColor = ((RedBlackNode)removedOrMovedNode).color;
                replaceNode = removedOrMovedNode.right;
                if (removedOrMovedNode.parent == deleteNode) {
                    replaceNode.parent = removedOrMovedNode;
                } else {
                    rbTreeTransplant(removedOrMovedNode, removedOrMovedNode.right);
                    removedOrMovedNode.right = deleteNode.right;
                    removedOrMovedNode.right.parent = removedOrMovedNode;
                }
                rbTreeTransplant(deleteNode, removedOrMovedNode);
                removedOrMovedNode.left = deleteNode.left;
                removedOrMovedNode.left.parent = removedOrMovedNode;
                ((RedBlackNode)removedOrMovedNode).color = ((RedBlackNode)deleteNode).color;
            }
            
            size--;
            if (removedOrMovedNodeColor == ColorEnum.BLACK) {
                deleteRBFixup((RedBlackNode)replaceNode);
            }
        }
        
        return replaceNode;
    }
    
    /**
     * @see trees.AbstractBinarySearchTree#createNode(int, trees.AbstractBinarySearchTree.Node, trees.AbstractBinarySearchTree.Node, trees.AbstractBinarySearchTree.Node)
     */
    @Override
    protected Node createNode(int value, Node parent, Node left, Node right) {
        return new RedBlackNode(value, parent, left, right, ColorEnum.RED);
    }
    
    /**
     * {@inheritDoc}
     */
    @Override
    protected Node getMinimum(Node node) {
        while (node.left != nilNode) {
            node = node.left;
        }
        return node;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected Node getMaximum(Node node) {
        while (node.right != nilNode) {
            node = node.right;
        }
        return node;
    }
    
    /**
     * {@inheritDoc}
     */
    @Override
    protected Node rotateLeft(Node node) {
        Node temp = node.right;
        temp.parent = node.parent;
        
        node.right = temp.left;
        if (node.right != nilNode) {
            node.right.parent = node;
        }

        temp.left = node;
        node.parent = temp;

        // temp took over node's place so now its parent should point to temp
        if (temp.parent != nilNode) {
            if (node == temp.parent.left) {
                temp.parent.left = temp;
            } else {
                temp.parent.right = temp;
            }
        } else {
            root = temp;
        }
        
        return temp;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected Node rotateRight(Node node) {
        Node temp = node.left;
        temp.parent = node.parent;

        node.left = temp.right;
        if (node.left != nilNode) {
            node.left.parent = node;
        }

        temp.right = node;
        node.parent = temp;

        // temp took over node's place so now its parent should point to temp
        if (temp.parent != nilNode) {
            if (node == temp.parent.left) {
                temp.parent.left = temp;
            } else {
                temp.parent.right = temp;
            }
        } else {
            root = temp;
        }
        
        return temp;
    }

    
    /**
     * Similar to original transplant() method in BST but uses nilNode instead of null.
     */
    private Node rbTreeTransplant(Node nodeToReplace, Node newNode) {
        if (nodeToReplace.parent == nilNode) {
            this.root = newNode;
        } else if (nodeToReplace == nodeToReplace.parent.left) {
            nodeToReplace.parent.left = newNode;
        } else {
            nodeToReplace.parent.right = newNode;
        }
        newNode.parent = nodeToReplace.parent;
        return newNode;
    }
    
    /**
     * Restores Red-Black tree properties after delete if needed.
     */
    private void deleteRBFixup(RedBlackNode x) {
        while (x != root && isBlack(x)) {
            
            if (x == x.parent.left) {
                RedBlackNode w = (RedBlackNode)x.parent.right;
                if (isRed(w)) { // case 1 - sibling is red
                    w.color = ColorEnum.BLACK;
                    ((RedBlackNode)x.parent).color = ColorEnum.RED;
                    rotateLeft(x.parent);
                    w = (RedBlackNode)x.parent.right; // converted to case 2, 3 or 4
                }
                // case 2 sibling is black and both of its children are black
                if (isBlack(w.left) && isBlack(w.right)) {
                    w.color = ColorEnum.RED;
                    x = (RedBlackNode)x.parent;
                } else if (w != nilNode) {
                    if (isBlack(w.right)) { // case 3 sibling is black and its left child is red and right child is black
                        ((RedBlackNode)w.left).color = ColorEnum.BLACK;
                        w.color = ColorEnum.RED;
                        rotateRight(w);
                        w = (RedBlackNode)x.parent.right;
                    }
                    w.color = ((RedBlackNode)x.parent).color; // case 4 sibling is black and right child is red
                    ((RedBlackNode)x.parent).color = ColorEnum.BLACK;
                    ((RedBlackNode)w.right).color = ColorEnum.BLACK;
                    rotateLeft(x.parent);
                    x = (RedBlackNode)root;
                } else {
                    x.color = ColorEnum.BLACK;
                    x = (RedBlackNode)x.parent;
                }
            } else {
                RedBlackNode w = (RedBlackNode)x.parent.left;
                if (isRed(w)) { // case 1 - sibling is red
                    w.color = ColorEnum.BLACK;
                    ((RedBlackNode)x.parent).color = ColorEnum.RED;
                    rotateRight(x.parent);
                    w = (RedBlackNode)x.parent.left; // converted to case 2, 3 or 4
                }
                // case 2 sibling is black and both of its children are black
                if (isBlack(w.left) && isBlack(w.right)) {
                    w.color = ColorEnum.RED;
                    x = (RedBlackNode)x.parent;
                } else if (w != nilNode) {
                    if (isBlack(w.left)) { // case 3 sibling is black and its right child is red and left child is black
                        ((RedBlackNode)w.right).color = ColorEnum.BLACK;
                        w.color = ColorEnum.RED;
                        rotateLeft(w);
                        w = (RedBlackNode)x.parent.left;
                    }
                    w.color = ((RedBlackNode)x.parent).color; // case 4 sibling is black and left child is red
                    ((RedBlackNode)x.parent).color = ColorEnum.BLACK;
                    ((RedBlackNode)w.left).color = ColorEnum.BLACK;
                    rotateRight(x.parent);
                    x = (RedBlackNode)root;
                } else {
                    x.color = ColorEnum.BLACK;
                    x = (RedBlackNode)x.parent;
                }
            }
            
        }
    }
    
    private boolean isBlack(Node node) {
        return node != null ? ((RedBlackNode)node).color == ColorEnum.BLACK : false;
    }
    
    private boolean isRed(Node node) {
        return node != null ? ((RedBlackNode)node).color == ColorEnum.RED : false;
    }

    /**
     * Restores Red-Black tree properties after insert if needed. Insert can
     * break only 2 properties: root is red or if node is red then children must
     * be black.
     */
    private void insertRBFixup(RedBlackNode currentNode) {
        // current node is always RED, so if its parent is red it breaks
        // Red-Black property, otherwise no fixup needed and loop can terminate
        while (currentNode.parent != root && ((RedBlackNode) currentNode.parent).color == ColorEnum.RED) {
            RedBlackNode parent = (RedBlackNode) currentNode.parent;
            RedBlackNode grandParent = (RedBlackNode) parent.parent;
            if (parent == grandParent.left) {
                RedBlackNode uncle = (RedBlackNode) grandParent.right;
                // case1 - uncle and parent are both red
                // re color both of them to black
                if (((RedBlackNode) uncle).color == ColorEnum.RED) {
                    parent.color = ColorEnum.BLACK;
                    uncle.color = ColorEnum.BLACK;
                    grandParent.color = ColorEnum.RED;
                    // grandparent was recolored to red, so in next iteration we
                    // check if it does not break Red-Black property
                    currentNode = grandParent;
                } 
                // case 2/3 uncle is black - then we perform rotations
                else {
                    if (currentNode == parent.right) { // case 2, first rotate left
                        currentNode = parent;
                        rotateLeft(currentNode);
                    }
                    // do not use parent
                    parent.color = ColorEnum.BLACK; // case 3
                    grandParent.color = ColorEnum.RED;
                    rotateRight(grandParent);
                }
            } else if (parent == grandParent.right) {
                RedBlackNode uncle = (RedBlackNode) grandParent.left;
                // case1 - uncle and parent are both red
                // re color both of them to black
                if (((RedBlackNode) uncle).color == ColorEnum.RED) {
                    parent.color = ColorEnum.BLACK;
                    uncle.color = ColorEnum.BLACK;
                    grandParent.color = ColorEnum.RED;
                    // grandparent was recolored to red, so in next iteration we
                    // check if it does not break Red-Black property
                    currentNode = grandParent;
                }
                // case 2/3 uncle is black - then we perform rotations
                else {
                    if (currentNode == parent.left) { // case 2, first rotate right
                        currentNode = parent;
                        rotateRight(currentNode);
                    }
                    // do not use parent
                    parent.color = ColorEnum.BLACK; // case 3
                    grandParent.color = ColorEnum.RED;
                    rotateLeft(grandParent);
                }
            }

        }
        // ensure root is black in case it was colored red in fixup
        ((RedBlackNode) root).color = ColorEnum.BLACK;
    }

    protected static class RedBlackNode extends Node {
        public ColorEnum color;

        public RedBlackNode(Integer value, Node parent, Node left, Node right, ColorEnum color) {
            super(value, parent, left, right);
            this.color = color;
        }
    }
}
```

<br/>

<br/>

### SB树

叔叔节点形成的整棵树的节点个数，不会比侄子节点形成的整棵树的节点个数要少；

{% asset_img picture5.jpg %}

y是z1和z2的叔叔节点，z是y1和y2的叔叔节点

<br/>

<br/>

### 总结

这些树的时间复杂度都是O(logN)，红黑树，sb树等，所做的都是常数级别的优化，让每次调整的频率没有那么大；

只是各自平衡性的标准不一样；

<br/>

<br/>

### 平衡树的基本操作：左旋和右旋

<br/>

右旋操作，又叫顺时针旋转

{% asset_img picture8.jpg %}

<br/>

左旋，又叫逆时针旋转

{% asset_img picture9.jpg %}

<br/>

AVL树，红黑树，sb树，等平衡树他们所用到的基本动作就是这两个基本动作；

 <br/>

AVL树是怎么旋转的？

如何发现不平衡的？

每一个节点记录两个信息，左树高度和右树高度，插入一个节点的时候，会往这个节点的父节点回溯，然后沿途修改每个父节点的子树高度；如下图所示，此时就会触发一个左旋操作；

{% asset_img picture10.jpg %}

删除操作发现不平衡也是同样的原理。

<br/>

调整的组合有哪几种？

四种：LL，RR，LR，RL

1. LL：左树高度超了

{% asset_img picture11.jpg %}

此时会触发一个右旋操作；

<br/>

2. RR：右树高度超了 

此时会触发一个左旋操作；

<br/>

3. LR：左树高度超了，但是情况如下，此时需要进行两步操作，先左旋左子树3，再右旋头节点5

{% asset_img picture12.jpg %}

<br/>

4. RL：和LR正好相反的情况，需要两步操作；

<br/>

### 跳表

功能和红黑树一致

查找某个key，判断某个key是否存在，找最大的key，找某个key左边距离它最近的比它大的key，右边距离它最近的比它大的key，等等，都是O(logN)的操作

底层的实现结构完全不一致；

底层的实现比较简单，所以容易进行第二次开发，完善自己需要的功能

<br/>

逻辑；

如果一个数在L层上，如果L层没到最大层，扔骰子扔出来的一个比较小的值， 就从最高层开始找，如果最高层的右边下一个值比当前值要大，往下走，如果下一个值比当前值要小，往右走，走到不能再走了，往下走，在这个过程中如果已经到了L层了，在往下走之前把属于内个值的内个层的点建上，然后往下走，依次建立出来属于新的值的所有层的点；

<br/>

图示

{% asset_img picture13.jpg %}

<br/>

{% asset_img picture14.jpg %}

<br/>

本质

第一层的数最多，层数往上数目会越来越少，这是概率决定的，不会每个数扔出来的概率都很高，高层的点的数目可能会特别少，在查询一个数或者建立一个数的层数的时候，在高层一跨，就会跨过非常多的数，所以这个结构在分布上，就是一个和输入规律没关系的事情，因为一个key，经过一个随机函数，二分之一的比率扔出0和1，只有一层的数会很多， 高层的数会越来越少，在高层跨一个的时候，会省掉从第一层开始遍历很多的工作量，而且跨的过程中，是不会回退的，只会往下或者往右走。也就是用二分之一这个概率来优化的效率；

<br/>

代码的图示

{% asset_img picture15.jpg %}

<br/>

代码

```java
public class Code_02_SkipList {

	public static class SkipListNode {  //调表的Node结构
		public Integer value;
		public ArrayList<SkipListNode> nextNodes;  // size层数，nextNodes[0]：在第0层的下一个节点

		public SkipListNode(Integer value) {
			this.value = value;
			nextNodes = new ArrayList<SkipListNode>();
		}
	}

	public static class SkipListIterator implements Iterator<Integer> {
		SkipList list;
		SkipListNode current;

		public SkipListIterator(SkipList list) {
			this.list = list;
			this.current = list.getHead();
		}

		public boolean hasNext() {
			return current.nextNodes.get(0) != null;
		}

		public Integer next() {
			current = current.nextNodes.get(0);
			return current.value;
		}
	}

	public static class SkipList {
		private SkipListNode head;  //巨小
		private int maxLevel; //最大层数，记录的是所有数据扔出来的最大层数
		private int size;  //加进来了多少个key
		private static final double PROBABILITY = 0.5;  // 以什么概率出0，以1-这个概率出1

		public SkipList() {
			size = 0;
			maxLevel = 0;
			head = new SkipListNode(null);
			head.nextNodes.add(null);
		}

		public SkipListNode getHead() {
			return head;
		}

		public void add(Integer newValue) {
			if (!contains(newValue)) {
				size++;
				int level = 1;
				while (Math.random() < PROBABILITY) {
					level++;  //扔骰子决定层数
				}
				// update max level
				if (level > maxLevel) {
					int increment = level - maxLevel;
					while (increment-- > 0) {
						this.head.nextNodes.add(null);
					}
					maxLevel = level;//head 的 maxLevel 永远记录最大层数
				}
				SkipListNode newNode = new SkipListNode(newValue);  //新的值
				SkipListNode current = findInsertionOfTopLevel(newValue, level);

				while (level > 0) {	//一层一层找， 一定会一直找到第0层，每一层找到两个点接上，

					//下面6行代码就是让前后环境接上，
					if (current.nextNodes.get(level) != null) {
						newNode.nextNodes.add(0, current.nextNodes.get(level));//每次放到0位置，下一次循环0位置的值会被怼到1位置，依次往上怼，最终的结果就是正确的
					} else {
						newNode.nextNodes.add(0, null);
					}
					current.nextNodes.set(level, newNode); //current的每一层接到新的newNode，
					level--;

					//注意这个 current 每一层可能都不一样，因为上一个current后面可能有层数更低的节点
					//这一层中最后一个小于当前数的，
					current = findNext(newValue,current,level);

				}
				newNode.nextNodes.add(0, null);
				size++;
			}
		}

		public void delete(int value) {
			//if exists
			if (contains(value)) {
				//find the node and its level
				SkipListNode deletedNode = head;
				int deletedLevels = maxLevel;
				//because exists,so must can find
				while (deletedLevels > 0) {
					if (deletedNode.nextNodes.get(deletedLevels) != null) {
						if (deletedNode.nextNodes.get(deletedLevels).value == value) {
							deletedNode = deletedNode.nextNodes.get(deletedLevels);
							break;
						} else if (deletedNode.nextNodes.get(deletedLevels).value < value) {
							deletedNode = deletedNode.nextNodes.get(deletedLevels);
						} else {
							deletedLevels--;
						}
					} else {
						deletedLevels--;
					}
				}
				//release the node and adjust the reference
				while (deletedLevels > 0) {
					SkipListNode pre = findInsertionOfTopLevel(value, deletedLevels);
					if (deletedNode.nextNodes.get(deletedLevels) != null) {
						pre.nextNodes.set(deletedLevels, deletedNode.nextNodes.get(deletedLevels));
					} else {
						pre.nextNodes.set(deletedLevels, null);
					}
					deletedLevels--;
				}

				size--;
			}
		}

		// Returns the skiplist node with greatest value <= e
		private SkipListNode find(Integer e) {
			return find(e, head, maxLevel);
		}

		// Returns the skiplist node with greatest value <= e
		// Starts at node start and level
		private SkipListNode find(Integer e, SkipListNode current, int level) {
			do {
				current = findNext(e, current, level);
			} while (level-- > 0);
			return current;
		}

		private SkipListNode findInsertionOfTopLevel(int newValue, int level) {
			int curLevel = this.maxLevel;
			SkipListNode cur = head;
			while (curLevel >= level) {
				if (cur.nextNodes.get(curLevel) != null
						&& cur.nextNodes.get(curLevel).value < newValue) {
					// go right
					cur = cur.nextNodes.get(curLevel);
				} else {
					// go down
					curLevel--;
				}
			}
			return cur;
		}


		// Returns the node at a given level with highest value less than e

		/**
		 * @param e   新的值
		 * @param current	当前的节点
		 * @param level   在第level层找，
		 *
		 */
		private SkipListNode findNext(Integer e, SkipListNode current, int level) {
			SkipListNode next = current.nextNodes.get(level); //在当前层的下一个Node
			while (next != null) {
				Integer value = next.value;
				if (lessThan(e, value)) { //当前值小于拿出来的next的值，
					break;//找到了，直接返回current
				}
				current = next; //没找到，继续往右走，
				next = current.nextNodes.get(level);
			}
			return current; //可以理解为这一层中最后一个小于当前数的；
		}

		public int size() {
			return size;
		}

		public boolean contains(int value) {
			if (this.size == 0) {
				return false;
			}
			SkipListNode cur = head;
			int curLevel = maxLevel;
			while (curLevel > 0) {
				if (cur.nextNodes.get(curLevel) != null) {
					if (cur.nextNodes.get(curLevel).value == value) {
						return true;
					} else if (cur.nextNodes.get(curLevel).value < value) {
						cur = cur.nextNodes.get(curLevel);
					} else {
						curLevel--;
					}
				} else {
					curLevel--;
				}
			}

			return false;
		}

		public Iterator<Integer> iterator() {
			return new SkipListIterator(this);
		}

		/******************************************************************************
		 * Utility Functions *
		 ******************************************************************************/

		private boolean lessThan(Integer a, Integer b) {
			return a.compareTo(b) < 0;
		}

		private boolean equalTo(Integer a, Integer b) {
			return a.compareTo(b) == 0;
		}
	}

	public static void main(String[] args) {
	}
}
```

