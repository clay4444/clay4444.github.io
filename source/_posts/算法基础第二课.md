---
title: 算法基础第二课
categories:
  - leetcode
abbrlink: 8fa23e7c
date: 2019-02-20 22:55:08
---

### 荷兰国旗问题

给定一个数组arr，和一个数num，请把小于num的数放在数组的 左边，等于num的数放在数组的中间，大于num的数放在数组的 右边。

要求额外空间复杂度O(1)，时间复杂度O(N)

<br/>

less、more和cur两个指针，less左边的代表小于num区域的数，more右边的代表大于num区域的数，cur指向当前数，过程图示如下

<br/>

{% asset_img picture1.jpg %}

<br/>

遇到小于num的，直接和小于区域的下一个数进行交换。cur直接跳一个位置，
遇到大于num的，直接和大于区域的下一个数进行交换。cur原地不动，因为不知道换过来的数字是大于还是小于num还是等于num。
遇到等于num的，直接跳下一个数。
当cur和more撞上的时候，停止。

<br/>

{% asset_img picture2.jpg %}

<br/>

根据图示，我们可以理解为小于区域推着等于区域一直往右走，判断cur的时候，和num相比，如果cur是小于等于num的，那么和小于区域的下一个数交换之后，一定是等于num的，如果没有等于区域，那么就是自己和自己交换，所以此时可以cur可以直接++，但是如果cur是大于num的，和大于区域的前一个数交换之后，换过来的数是待定区域的，我们不知道它和num的关系，所以此时cur不能直接++

<br/>

代码

```java
/**
 * 荷兰国旗问题
 * 小于num的数字放在左边，等于的放中间，大于的放在右边。
 */
public class Code_08_NetherlandsFlag {

    public static int[] partition(int[] arr, int L, int R, int num) {

        int less = L - 1;
        int more = R + 1;
        int cur = L;//指向当前数字的指针

        while (cur < more){
            if(arr[cur] < num){//说明应该在小于区域
                swap(arr,cur++,++less);   //和小于区域的下一个数字进行交换，cur也要跳下一个位置。
                //cur++ 先赋值，再自增
                //++less  先自增，再赋值
                //为什么换到小于区域之后，cur可以直接++呢？
                //因为换过来的数字肯定是等于num的呀!
                //就算是第一次换的时候，也是自己和自己换的呀！
            }else if(arr[cur] > num){
                swap(arr,cur,--more);   //和大于区域的前一个数字进行交换，
                // 这里为什么cur不要跳下一个位置呢？
                // 因为还要考察换过去的数字，是否也小于num。
                //从后面换到前面的数字可不一定是等于num的，可能还是大于num的。也可能是小于num的。
                //所以往大于区域扔过去一个数字之后，还要继续查看cur位置的数字。
            }else{
                cur++;
            }
        }
        //返回等于num的中间内一段。
        return new int[] { less + 1, more - 1 };
    }

    public static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    // for test
    public static int[] generateArray() {
        int[] arr = new int[10];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) (Math.random() * 3);
        }
        return arr;
    }

    // for test
    public static void printArray(int[] arr) {
        if (arr == null) {
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        int[] test = generateArray();

        printArray(test);
        int[] res = partition(test, 0, test.length - 1, 1);
        printArray(test);
        System.out.println(res[0]);
        System.out.println(res[1]);

    }
}
```



<br/>

### 快排

随机快排是每次只排好一个，即，使用最后一个数字，小于等于最后一个数字的放左边，大于最后一个数字的放在右边，每次只排好了一个（经典快排：找最后一个数字x作为分区标准，小于等于x的放左边，大于x的放在右边，再对左右两边进行此种方式的递归处理，递归的把两边的数据都排好序。）

<br/>

可以用荷兰国旗进行优化，小于x的放左边，等于x的放中间，大于x的放在右边，再对左右两边进行此种方式的递归处理，这样每次是排好了一批（等于最后一个数的都放在了中间区域）

<br/>

经典快排的问题：

最后一个数字划分出来的区域，很可能不是等规模的，会打偏。
例如1，2，3，4，5，6，7  ，先以7划分区域，小于7的放在左边，7放在最右边，这个过程经历了一个O(N) 的partition，对于6来说，同样如此，。。。。也就是说每搞定一个数，都要经过一个O(N) 的partition的代价，那么最终，时间复杂度就是 O(N^2)，因为 partition的时间复杂度是 O(N) 

{% asset_img picture3.jpg %}

此时 快排就退变成了一个O（N^2）的算法。换句话说，经典快排总是以最后一个数划分，此时时间复杂度就和数据本身的状况产生了关系，

<br/>

如果是最好情况，那么partition的数字，都是正正好好在中间的，那么，左右两部分的规模就变成了 （N/2），左右部分都要去做一遍，发生两次，所以是 2 T(N/2)，除了子过程之外剩下的过程就剩一个partition过程了（快排的过程除了两个子过程之外，就剩下一个partition了），所以是 O(N)

{% asset_img picture4.jpg %}

<br/>

master 公式：T(N) = 2*T(N/2) + O(N) => O(N*logN)

所以时间复杂度是O(n * logN)，是根据master公式计算出来的。

<br/>

**随机快排**

随机找一个数和最后一个数交换位置，再进行递归 的 partition 。

随机快排时间复杂度：O(n * logN)  根据期望算出来的。  是一个长期期望值

<br/>

额外空间复杂度是O（logN）

因为每次记录断点（中间相等的数据的界标），而且每次都是分成两半，记录中间的，所以是O（logN），也是根据概率得出来的。只有记录断点了，左部分完成之后，才能根据这个断点界标去继续执行右部分

<br/>

随机快排是一个在工程上非常常用的算法，因为它的代码实现非常简单，这意味着常数项非常低；

<br/>

工程上的快排是非递归的，也就是不让系统帮你压栈，而是自己压栈，递归函数写起来非常简单，但是系统准备一个递归函数代价是比较高的，系统栈会保存很多和业务无关的东西（代码行数，指针，变量域，等等），而且系统栈在超过多少层之后会出错，所以，工程上一般不会出现递归行为；

<br/>

代码

```java
public class Code_04_QuickSort {

    public static void quickSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        quickSort(arr, 0, arr.length - 1);
    }

    public static void quickSort(int[] arr, int l, int r) {

        if(r > l){
            swap(arr,l+(int)(Math.random() * (r-l+1)),r);//随机选择一个数字和最后一个数字进行交换。
            int[] partion = partion(arr,l,r,arr[r]);     // 以最后一个数字为分区标准
            quickSort(arr,l,partion[0]-1);
            quickSort(arr,partion[1]+1,r);
        }
    }

    /**
     * 荷兰国旗问题的分区问题
     * @return
     */
    private static int[] partion(int[] arr, int l, int r, int num) {

        int less = l-1;
        int more = r+1;
        int cur = l;

        while(cur < more){          //撞上了就代表结束了。
            if(arr[cur] < num){
                swap(arr,cur++,++less);
            }else if(arr[cur] > num){
                swap(arr,cur,--more);
            }else{
                cur++;
            }
        }

        return new int[]{less+1,cur-1};     //返回包含两个数字的数组，第一个数字是等于区域的左边界，第二个是右边界
    }

    public static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    // for test
    public static void comparator(int[] arr) {
        Arrays.sort(arr);
    }

    // for test
    public static int[] generateRandomArray(int maxSize, int maxValue) {
        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
        }
        return arr;
    }

    // for test
    public static int[] copyArray(int[] arr) {
        if (arr == null) {
            return null;
        }
        int[] res = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            res[i] = arr[i];
        }
        return res;
    }

    // for test
    public static boolean isEqual(int[] arr1, int[] arr2) {
        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
            return false;
        }
        if (arr1 == null && arr2 == null) {
            return true;
        }
        if (arr1.length != arr2.length) {
            return false;
        }
        for (int i = 0; i < arr1.length; i++) {
            if (arr1[i] != arr2[i]) {
                return false;
            }
        }
        return true;
    }

    // for test
    public static void printArray(int[] arr) {
        if (arr == null) {
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    // for test
    public static void main(String[] args) {
        int testTime = 500000;
        int maxSize = 100;
        int maxValue = 100;
        boolean succeed = true;
        for (int i = 0; i < testTime; i++) {
            int[] arr1 = generateRandomArray(maxSize, maxValue);
            int[] arr2 = copyArray(arr1);
            quickSort(arr1);
            comparator(arr2);
            if (!isEqual(arr1, arr2)) {
                succeed = false;
                printArray(arr1);
                printArray(arr2);
                break;
            }
        }
        System.out.println(succeed ? "Nice!" : "Fucking fucked!");

        int[] arr = generateRandomArray(maxSize, maxValue);
        printArray(arr);
        quickSort(arr);
        printArray(arr);

    }
}
```

<br/>

### 堆排序

满二叉树N个节点：层数是logN

堆就是完全二叉树：是满二叉树（每个非叶节点都有左右两个孩子），它属于完全二叉树，如果不是每个非叶节点都有左右两个孩子，那么每一层的节点都要从左往右依次补齐，只有这两种情况

<br/>

完全二叉树可以用数组表示出来，如下图所示：下标为i的节点的左子节点就是 2*i+1 ,右子节点就是2*i+2，父节点就是(i-1) / 2，数组结构，通过这样的关系对应，你是可以脑补出一颗完全二叉树的，换句话说，只是在这个数组结构中，定义了一个规则，你可以在逻辑概念上，产生与之相对应的二叉树；

{% asset_img picture5.jpg %}

<br/>

堆分为两种，大根堆和小根堆

大根堆：在这颗完全二叉树中，任何一颗子树的最大值，都是这颗子树的头部，图示

{% asset_img picture6.jpg %}

<br/>

小根堆：在这颗完全二叉树中，任何一颗子树的最小值，都是这颗子树的头部，图示

<br/>

问题：给定一个数组，如何调整成大根堆？也就是建立大根堆的过程，heapinsert

{% asset_img picture7.jpg %}

{% asset_img picture8.jpg %}

把数组中的每个数依次组成一颗完全二叉树，如果发现当前数字比他的父节点要大（通过简单的下标变换就可以周找到父节点），直接交换两个数字，后续就递归的再找它父节点的位置，依次判断，大就交换位置，小于等于父节点就停止；

<br/>

headinsert 的时间复杂度

每次插入一个新值索引为i，都要匹配log (i-1)次，所以总共N个节点，就需要匹配log1 + log2 + log3 + ...+ log(N-1) 次数，等于N，所以将一个数组构建大跟堆的过程的时间复杂度就是O(N)。也就是heapInsert的过程。

<br/>

heapify 的过程，

heapify的过程：如果大跟堆数组中的一个数字变小了，怎么还原成大跟堆。也就是往下沉的过程。

找它的左右孩子中比较大的节点，变化节点和这个节点交换位置，如果其中一个孩子没有，那么就和另外一个孩子直接交换位置，本质就是变化节点往下沉，寻找自己新的位置的过程，

{% asset_img picture9.jpg %}

{% asset_img picture10.jpg %}

<br/>

案例

一个东西源源不断的往外吐数字，要求任一时刻找到所有球的中位数

常规做法；一个容器接受所有的数字。求中位数的时候，先排序，再找中位数，时间复杂度O(N*logN)，如果求中位数的时刻很多，效率很低

{% asset_img picture11.jpg %}

<br/>

堆结构解决

构建两个堆，一个大根堆，一个小根堆，进来一个数，和大根堆堆顶的元素比较，如果小于等于大根堆堆顶的元素，就放到大根堆中，如果大于，就放在小根堆中，当某一时刻，大根堆中的元素比小根堆中的元素多两个时，就把大根堆中堆顶的元素弹出来，放在小根堆中，然后让大根堆中的最后一个值放到堆顶，然后经历一次heapify的过程，重新构建成大根堆，要保证，大根堆中的元素数，和小跟堆中的元素数，各占N/2，这样，当取中位数的时候，取大根堆堆顶的元素和小根堆堆顶的元素相加 / 2 即可，

{% asset_img picture12.jpg %}

<br/>

**优先级队列**结构，就是堆结构

**非常逆天的数据结构**，一个堆新增加一个数字，**每次加一个数只需要换logN次**，结构就变好了，举个例子，40多亿的数据，最多只需要32 次变换，堆结构就好了，堆是非常重要的；

根本原因就是它只需要调整一个完全二叉树的高度个数，也就是内一条链上的数字，

<br/>

问题：为什么大根堆中放的是较小的 N / 2，

进来数，小于等于大根堆堆顶，放在大根堆，大于大根堆堆顶，放在小根堆。调整的时候，大根堆弹出的策略是每次弹出最大的，放在小根堆，小根堆弹出的策略是每次弹出最小的，放在大根堆。

<br/>

**堆排序**

先构建成大根堆，然后把最后一个数字和堆顶交换，最大值放在了最后一个位置，然后让heapsize -1（也就是最后一个位置不动了），再进行从0开始 heapify的过程，重新调整成大根堆，再把堆顶元素放到倒数第二个位置（也就是现在堆得最后一个位置），然后让heapsize -1，再进行从0开始 heapify的过程，重新调整成大根堆……重复此过程，直到heapsize等于0；

<br/>

代码

```java
public class Code_03_HeapSort {

    public static void heapSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            heapInsert(arr, i);   // 建立大根堆
        }
        int heapSize = arr.length;//heapsize，开始时是数组长度，
        swap(arr, 0, --heapSize);//大根堆堆顶（数组最大元素）和最后一个位置的数字交换，此时最大元素的位置就排好了。堆顶的元素就是换上去的最后一个。
        while (heapSize > 0) {      //然后每次减小heapsize的大小，每次都
            heapify(arr, 0, heapSize);//heapify就是把第一个数字往下沉，重新构建大根堆的过程，但是此时要注意heapSize已经减1，因为上次最大的数字已经在最后一个位置了。
            swap(arr, 0, --heapSize);//大根堆构建完成，这个swap和上个swap的作用是一样的，都是把大根堆的最大值放到数组末尾。
        }
    }

    /**
     * index索引位置的值往下沉，重新构建大顶堆的过程。
     * heapify的过程，heapSize 就是标记当前处理的这个大根堆有几个节点
     * 0到 heapSize-1 这个区域是一个大根堆，此时index 标记的节点 变小了，此时要在 0到 heapSize-1 上重新把它变换成大根堆
     */
    private static void heapify(int[] arr, int index, int heapSize) {
        int left = (2*index) + 1;//左孩子

        while (left < heapSize){
            int largest = left + 1 < heapSize && arr[left+1] > arr[left] ? left + 1 : left;
            largest = arr[largest] > arr[index] ? largest : index;

            if(largest == index){//说明没换，说明变化的内个节点比左右孩子节点都要大；
                break;//说明已经是大顶堆了，直接退出循环即可。
            }
            //假如换了，就要继续往下沉。
            swap(arr,index,largest);//下沉
            index = largest;
            left = index * 2 + 1;//新的左孩子，每次都是用left（左孩子）去比较的，因为是往下沉的过程嘛，
        }
    }

    /**
     * 构建大根堆的过程
     * 也就是完全二叉树向上插入的过程
     */
    private static void heapInsert(int[] arr, int index) {
        while(arr[index] > arr[(index-1) / 2]){     //index(要插入的数)比它的父节点要大，就向上交换位置。
            swap(arr,index,(index-1) / 2);
            index = (index-1) / 2;
        }
    }

    public static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    // for test
    public static void comparator(int[] arr) {
        Arrays.sort(arr);
    }

    // for test
    public static int[] generateRandomArray(int maxSize, int maxValue) {
        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
        }
        return arr;
    }

    // for test
    public static int[] copyArray(int[] arr) {
        if (arr == null) {
            return null;
        }
        int[] res = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            res[i] = arr[i];
        }
        return res;
    }

    // for test
    public static boolean isEqual(int[] arr1, int[] arr2) {
        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
            return false;
        }
        if (arr1 == null && arr2 == null) {
            return true;
        }
        if (arr1.length != arr2.length) {
            return false;
        }
        for (int i = 0; i < arr1.length; i++) {
            if (arr1[i] != arr2[i]) {
                return false;
            }
        }
        return true;
    }

    // for test
    public static void printArray(int[] arr) {
        if (arr == null) {
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    // for test
    public static void main(String[] args) {
        int testTime = 500000;
        int maxSize = 100;
        int maxValue = 100;
        boolean succeed = true;
        for (int i = 0; i < testTime; i++) {
            int[] arr1 = generateRandomArray(maxSize, maxValue);
            int[] arr2 = copyArray(arr1);
            heapSort(arr1);
            comparator(arr2);
            if (!isEqual(arr1, arr2)) {
                succeed = false;
                break;
            }
        }
        System.out.println(succeed ? "Nice!" : "Fucking fucked!");

        int[] arr = generateRandomArray(maxSize, maxValue);
        printArray(arr);
        heapSort(arr);
        printArray(arr);
    }
}
```

<br/>

### 排序算法的稳定性及其汇总

#### 定义

原序列中相同的值的排列顺序在排好序的数组中的相对次序不变

<br/>

#### 意义：

希望原始信息被保留下来，不要被抹去，此时稳定性就很重要

左，31，175
幺，7，180
小明，7，280，
先按照身高排序，此时左，幺，小明，
再点按照年龄排序，此时希望结果是幺，小明，左，
要保留原始按照身高排序的结果，就需要稳定性。

<br/>

#### 总结：

N^2 的

冒泡：一直往下沉的过程，遇到相同的值就不交换了，直接让后面的值往后冒，所以可以实现成稳定的。
插入：遇到相邻的相等的值，就不往前插入了，前面的都是有序的，所以可以实现为稳定的。
选择：总是不稳定的，5，5，5，5，4，0，1，               ： 0和5交换。已经打破了稳定性

<br/>

N*logN的

归并：可以实现稳定性，只要保证merge时，p1和p2相等的时候，先拷贝左边的，拷贝到新数组里，也就是只移动p1，就可以了，3,3,4,5,6       3,5,6,7,9，
快排：不可以实现稳定性，因为partion的过程做不到稳定性，
堆排：不可以实现稳定性，堆就是完全二叉树，交换的时候不会care相等的值的，例如：4，4，4，5，5 建立大根堆的过程中第一个5就会和第二个4进行交换（因为第二个4是第一个5的父节点），仅仅是建立大根堆的过程，稳定性就破坏了。

<br/>

### 工程中的综合排序算法

<br/>

#### 数组很长

1. 如果都是基础数据类型，就会进行快排序。
   因为基础数据类型，相同的值根本无差别，不用在乎稳定性；

2. 如果是引用数据类型，例如student, people, 类型，会用归并排序。
   如果是引用数据类型，可能有多个属性，此时就会涉及到稳定性问题。

<br/>

快排并不只是快排序，而是和插入排序合并到一起了，当快排 递归的处理 左右两边的 数字区域时，当左右区域 小于60 的时候，就会选择插入排序了，相当于把两个算法结合到一起了

<br/>

#### 数组很短

会用插入排序，因为插入排序的常数项特别低， 在小于60个的情况下，插入排序的 O(n2) 缺点根本不能体现，反而会体现出常数项特别低的优点。（因为代码非常简单）

<br/>

### 桶排序、计数排序、基数排序的介绍

1. 非基于比较的排序，与被排序的样本的实际数据状况很有关系，所 以实际中并不经常使用
2. 时间复杂度O(N)，额外空间复杂度O(N) 
3. 稳定的排序

<br/>

**桶排序是概念，没有具体实现，计数排序和基数排序是它的两个体现方式**

<br/>

计数排序举例

一个数字中很多元素，都是小于60，对数组中的元素进行排序，此时构建一个61长度的数组，遍历原数组中的元素，构建一个词频表，遇到一个数就对新构建的新数组中的对应位置做++操作，最后遍历这个词频表，把对应位置的数字遍历对应的次数，即可完成对原数组的排序，此时时间复杂度是O（N），因为只需要准备一个数组，遍历一个数组，重构一个数组。

<br/>

相当于按照数据状况设计几个容器，然后把每一个数字扔到它对应的桶中，最后再按照桶的顺序，依次倒出来。

<br/>

非常有局限性，这种局限性来自数据状况本身，是我们无法控制的；

<br/>

####  补充问题

给定一个数组，求如果排序之后，相邻两数的最大差值，要求时间复杂度O(N)，且要求不能用非基于比较的排序。

<br/>

分桶：

N个数，准备N+1个桶，遍历一遍数组，最小的放在0号桶，最大的放在N号桶，然后用最大值减去最小值，划分出N+1个范围，然后把数组中的数字，放在对应范围的桶中；例如，9个数字，准备10个桶，最小值0，最大值99，划分范围：0到9的放在第0个桶，10到19放在第1个桶，20到29放在第2个桶。。。。 依次往下，比如76就放在第七号桶，

{% asset_img picture13.jpg %}

<br/>

N个数，N+1个捅，所以必有一个空捅，
分捅之后，相邻两个数可能来自同一个捅，也可能来自不同桶
空捅的目的：否定最大差值一定不来自相同桶的数，
因为空捅左边非空桶的最大值和右边非空桶的最小值相差值一定大于桶所表示的范围，
而来自一个桶内部两个相邻数产生的差值一定小于桶所表达的范围。

所以最大差值一定不是 来自相同桶内的两个数字 的差值（这就是空桶存在的意义）

{% asset_img picture14.jpg %}

<br/>

计算过程

每个桶填入数字的时候，都维持三个变量，boolean 是否有值，min   最小值，max    最大值，

填完后，遍历所有非空的桶，每次遍历到一个桶，就找他左边第一个非空桶的最大值，然后用当前这个桶的最小值和左边第一个非空桶的最大值相减，得出一个差值，每个桶都这样计算，最后的答案，一定在这些差值中间；

{% asset_img picture15.jpg %}

<br/>

问题：为什么不直接找空桶两边的两个桶，用右边桶的最小值减去左边桶的最大值？

空桶的意义是否定答案存在于单个桶内部最大值减去最小值，但是并没有排除答案来自两个相邻非空桶的最大值和最小值的差值

例子如下：

{% asset_img picture16.jpg %}

<br/>

代码：

```java
public class Code_11_MaxGap {

    public static int maxGap(int[] nums) {
        if (nums == null || nums.length < 2) {
            return 0;
        }
        int len = nums.length;
        int min = Integer.MAX_VALUE;//  min 初始化为最大值。
        int max = Integer.MIN_VALUE;//  max 初始化为最小值。

        for(int i = 0; i < nums.length; i++){   //遍历找到数组中的最大值和最小值
            max = Math.max(max,nums[i]);
            min = Math.min(min,nums[i]);
        }
        if (min == max) {//最大值和最小值相等，返回0
            return 0;
        }

        /**
         * 定义三个数组，分别代表桶的三个属性
         * hasNum：桶中是否有值
         * maxs：当前桶的最大值
         * mins：当前桶的最小值
         */
        boolean hasNum[] = new boolean[len + 1];//默认是false
        int maxs[] = new int[len + 1];//默认是0
        int mins[] = new int[len + 1];//默认是0
        int bid;//桶号
        for(int i = 0; i < len; i++){
            bid = bucket(nums[i], len, min, max);//属于哪个桶
            maxs[bid] = hasNum[bid] ? Math.max(maxs[bid],nums[i]) : nums[i];//对应的桶中存在的最大值。
            mins[bid] = hasNum[bid] ? Math.min(mins[bid],nums[i]) : nums[i];//对应的桶中存在的最小值。
            hasNum[bid] = true;//对应的桶中存入值了。
        }
        /**
         * 此时对应的数字都放到了对应的桶中，且每个桶的三个属性值也都填好了。
         */

        int lastMax = maxs[0];  //上一个非空桶的最大值。
        int res = 0;

        //开始遍历所有的桶（N+1个）查找相邻的最大值。
        //从1号桶从开始比较，0号桶不用比较。
        for(int i = 1; i <= nums.length; i++){  //因为桶的个数是N+1个，所以终止条件是 <= nums.length;
            if(hasNum[i]){//当前桶中有值
               //就和上一次非空桶的最大值相减
                res = Math.max(res,mins[i] - lastMax);  //和上一次取得的结果进行比较，取大的。
                lastMax = maxs[i];  //把lastMax置为当前桶的最大值，供下一个非空桶的最小值相减。
            }
        }

        return res;
    }

    public static int bucket(long num, long len, long min, long max) {
        return (int) ((num - min) * len / (max - min));
    }

    // for test
    public static int comparator(int[] nums) {
        if (nums == null || nums.length < 2) {
            return 0;
        }
        Arrays.sort(nums);
        int gap = Integer.MIN_VALUE;
        for (int i = 1; i < nums.length; i++) {
            gap = Math.max(nums[i] - nums[i - 1], gap);
        }
        return gap;
    }

    // for test
    public static int[] generateRandomArray(int maxSize, int maxValue) {
        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
        }
        return arr;
    }

    // for test
    public static int[] copyArray(int[] arr) {
        if (arr == null) {
            return null;
        }
        int[] res = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            res[i] = arr[i];
        }
        return res;
    }

    // for test
    public static void main(String[] args) {
        int testTime = 500000;
        int maxSize = 100;
        int maxValue = 100;
        boolean succeed = true;
        for (int i = 0; i < testTime; i++) {
            int[] arr1 = generateRandomArray(maxSize, maxValue);
            int[] arr2 = copyArray(arr1);
            if (maxGap(arr1) != comparator(arr2)) {
                succeed = false;
                break;
            }
        }
        System.out.println(succeed ? "Nice!" : "Fucking fucked!");
    }
}
```