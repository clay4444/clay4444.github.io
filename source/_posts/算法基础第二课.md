---
title: 算法基础第二课
date: 2019-02-20 22:55:08
categories:
  - leetcode
---

### 荷兰国旗问题

给定一个数组arr，和一个数num，请把小于num的数放在数组的 左边，等于num的数放在数组的中间，大于num的数放在数组的 右边。

要求额外空间复杂度O(1)，时间复杂度O(N)

<br/>

less、more和cur两个指针，less左边的代表小于num区域的数，more右边的代表大于num区域的数，cur指向当前数，过程图示如下

<br/>

{% asset_img picture1.jpg %}

<br/>

遇到小于num的，直接和小于区域的下一个数进行交换。cur直接跳一个位置，
遇到大于num的，直接和大于区域的下一个数进行交换。cur原地不动，因为不知道换过来的数字是大于还是小于num还是等于num。
遇到等于num的，直接跳下一个数。
当cur和more撞上的时候，停止。

<br/>

{% asset_img picture2.jpg %}

<br/>

根据图示，我们可以理解为小于区域推着等于区域一直往右走，判断cur的时候，和num相比，如果cur是小于等于num的，那么和小于区域的下一个数交换之后，一定是等于num的，如果没有等于区域，那么就是自己和自己交换，所以此时可以cur可以直接++，但是如果cur是大于num的，和大于区域的前一个数交换之后，换过来的数是待定区域的，我们不知道它和num的关系，所以此时cur不能直接++

<br/>

代码

```java
/**
 * 荷兰国旗问题
 * 小于num的数字放在左边，等于的放中间，大于的放在右边。
 */
public class Code_08_NetherlandsFlag {

    public static int[] partition(int[] arr, int L, int R, int num) {

        int less = L - 1;
        int more = R + 1;
        int cur = L;//指向当前数字的指针

        while (cur < more){
            if(arr[cur] < num){//说明应该在小于区域
                swap(arr,cur++,++less);   //和小于区域的下一个数字进行交换，cur也要跳下一个位置。
                //cur++ 先赋值，再自增
                //++less  先自增，再赋值
                //为什么换到小于区域之后，cur可以直接++呢？
                //因为换过来的数字肯定是等于num的呀!
                //就算是第一次换的时候，也是自己和自己换的呀！
            }else if(arr[cur] > num){
                swap(arr,cur,--more);   //和大于区域的前一个数字进行交换，
                // 这里为什么cur不要跳下一个位置呢？
                // 因为还要考察换过去的数字，是否也小于num。
                //从后面换到前面的数字可不一定是等于num的，可能还是大于num的。也可能是小于num的。
                //所以往大于区域扔过去一个数字之后，还要继续查看cur位置的数字。
            }else{
                cur++;
            }
        }
        //返回等于num的中间内一段。
        return new int[] { less + 1, more - 1 };
    }

    public static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    // for test
    public static int[] generateArray() {
        int[] arr = new int[10];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) (Math.random() * 3);
        }
        return arr;
    }

    // for test
    public static void printArray(int[] arr) {
        if (arr == null) {
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        int[] test = generateArray();

        printArray(test);
        int[] res = partition(test, 0, test.length - 1, 1);
        printArray(test);
        System.out.println(res[0]);
        System.out.println(res[1]);

    }
}
```



<br/>

### 快排

随机快排是每次只排好一个，即，使用最后一个数字，小于等于最后一个数字的放左边，大于最后一个数字的放在右边，每次只排好了一个（经典快排：找最后一个数字x作为分区标准，小于等于x的放左边，大于x的放在右边，再对左右两边进行此种方式的递归处理，递归的把两边的数据都排好序。）

<br/>

可以用荷兰国旗进行优化，小于x的放左边，等于x的放中间，大于x的放在右边，再对左右两边进行此种方式的递归处理，这样每次是排好了一批（等于最后一个数的都放在了中间区域）

<br/>

经典快排的问题：

最后一个数字划分出来的区域，很可能不是等规模的，会打偏。
例如1，2，3，4，5，6，7  ，先以7划分区域，小于7的放在左边，7放在最右边，这个过程经历了一个O(N) 的partition，对于6来说，同样如此，。。。。也就是说每搞定一个数，都要经过一个O(N) 的partition的代价，那么最终，时间复杂度就是 O(N^2)，因为 partition的时间复杂度是 O(N) 

{% asset_img picture3.jpg %}

此时 快排就退变成了一个O（N^2）的算法。换句话说，经典快排总是以最后一个数划分，此时时间复杂度就和数据本身的状况产生了关系，

<br/>

如果是最好情况，那么partition的数字，都是正正好好在中间的，那么，左右两部分的规模就变成了 （N/2），左右部分都要去做一遍，发生两次，所以是 2 T(N/2)，除了子过程之外剩下的过程就剩一个partition过程了（快排的过程除了两个子过程之外，就剩下一个partition了），所以是 O(N)

{% asset_img picture4.jpg %}

<br/>

master 公式：T(N) = 2*T(N/2) + O(N) => O(N*logN)

所以时间复杂度是O(n * logN)，是根据master公式计算出来的。

<br/>

**随机快排**

随机找一个数和最后一个数交换位置，再进行递归 的 partition 。

随机快排时间复杂度：O(n * logN)  根据期望算出来的。  是一个长期期望值

<br/>

额外空间复杂度是O（logN）

因为每次记录断点（中间相等的数据的界标），而且每次都是分成两半，记录中间的，所以是O（logN），也是根据概率得出来的。只有记录断点了，左部分完成之后，才能根据这个断点界标去继续执行右部分

<br/>

随机快排是一个在工程上非常常用的算法，因为它的代码实现非常简单，这意味着常数项非常低；

<br/>

工程上的快排是非递归的，也就是不让系统帮你压栈，而是自己压栈，递归函数写起来非常简单，但是系统准备一个递归函数代价是比较高的，系统栈会保存很多和业务无关的东西（代码行数，指针，变量域，等等），而且系统栈在超过多少层之后会出错，所以，工程上一般不会出现递归行为；

<br/>

代码

```java
public class Code_04_QuickSort {

    public static void quickSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        quickSort(arr, 0, arr.length - 1);
    }

    public static void quickSort(int[] arr, int l, int r) {

        if(r > l){
            swap(arr,l+(int)(Math.random() * (r-l+1)),r);//随机选择一个数字和最后一个数字进行交换。
            int[] partion = partion(arr,l,r,arr[r]);     // 以最后一个数字为分区标准
            quickSort(arr,l,partion[0]-1);
            quickSort(arr,partion[1]+1,r);
        }
    }

    /**
     * 荷兰国旗问题的分区问题
     * @return
     */
    private static int[] partion(int[] arr, int l, int r, int num) {

        int less = l-1;
        int more = r+1;
        int cur = l;

        while(cur < more){          //撞上了就代表结束了。
            if(arr[cur] < num){
                swap(arr,cur++,++less);
            }else if(arr[cur] > num){
                swap(arr,cur,--more);
            }else{
                cur++;
            }
        }

        return new int[]{less+1,cur-1};     //返回包含两个数字的数组，第一个数字是等于区域的左边界，第二个是右边界
    }

    public static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    // for test
    public static void comparator(int[] arr) {
        Arrays.sort(arr);
    }

    // for test
    public static int[] generateRandomArray(int maxSize, int maxValue) {
        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
        }
        return arr;
    }

    // for test
    public static int[] copyArray(int[] arr) {
        if (arr == null) {
            return null;
        }
        int[] res = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            res[i] = arr[i];
        }
        return res;
    }

    // for test
    public static boolean isEqual(int[] arr1, int[] arr2) {
        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
            return false;
        }
        if (arr1 == null && arr2 == null) {
            return true;
        }
        if (arr1.length != arr2.length) {
            return false;
        }
        for (int i = 0; i < arr1.length; i++) {
            if (arr1[i] != arr2[i]) {
                return false;
            }
        }
        return true;
    }

    // for test
    public static void printArray(int[] arr) {
        if (arr == null) {
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    // for test
    public static void main(String[] args) {
        int testTime = 500000;
        int maxSize = 100;
        int maxValue = 100;
        boolean succeed = true;
        for (int i = 0; i < testTime; i++) {
            int[] arr1 = generateRandomArray(maxSize, maxValue);
            int[] arr2 = copyArray(arr1);
            quickSort(arr1);
            comparator(arr2);
            if (!isEqual(arr1, arr2)) {
                succeed = false;
                printArray(arr1);
                printArray(arr2);
                break;
            }
        }
        System.out.println(succeed ? "Nice!" : "Fucking fucked!");

        int[] arr = generateRandomArray(maxSize, maxValue);
        printArray(arr);
        quickSort(arr);
        printArray(arr);

    }
}
```

<br/>

### 堆排序

满二叉树N个节点：层数是logN

堆就是完全二叉树：是满二叉树（每个非叶节点都有左右两个孩子），它属于完全二叉树，如果不是每个非叶节点都有左右两个孩子，那么每一层的节点都要从左往右依次补齐，只有这两种情况

<br/>

完全二叉树可以用数组表示出来，如下图所示：下标为i的节点的左子节点就是 2*i+1 ,右子节点就是2*i+2，父节点就是(i-1) / 2，数组结构，通过这样的关系对应，你是可以脑补出一颗完全二叉树的，换句话说，只是在这个数组结构中，定义了一个规则，你可以在逻辑概念上，产生与之相对应的二叉树；

{% asset_img picture5.jpg %}

<br/>

堆分为两种，大根堆和小根堆

大根堆：在这颗完全二叉树中，任何一颗子树的最大值，都是这颗子树的头部，图示

{% asset_img picture6.jpg %}

<br/>

小根堆：在这颗完全二叉树中，任何一颗子树的最小值，都是这颗子树的头部，图示

<br/>

问题：给定一个数组，如何调整成大根堆？也就是建立大根堆的过程，heapinsert

{% asset_img picture7.jpg %}

{% asset_img picture8.jpg %}

把数组中的每个数依次组成一颗完全二叉树，如果发现当前数字比他的父节点要大（通过简单的下标变换就可以周找到父节点），直接交换两个数字，后续就递归的再找它父节点的位置，依次判断，大就交换位置，小于等于父节点就停止；

<br/>

headinsert 的时间复杂度

每次插入一个新值索引为i，都要匹配log (i-1)次，所以总共N个节点，就需要匹配log1 + log2 + log3 + ...+ log(N-1) 次数，等于N，所以将一个数组构建大跟堆的过程的时间复杂度就是O(N)。也就是heapInsert的过程。

<br/>

heapify 的过程，

heapify的过程：如果大跟堆数组中的一个数字变小了，怎么还原成大跟堆。也就是往下沉的过程。

找它的左右孩子中比较大的节点，变化节点和这个节点交换位置，如果其中一个孩子没有，那么就和另外一个孩子直接交换位置，本质就是变化节点往下沉，寻找自己新的位置的过程，

{% asset_img picture9.jpg %}

{% asset_img picture10.jpg %}

<br/>

案例

一个东西源源不断的往外吐数字，要求任一时刻找到所有球的中位数

常规做法；一个容器接受所有的数字。求中位数的时候，先排序，再找中位数，时间复杂度O(N*logN)，如果求中位数的时刻很多，效率很低

{% asset_img picture11.jpg %}

<br/>

堆结构解决

构建两个堆，一个大根堆，一个小根堆，进来一个数，和大根堆堆顶的元素比较，如果小于等于大根堆堆顶的元素，就放到大根堆中，如果大于，就放在小根堆中，当某一时刻，大根堆中的元素比小根堆中的元素多两个时，就把大根堆中堆顶的元素弹出来，放在小根堆中，然后让大根堆中的最后一个值放到堆顶，然后经历一次heapify的过程，重新构建成大根堆，要保证，大根堆中的元素数，和小跟堆中的元素数，各占N/2，这样，当取中位数的时候，取大根堆堆顶的元素和小根堆堆顶的元素相加 / 2 即可，

{% asset_img picture12.jpg %}

<br/>

**优先级队列**结构，就是堆结构

**非常逆天的数据结构**，一个堆新增加一个数字，**每次加一个数只需要换logN次**，结构就变好了，举个例子，40多亿的数据，最多只需要32 次变换，堆结构就好了，堆是非常重要的；

根本原因就是它只需要调整一个完全二叉树的高度个数，也就是内一条链上的数字，

<br/>

问题：为什么大根堆中放的是较小的 N / 2，

进来数，小于等于大根堆堆顶，放在大根堆，大于大根堆堆顶，放在小根堆。调整的时候，大根堆弹出的策略是每次弹出最大的，放在小根堆，小根堆弹出的策略是每次弹出最小的，放在大根堆。

<br/>

**堆排序**

先构建成大根堆，然后把最后一个数字和堆顶交换，最大值放在了最后一个位置，然后让heapsize -1（也就是最后一个位置不动了），再进行从0开始 heapify的过程，重新调整成大根堆，再把堆顶元素放到倒数第二个位置（也就是现在堆得最后一个位置），然后让heapsize -1，再进行从0开始 heapify的过程，重新调整成大根堆……重复此过程，直到heapsize等于0；

<br/>

代码

```java
public class Code_03_HeapSort {

    public static void heapSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            heapInsert(arr, i);   // 建立大根堆
        }
        int heapSize = arr.length;//heapsize，开始时是数组长度，
        swap(arr, 0, --heapSize);//大根堆堆顶（数组最大元素）和最后一个位置的数字交换，此时最大元素的位置就排好了。堆顶的元素就是换上去的最后一个。
        while (heapSize > 0) {      //然后每次减小heapsize的大小，每次都
            heapify(arr, 0, heapSize);//heapify就是把第一个数字往下沉，重新构建大根堆的过程，但是此时要注意heapSize已经减1，因为上次最大的数字已经在最后一个位置了。
            swap(arr, 0, --heapSize);//大根堆构建完成，这个swap和上个swap的作用是一样的，都是把大根堆的最大值放到数组末尾。
        }
    }

    /**
     * index索引位置的值往下沉，重新构建大顶堆的过程。
     * heapify的过程，heapSize 就是标记当前处理的这个大根堆有几个节点
     * 0到 heapSize-1 这个区域是一个大根堆，此时index 标记的节点 变小了，此时要在 0到 heapSize-1 上重新把它变换成大根堆
     */
    private static void heapify(int[] arr, int index, int heapSize) {
        int left = (2*index) + 1;//左孩子

        while (left < heapSize){
            int largest = left + 1 < heapSize && arr[left+1] > arr[left] ? left + 1 : left;
            largest = arr[largest] > arr[index] ? largest : index;

            if(largest == index){//说明没换，说明变化的内个节点比左右孩子节点都要大；
                break;//说明已经是大顶堆了，直接退出循环即可。
            }
            //假如换了，就要继续往下沉。
            swap(arr,index,largest);//下沉
            index = largest;
            left = index * 2 + 1;//新的左孩子，每次都是用left（左孩子）去比较的，因为是往下沉的过程嘛，
        }
    }

    /**
     * 构建大根堆的过程
     * 也就是完全二叉树向上插入的过程
     */
    private static void heapInsert(int[] arr, int index) {
        while(arr[index] > arr[(index-1) / 2]){     //index(要插入的数)比它的父节点要大，就向上交换位置。
            swap(arr,index,(index-1) / 2);
            index = (index-1) / 2;
        }
    }

    public static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    // for test
    public static void comparator(int[] arr) {
        Arrays.sort(arr);
    }

    // for test
    public static int[] generateRandomArray(int maxSize, int maxValue) {
        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
        }
        return arr;
    }

    // for test
    public static int[] copyArray(int[] arr) {
        if (arr == null) {
            return null;
        }
        int[] res = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            res[i] = arr[i];
        }
        return res;
    }

    // for test
    public static boolean isEqual(int[] arr1, int[] arr2) {
        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
            return false;
        }
        if (arr1 == null && arr2 == null) {
            return true;
        }
        if (arr1.length != arr2.length) {
            return false;
        }
        for (int i = 0; i < arr1.length; i++) {
            if (arr1[i] != arr2[i]) {
                return false;
            }
        }
        return true;
    }

    // for test
    public static void printArray(int[] arr) {
        if (arr == null) {
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    // for test
    public static void main(String[] args) {
        int testTime = 500000;
        int maxSize = 100;
        int maxValue = 100;
        boolean succeed = true;
        for (int i = 0; i < testTime; i++) {
            int[] arr1 = generateRandomArray(maxSize, maxValue);
            int[] arr2 = copyArray(arr1);
            heapSort(arr1);
            comparator(arr2);
            if (!isEqual(arr1, arr2)) {
                succeed = false;
                break;
            }
        }
        System.out.println(succeed ? "Nice!" : "Fucking fucked!");

        int[] arr = generateRandomArray(maxSize, maxValue);
        printArray(arr);
        heapSort(arr);
        printArray(arr);
    }
}
```