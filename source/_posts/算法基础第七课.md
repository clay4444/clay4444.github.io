---
title: 算法基础第七课
date: 2019-02-24 19:46:22
categories:
  - leetcode
---

### trie 树、前缀树

何为前缀树？ 如何生成前缀树？

一个字符串类型的数组arr1，另一个字符串类型的数组arr2。

<br/>

{% asset_img picture1.jpg %}

<br/>

几种情况：

所有的字符串中是否有以"be"开头的，只需要按照路往下走判断即可。
但是只判断是否含有be这个单词，是查询不出来的，只含有be和还含有bef是相同的树，是完全一致的trie树

所以每个节点加一个多余数据项：有多少个字符串是以当前节点结尾的。
还想查询有多少个字符串以"bc"作为前缀，这种树查不出来。
所以每个节点再加一个数据项：每一个节点被划过了多少次。

<br/>

### 贪心：最小字典序

给定一个字符串类型的数组strs，找到一种拼接方式，使得把所 有字 符串拼起来之后形成的字符串具有最低的字典序。

<br/>

字典序：

如果两个字符串一样长，就是字面值得大小比较， 比如abc的字典序比bce的字典序要小，abc表示三位都是26进制的数，bce也是三位都是26进制的数，这两个数肯定abc小；

长度不等，abc和b比较，短的字母后面补上为0的东西，让它变成长度一样长的字符串，再比较；

abc和b00比较，abc小，因为b00的最高位的b比a要大；

<br/>

贪心：

我们自己定义一个指标，在这个指标下，要把每个样本分出优先级，优先级大的先执行，小的后执行

<br/>

代码：

```java
public class Code_05_LowestLexicography {

    /**
     * 按照自定义的比较器进行比较
     */
	public static class MyComparator implements Comparator<String> {
		@Override
		public int compare(String a, String b) {
			return (a + b).compareTo(b + a);
		}
	}

	public static String lowestString(String[] strs) {
		if (strs == null || strs.length == 0) {
			return "";
		}
		Arrays.sort(strs, new MyComparator());
		String res = "";
		for (int i = 0; i < strs.length; i++) {
			res += strs[i];
		}
		return res;
	}

	public static void main(String[] args) {
		String[] strs1 = { "jibw", "ji", "jp", "bw", "jibw" };
		System.out.println(lowestString(strs1));

		String[] strs2 = { "ba", "b" };
		System.out.println(lowestString(strs2));
	}
}
```

<br/>

### 贪心：最小代价切金条

一块金条切成两半，是需要花费和长度数值一样的铜板的。比如 长度为20的 金条，不管切成长度多大的两半，都要花费20个铜 板。一群人想整分整块金 条，怎么分最省铜板？ 例如,给定数组{10,20,30}，代表一共三个人，整块金条长度为 10+20+30=60. 金条要分成10,20,30三个部分。 如果， 先把长 度60的金条分成10和50，花费60 再把长度50的金条分成20和30， 花费50 一共花费110铜板。 但是如果， 先把长度60的金条分成30和30，花费60 再把长度30 金条分成10和20，花费30 一共花费90铜板。 输入一个数组，返回分割的最小代价。

<br/>

经典的赫夫曼编码的问题：

子节点合并在一起的代价是加起来的和

<br/>

代码：

```java
/**
 * 切金条
 * 赫夫曼编码
 * 都放到小根堆中。一次取出来相加即可。
 */
public class Code_02_Less_Money {
	public static int lessMoney(int[] arr) {
		PriorityQueue<Integer> pQ = new PriorityQueue<>();//小根堆。
		for (int i = 0; i < arr.length; i++) {
			pQ.add(arr[i]);
		}
		int sum = 0;
		int cur = 0;
		while (pQ.size() > 1) {//当小根堆中只有一个值的时候，返回。
			cur = pQ.poll() + pQ.poll();//从小跟堆中拿出两个。
			sum += cur;//相加
			pQ.add(cur);//再重新放到小跟堆中去。
		}
		return sum;//返回相加的值。
	}

	public static class MinheapComparator implements Comparator<Integer> {
		@Override
		public int compare(Integer o1, Integer o2) {
			return o1 - o2; // < 0  o1 < o2  负数
		}
	}

	public static class MaxheapComparator implements Comparator<Integer> {
		@Override
		public int compare(Integer o1, Integer o2) {
			return o2 - o1; // <   o2 < o1
		}
	}

	public static void main(String[] args) {
		// solution
		int[] arr = { 6, 7, 8, 9 };
		System.out.println(lessMoney(arr));

		int[] arrForHeap = { 3, 5, 2, 7, 0, 1, 6, 4 };

		// min heap
		PriorityQueue<Integer> minQ1 = new PriorityQueue<>();
		for (int i = 0; i < arrForHeap.length; i++) {
			minQ1.add(arrForHeap[i]);
		}
		while (!minQ1.isEmpty()) {
			System.out.print(minQ1.poll() + " ");
		}
		System.out.println();

		// min heap use Comparator
		PriorityQueue<Integer> minQ2 = new PriorityQueue<>(new MinheapComparator());
		for (int i = 0; i < arrForHeap.length; i++) {
			minQ2.add(arrForHeap[i]);
		}
		while (!minQ2.isEmpty()) {
			System.out.print(minQ2.poll() + " ");
		}
		System.out.println();

		// max heap use Comparator
		PriorityQueue<Integer> maxQ = new PriorityQueue<>(new MaxheapComparator());
		for (int i = 0; i < arrForHeap.length; i++) {
			maxQ.add(arrForHeap[i]);
		}
		while (!maxQ.isEmpty()) {
			System.out.print(maxQ.poll() + " ");
		}
	}
}
```

<br/>

### IPO，做项目问题；

一个cost 数组，一个profit 利润数组，对应下标表示对应的项目，给定一个启动资金W，做项目，但是一次只能做一个项目，k：做多做k个项目；都做完或者做不下去了，停止，求最大收益

<br/>

思路：

小根堆，根据花费把全部项目放进去，然后看初始资金，弹出头部，只要花费小于初始资金的，都弹出来，然后放进大根堆，此时 大根堆 根据收益高组成；

从大根堆弹出一个项目做，那么这个项目一个是可做的项目中收益最高的，做完之后，初始资金增加，然后再看小跟堆中哪些项目可以被解锁，然后放进大根堆。

然后再从大根堆中弹出一个项目做，做完之后初始资金再次增加，重复此步骤即可；

一直做k个或者大根堆为空了，结束；

{% asset_img picture2.jpg %}

<br/>

代码：

```java
public class Code_03_IPO {
    /**
     * Node就是项目
     */
    public static class Node {
        public int p;//收益
        public int c;//花费

        public Node(int p, int c) {
            this.p = p;
            this.c = c;
        }
    }
    /**
     * 小根堆，谁花费低，谁放在顶部
     */
    public static class MinCostComparator implements Comparator<Node> {

        @Override
        public int compare(Node o1, Node o2) {
            return o1.c - o2.c;
        }

    }

    /**
     * 大根堆，谁收益高，谁放在顶部
     */
    public static class MaxProfitComparator implements Comparator<Node> {

        @Override
        public int compare(Node o1, Node o2) {
            return o2.p - o1.p;
        }

    }

    public static int findMaximizedCapital(int k, int W, int[] Profits, int[] Capital) {
        Node[] nodes = new Node[Profits.length];
        for (int i = 0; i < Profits.length; i++) {
            nodes[i] = new Node(Profits[i], Capital[i]);
        }

        PriorityQueue<Node> minCostQ = new PriorityQueue<>(new MinCostComparator());//最小花费
        PriorityQueue<Node> maxProfitQ = new PriorityQueue<>(new MaxProfitComparator());//最大收益
        for (int i = 0; i < nodes.length; i++) {
            minCostQ.add(nodes[i]);     //把所有的项目加到小根堆中去。
        }
        for (int i = 0; i < k; i++) {//依次做项目，最多做k个。
            while (!minCostQ.isEmpty() && minCostQ.peek().c <= W) {//把所有可以被解锁的项目放到大根堆中去。
                maxProfitQ.add(minCostQ.poll());
            }
            if (maxProfitQ.isEmpty()) {//很可能做不到k个项目就得停止，因为初始资金做不了项目了，
                return W;
            }
            W += maxProfitQ.poll().p;
        }
        return W;
    }
}
```

<br/>

<br/>

### 会议室项目宣讲

一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。 给你每一个项目开始的时间和结束的时间(给你一个数组，里面是一个个具体的项目)，你来安排宣讲的日程，要求会 议室进行 的宣讲的场次最多。返回这个最多的宣讲场次。

<br/>

贪心策略

结束时间最早

<br/>

代码：

```java
/**
 * 最多可以开多少场宣讲会
 * 1. 按照最先开始的时间贪心，错误：可能一开开一天
 * 2. 按照最短时间贪心，错误：可能一个时间短的宣讲在两个时间稍长的宣讲的中间。
 *
 * 正确的贪心策略：哪个项目结束的早，然后淘汰掉因为这个项目而不能做的其他项目。
 */
public class Code_06_BestArrange {
    /**
     * 项目宣讲实体
     */
	public static class Program {
		public int start;//开始时间
		public int end;//结束时间

		public Program(int start, int end) {
			this.start = start;
			this.end = end;
		}
	}

	public static class ProgramComparator implements Comparator<Program> {

		@Override
		public int compare(Program o1, Program o2) {
			return o1.end - o2.end;
		}

	}

    /**
     * @param programs  总共的项目宣讲
     * @param cur 当前时间
     * @return
     */
	public static int bestArrange(Program[] programs, int cur) {
		Arrays.sort(programs, new ProgramComparator());
		int result = 0;
		for (int i = 0; i < programs.length; i++) {
			if (cur <= programs[i].start) {
				result++;
				cur = programs[i].end;//当前时间置为选择的项目的结束时间，也就是淘汰掉因为这个项目而不能做的其他项目
			}
		}
		return result;
	}

	public static void main(String[] args) {
	}
}
```