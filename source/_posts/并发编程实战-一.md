---
title: 并发编程实战(一)
categories:
  - 多线程编程
tags:
  - 并发编程实战读书笔记
abbrlink: eb162f92
date: 2018-02-23 18:45:05
---

## 第一章：简介

<br/>

### 要解决的问题

Java平台提供的各种并发功能与开发人员在程序中需要的并发语义并不匹配，

<br/>

在Java在语言中提供了一结底层机制，例如同步和条件等待，但在使用这些机制来实现应用级的协议与策略时必须始终保持一致。如果没有这些策略，那么在编写程序肘，虽然程序看似顺利的编译和运行， 但是却总会出现各种奇怪的问题

<br/>

### 为什么需要编写并发程序

<br/>

钱程是Java 语言中不可或缺的重要功能，它们能使复杂的异步代码变得更货单，从而极大地需化了复杂系统的开发。此外，要想充分发挥多处理器系统的强大计算能力，最简单的方式就是使用线程。随着处理器数量的
持续增长，如伺高效地使用并发正变得越来越重要。

<br/>

#### 操作系统的作用

<br/>

操作系挠的出现使得计算每次能运行多个程序，并且不同的程序都在单独的进程中运行，操作系统为各个独立执行的进程分配各种资源，包括内存，文件句柄以及安全证书等。如果需要的话，在不同的进程之间可以通过一些粗粒度的通信机制来交换数据，也括：套接字、信号处理器、共享内存、信号量以及文件等。
<br/>

资源利用率，公平性，便利性，

<br/>

这些促使进程出现的因素〈资源利用率、公平性以及便利性等）同样也促使着线程的出现。结程允许在同一个进程中同时存在多个程序控制流。线程会共享进程范围内的资源，例如内存句柄和文件句柄， 但每个线程都有各自的程序计数器（Program Count）、栈以及局部变量等。给程还提供了一种直观的分解模式来充分利用多处理器系统中的硬件并行性，而在同一个程序中的多个线程也可以被同时调度到多个CPU上运行。

<br/>

线程也被称为轻量级进程。在大多数现代操作系统中，都是以线程为基本的调度单位，而不是进程。

<br/>

由于同一个进程中的所有钱程都将其享进程的内存地址空间，因此这些线程都能访问相同的变量并在i司一个堆上分配对象，这就需要实班一种比在进程间共享数据粒度更细的数据共享主机制

<br/>

由于基本的调度单位是线程，因此如果在程序中只有一个线程，那么最多同时只能在一个处理器上运行。在双处理器系统上，单线程的程序只能使用一半的CPU 资攘，而在拥有100 个处理器的系统上，将有99% 的资源无法用。另一方面，多线程程序可以同时在多个处理器上执行。如果设计正确，多钱程程序可以通过提高处理器资源的利用率来提升系镜吞吐率。

<br/>

### 建模的简单性

<br/>

如果在程序中只包含一种类型的任务，那么比包含多种不同类塑任务的程序要更易于编写，错误更少，也更容易测试 如果为模型中每种类型的任务都分配一个专门的线程，那么可以形或一种串行执行的假象，并将程序的执行逻辑与调度机棋的细节，交替执行的操作，异步1/0 以及资源等待等问题分离开来。通过使用线嚣，可以将复杂并异步的工作流进一步分解为一组简单并且同步的工作流，每个工作流在一个单独的线程中运行，并在特定的问步位置进行交互。

<br/>

例如：Servlet 和RMI

<br/>

### 非阻塞IO

<br/>

java.nio

Linux的系统调用：select，poll

<br/>

### 安全性问题

关键点：没有充足同步的情况下，多线程调用程序会发生奇怪的结果

<br/>

### 注解

@ThreadSafe，@NotThreadSafe，

<br/>

### 竞态条件

多线程环境下 ，getValue   是否会返回唯一的值，要取决于运行时对线程中操作的交替执行方式，

<br/>

### 同步机制

<br/>

Java提供了同步机制来避免多个线程操作共享变量

<br/>

如果没有同步，那么无论是铺译器、硬件还是运行时，都可以随意安排操作的执行时间和顺序，例如对寄存器或者处理器中的变量进行缓存，而这些被缓存的变量对于其他线程来说是暂时〈甚至承久〉不可见的。虽然这些技术有利于实现更优的性能，并且通常也是值得采用的方案，但它们也为开发人员带来了负担，因为开发人员必续找出这些数据在哪些位置被多个线程共事，只有这样才能使这些优化措拖不破坏钱程安全性。

<br/>

### 活跃性问题

<br/>

安全性：永远不发生糟糕的事情

**活跃性 **：某件正确的事情最终会发生

<br/>

当某个操作无法继续执行下去时，就会发生指跃性问题。在串行程序中，活跃性问题的形式之一就是无意中造成的无限循环，从而使循环之后的代码无法得别执行。线程将带来其他一些活跃性问题。倒如，如果钱程A 在等待线程B 释放其持有的资擦，而线程B 永远都不释放该资摄，那么A 就会永久地等待下去。

<br/>

### 性能问题

<br/>

服务时间过长，响应不灵敏，吞吐率过低，资源消耗过高，或者可伸缩性较低等

<br/>

原因：上下文切换，会带来极大的开销，保存和恢复执行上下文，丢失局部性，并且CPU 时间将更多的花在线程调度而不是线程运行上。当线程共享数据时，必须使用同步机制，而这些机制往往会抑制某些编译器优化， 使得内存缓冲区中的数据无效，以及增加共享内存总线的同步流量。

<br/>

### Servlet，RMI 等框架中的线程

<br/>

Serviet 和RMI ，都会创建线程池并调用这些线程中的方法。

<br/>

当某个框架在应用程序中引入 并发性时，通常不可能将并发性仅局限于框架代码，因为框架本身会回调（ Callback）应用程序的代码，而这些代码将访问应用程序的状态。同样，对线程安全性的需求也不能局限于被调用的代码，而是要延伸到需要访问这些代码所访问的程序状态的所有代码路径。因此，线程安全性的需求将在程序中蔓延开来。

<br/>

**Timer**：Timer 类的作用是使任务在稍后的时刻执行，或者运行一次，或者周期性地运行。引入Timer 可能会使串任程序变得复杂，因为TimerTask 将在Timer 管理的钱程中拉行，而不是应用程序来管理。如果某个TimerTask 访问了应用程序中其他线程访问的数据，那么不仅仅τimerTask 需要以结程安全的方式来访问数据，其他类也必续采用线程安全的方式来访问该数据。通常，要实现这个目标，最简单的为式是确保TimerTask 访问的对象本身是线程安全的，从而就能把线程安全封装在共享对象内部。

<br/>

**Servlet **：每个Servlet 都表示一个程序逻辑组件，在高吞吐率的网站中，多个客户端可能同时请求同一个Servlet 的服务。在Servlet 规范中， Servlet 同样需要满足被多个线程同时调用，换句话说， Servlet 需要是线程安余的。

即使你可以确保每次只有一个线程访问某个Servlet，但在构建网页应用程序时仍然必须注意线程安全性。Servlet 通常会访问与其他Servlet 共享的信息，例如应用程序中的对象〈这些对象保存在ServletContext 中）或者会话中的对象〈这些对象保存在每个客户端的HttpSession中）。当一个Servlet 访问在多个Servlet 或者请求中共享的对象时，必续正确地协同对这些对象的访问，因为多个请求可能在不同的线程中同时访问这些对象。Servlet 和JSP ，以及在ServletContext 和HttpSession 等容器中保存的Servlet 过滤器和对象等，都必须是统程安全的。

<br/>

**RMI ** 远程对象必须注意两个线程安全性问题：正确地访问在多个对象中共享的状态，以及对远程对象本身状态的访问〈由于同一个对象可能会在多个线程中被问时访问〉。与Servlet 相同，RMI对象也应该做好被多个钱程同时调用的准备，并旦必须确保它们自身的线程安全性。