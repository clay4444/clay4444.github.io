---
title: 算法进阶第一课-3
date: 2019-04-05 17:28:57
categories:
  - leetcode
---

### 题目：给定一个整数，判断该数是否是回文数

<br/>

常数项：

比如插入排序遍历的时候只有一个交换操作，所以这个算法的常数项很低，但是时间复杂度O(n^2)，

但是堆排序，处理的过程中有很多的交换、判断、赋值 等操作，所以这个算法的常数项很高，但是它的时间复杂度是O(N*log(N))

所以在数组长度很小的情况下，插入排序效果更优，但是如果数组很长，常数项能起到的作用就很小了，此时就要看时间复杂度，明显 O(N*log(N)) 的时间复杂度在数组很长时，效果更优

<br/>

代码

```java
public class Code_01_Palindrome_Number {

	public static boolean isPalindrome(int n) {
		if (n < 0) {
			return false;
		}

		int help = 1;

		/*while(help <= n){
			help *= 10;  //可能会溢出，
		}
		help /= 10;*/

		while (n / help >= 10) {   //基础，只有多写才能搞定
			help *= 10;  // help 找到这个数字十进制的最高位；
		}
		while (n != 0) {
			if (n / help != n % 10) {  // n / help : 最高位，n % 10: 最低位
				return false;
			}
			n = (n % help) / 10;  //n % help：去掉最高位，再 / 10: 去掉最低位
			help /= 100;  // 	help / 100
		}
		return true;
	}
}
```

<br/>

<br/>

### 题目：数组哪两个位置的数可以加出aim来

给定一个数组arr，和一个整数aim，请返回哪两个位置的数可 以加出aim来。

例如 arr = {2, 7, 11, 15}，target = 9 

返回{0,1}，因为arr[0] + arr[1] = 2 + 7 = 9 

可以假设每个数组里只有一组答案

<br/>

方法一：哈希表

把所有数字放进哈希表中，然后再遍历一遍数字，用aim减去当前数字，去哈希表中查看有没有即可，时间复杂度O(N)，空间复杂度O(N)，

<br/>

方法二：双指针

假设数组是排好序的，开始时L指向0位置，R指向len位置，取得 arr[L]+arr[R] 的加和，如果比aim大，R向左走，如果比aim小，L向右走，最终arr[L]+arr[R] = aim时 ，此时L和R的位置就是要找的数字

所以这种方法需要先排序，所以时间复杂度O(N*log(N))，空间复杂度O(n)，

{% asset_img picture1.jpg %}

<br/>

理论上说哈希表的方式更优，但是哈希表使用哈希函数计算的时候，常数项是很大的，双指针的做法 常数项是很低的；

<br/>

代码

```java
public class Code_02_Tow_Sum {

	/**
	 * @return 返回这两个值在原数组中的index
	 */
	public int[] twoSum(int[] nums, int target) {
		int[] indices = new int[nums.length]; //index 数组，返回的时候，直接返回下标
		for (int i = 0; i < indices.length; i++) {
			indices[i] = i;
		}
		sort(nums, indices); //交换的时候不仅要交换原数组中的值，index数组的index也要交换，
		int l = 0;
		int r = nums.length - 1;
		int sum = 0;
		while (l < r) {
			sum = nums[l] + nums[r];
			if (sum > target) {
				r--;
			} else if (sum < target) {
				l++;
			} else {
				return new int[] { indices[l], indices[r] };
			}
		}
		return new int[] { -1, -1 };
	}

	public void sort(int[] nums, int[] indices) {
		for (int i = 0; i < nums.length; i++) {
			heapInsert(nums, indices, i);
		}
		for (int i = nums.length - 1; i >= 0; i--) {
			swap(nums, indices, 0, i);
			heapify(nums, indices, i);
		}
	}

	public void heapInsert(int[] nums, int[] indices, int i) {
		while (i > 0) {
			int p = (i - 1) / 2;
			if (nums[i] <= nums[p]) {
				break;
			}
			swap(nums, indices, i, p);
			i = p;
		}
	}

	public void heapify(int[] nums, int[] indices, int size) {
		int i = 0;
		int left = 1;
		int right = 2;
		int largest;
		while (left < size) {
			largest = nums[left] > nums[i] ? left : i;
			largest = right < size && nums[right] > nums[largest] ? right : largest;
			if (largest == i) {
				break;
			}
			swap(nums, indices, largest, i);
			i = largest;
			left = i * 2 + 1;
			right = i * 2 + 2;
		}
	}

	public void swap(int[] nums, int[] indices, int i, int j) {
		int tmp = nums[i];
		nums[i] = nums[j];
		nums[j] = tmp;
		tmp = indices[i];
		indices[i] = indices[j];
		indices[j] = tmp;
	}
}
```

<br/>

<br/>

### 拓展：数组中有重复的两对答案，要求重复的只打印一对

<br/>

思路：双指针

arr[L]+arr[R] <= aim 时，L向左移动，而且当 arr[L]+arr[R] = aim 然后L跳下一个位置时，如果发现下一个位置和L位置相同，直接跳过后面所有和L位置数值一样的，这样就会跳过所有重复的对答案；

{% asset_img picture2.jpg %}

<br/>

代码

```java
public static void printUniquePair(int[] arr, int k){

    if(arr == null || arr.length < 2){
        return;
    }
    int left = 0;
    int right = arr.length-1;
    while(left < right){
        if(arr[left] + arr[right] < k){
            left++;
        } else if(arr[left] + arr[right] > k){
            right++;
        }else{
            if(left == 0 || arr[left-1] != arr[left]){
                System.out.println(arr[left] + "," + arr[right]);
            }
            left++;
            right--;
        }
    }
}
```

<br/>

如果要打印所有重复的呢？

把连续相同的数字放进桶中，就变成了没有重复数字的情况，每次找到L和R的时候，看看L和R桶中各有几个数字，L桶中的数字个数乘以R桶中数字的个数就是重复的对数

<br/>

### 拓展：打印数组中三个数字加出aim的情况

<br/>

思路：

固定一个数字，然后看后面的子数组中是否能够组成aim-cur，又回到了上一题中两个数字能否加出aim的情况，

注意如果固定的数字后面一个位置的数字和当前固定的数字相同，直接跳过；

<br/>

代码

略

<br/>

### 题目：链表转换

给定一个链表list， 

如果： 

list = 1 调整之后1。 

list = 1->2 调整之后1->2 

list = 1->2->3 调整之后1->2->3 

list = 1->2->3->4 调整之后1->3->2->4 

list = 1->2->3->4->5 调整之后1->3->2->4->5 

list = 1->2->3->4->5->6 调整之后1->4->2->5->3->6 

list = 1->2->3->4->5->6->7 调整之后1->4->2->5->3->6->7 

根据上面的规律，调整一个任意长度的链表。

<br/>

找规律写代码

<br/>

方法一：转化为数组，再重新串起来

规律：左边位置i最后的位置是2*i，右边任意一个位置k最后的位置 (k-4) *2+1

把最终的数组拷贝回去；再重新串起来

{% asset_img picture3.jpg %}

<br/>

方法二：不用任何的辅助空间，只在原数组上进行操作

 快慢指针

快指针走完一遍的时候，慢指针来到中间位置，再用一个x指针，指向头结点位置，此时把x指针的节点和慢指针的节点串在一起，但是在这个过程中需要记住x指针后面的节点，因为这个节点后续要串在满指针指向节点的后面，

也就是每次取得x指针指向的节点和慢指针走向的节点，串在一起，再整体串在x指针和慢指针指向的上两个节点的后面；

<br/>

代码

```java
public class Code_03_RelocateLinkedList {

	public static class Node {
		public int value;
		public Node next;

		public Node(int value) {
			this.value = value;
		}
	}

	public static void relocate(Node head) {
		if (head == null || head.next == null) {
			return;
		}
		Node mid = head;
		Node right = head.next;
		while (right.next != null && right.next.next != null) {
			mid = mid.next;
			right = right.next.next;
		}
		right = mid.next;
		mid.next = null;
		mergeLR(head, right);
	}

	public static void mergeLR(Node left, Node right) {
		Node next = null;
		while (left.next != null) {
			next = right.next;
			right.next = left.next;
			left.next = right;
			left = right.next;
			right = next;
		}
		left.next = right;
	}

	public static void printLinkedList(Node head) {
		System.out.print("Linked List: ");
		while (head != null) {
			System.out.print(head.value + " ");
			head = head.next;
		}
		System.out.println();
	}

	public static void main(String[] args) {
		Node head = null;
		relocate(head);
		printLinkedList(head);

		head = new Node(1);
		relocate(head);
		printLinkedList(head);

		head = new Node(1);
		head.next = new Node(2);
		relocate(head);
		printLinkedList(head);

		head = new Node(1);
		head.next = new Node(2);
		head.next.next = new Node(3);
		relocate(head);
		printLinkedList(head);

		head = new Node(1);
		head.next = new Node(2);
		head.next.next = new Node(3);
		head.next.next.next = new Node(4);
		relocate(head);
		printLinkedList(head);

		head = new Node(1);
		head.next = new Node(2);
		head.next.next = new Node(3);
		head.next.next.next = new Node(4);
		head.next.next.next.next = new Node(5);
		relocate(head);
		printLinkedList(head);

		head = new Node(1);
		head.next = new Node(2);
		head.next.next = new Node(3);
		head.next.next.next = new Node(4);
		head.next.next.next.next = new Node(5);
		head.next.next.next.next.next = new Node(6);
		relocate(head);
		printLinkedList(head);

		head = new Node(1);
		head.next = new Node(2);
		head.next.next = new Node(3);
		head.next.next.next = new Node(4);
		head.next.next.next.next = new Node(5);
		head.next.next.next.next.next = new Node(6);
		head.next.next.next.next.next.next = new Node(7);
		relocate(head);
		printLinkedList(head);
	}
}
```

<br/>

<br/>

### 题目：beginWord变到endWord的所有最短转换路径

给定两个单词beginWord和endWord，还有一本词典是list类型。 

找到所有从beginWord变到endWord的最短转换路径，变动的规则是： 

1，一次只能变一个位置的字符 

2，每一个转换后的word一定要在list中 

3，初始时list中没有beginWord这个词 比如 beginWord = "hit" endWord = "cog" wordList = ["hot","dot","dog","lot","log","cog"] 

返回： 

[

["hit","hot","dot","dog","cog"],

["hit","hot","lot","log","cog"] 

] 

注意： 

1，返回值的类型为List<List<String>> 

2，如果不存在转化路径请返回空链表（不是null） 

3，所有的词一定都是相同长度的 

4，所有词都是小写的a~z 

5，在list中没有重复的词 

6，beginWord和endWord都不是空字符串或者null

<br/>

思路

先找出所有单词的所有邻居，放到一个map中，注意这个过程是时间复杂度为O(26L)的，而不是时间复杂度 为O(N^2)的，具体过程可查看代码

然后通过宽度优先遍历，找到每个节点距离beginword的距离，放到一个map中；

{% asset_img picture4.jpg %}

<br/>

最后一步，通过dfs搜索的方式，递归遍历获取所有的最小路径；

<br/>

代码

```java
public class Code_06_Word_Ladder {

	public static List<List<String>> findLadders(String beginWord,
			String endWord, List<String> wordList) {
		wordList.add(beginWord);
		HashMap<String, ArrayList<String>> nexts = getNexts(wordList);
		HashMap<String, Integer> distances = getDistances(beginWord, nexts);
		LinkedList<String> pathList = new LinkedList<>();
		List<List<String>> res = new ArrayList<>();
		getShortestPaths(beginWord, endWord, nexts, distances, pathList, res);
		return res;
	}

	/**
	 * 返回一个map，key是单词，value是这个单词的邻居；
	 * @param words  所有的单词
	 * @return
	 */
	public static HashMap<String, ArrayList<String>> getNexts(List<String> words) {
		Set<String> dict = new HashSet<>(words);
		HashMap<String, ArrayList<String>> nexts = new HashMap<>();
		for (int i = 0; i < words.size(); i++) {
			nexts.put(words.get(i), new ArrayList<>());
		}
		for (int i = 0; i < words.size(); i++) {
			nexts.put(words.get(i), getNext(words.get(i), dict));
		}
		return nexts;
	}

	/**
	 * 因为都是a-z，所以这种方式的时间复杂度是O(26L)，而如果采用遍历wordlist中所有的词，来找一个单词的邻居的方式的话，时间复杂度 O(N^2)，
	 * @param word  单词，
	 * @param dict  wordlist 中的词，去重了
	 * @return	word中跟word只有一个字符不一样的单词，全部加入 ArrayList 中
	 */
	private static ArrayList<String> getNext(String word, Set<String> dict) {
		ArrayList<String> res = new ArrayList<String>();
		char[] chs = word.toCharArray();
		for (char cur = 'a'; cur <= 'z'; cur++) {
			for (int i = 0; i < chs.length; i++) {
				if (chs[i] != cur) {
					char tmp = chs[i];
					chs[i] = cur;
					if (dict.contains(String.valueOf(chs))) {
						res.add(String.valueOf(chs));
					}
					chs[i] = tmp;
				}
			}
		}
		return res;
	}

	/**
	 * 宽度优先遍历
	 * @param begin  beginword
	 * @param nexts	 所有单词和它的邻居，是一个map
	 * @return	每个节点距离beginword的距离
	 */
	public static HashMap<String, Integer> getDistances(String begin,
			HashMap<String, ArrayList<String>> nexts) {
		//key: 单词，value：距离beginword的距离
		HashMap<String, Integer> distances = new HashMap<>();
		distances.put(begin, 0);
		Queue<String> queue = new LinkedList<String>();  //BFS 用队列
		queue.add(begin);
		HashSet<String> isVisited = new HashSet<String>(); //不要重复遍历
		isVisited.add(begin);
		while (!queue.isEmpty()) {
			String cur = queue.poll();
			for (String str : nexts.get(cur)) {
				if (!isVisited.contains(str)) {
					distances.put(str, distances.get(cur) + 1);
					queue.add(str);
					isVisited.add(str);
				}
			}
		}
		return distances;
	}

	/**
	 * 搜索的过程就是dfs的过程；
	 * 从cur出发，一路搜下去，看能不能搜到end
	 * @param cur	当前单词		可变
	 * @param end	endwork		不可变
	 * @param nexts	邻居表		不可变
	 * @param distances	距离表	不可变
	 * @param solution			可变
	 * @param res				可变
	 */
	private static void getShortestPaths(String cur, String end,
			HashMap<String, ArrayList<String>> nexts,
			HashMap<String, Integer> distances, LinkedList<String> solution,
			List<List<String>> res) {
		solution.add(cur); //所有正在走的路径
		if (end.equals(cur)) {  //搜到了，basecase
			res.add(new LinkedList<String>(solution)); //把所有走过的路径加到res中；
		} else {
			for (String next : nexts.get(cur)) { 	//cur拿到所有的邻居，
				if (distances.get(next) == distances.get(cur) + 1) { //只要cur的下一个节点，因为找的是最短路径，
					getShortestPaths(next, end, nexts, distances, solution, res);
				}
			}
		}
		solution.pollLast(); //注意每次要抹掉最后一个，因为solution只是一个实例，递归的过程中防止相互影响；
	}
}
```

<br/>

<br/>

### 题目：

给一个字符串str，代表一个整数，找到除了这个数之外，绝对值和这个数相差最小的回文数。 

例如： str = “123” 返回“121” 

注意： 假设字符串str一定能变成long类型

<br/>

思路：

先通过直接拷贝的方式返回一个回文数，然后看这个回文数和给定数字的大小关系，如果比给定数字大，就再求一个比给定数字小的回文数，如果比给定数字小，就再求一个比给定数字大的回文数，最后返回求出来的回文数和给定数字的绝对值小的回文数；

<br/>

代码

```java
public class Code_07_Find_the_Closest_Palindrome {

	public static String nearestPalindromic(String n) {
		Long num = Long.valueOf(n);
		Long raw = getRawPalindrome(n); //得到原始回文
		Long big = raw > num ? raw : getBigPalindrome(raw);		//求比这个数大的回文
		Long small = raw < num ? raw : getSmallPalindrome(raw);  //求比这个数小的回文
		return String.valueOf(big - num >= num - small ? small : big);
	}

	public static Long getRawPalindrome(String n) {
		char[] chs = n.toCharArray();
		int len = chs.length;
		for (int i = 0; i < len / 2; i++) {
			chs[len - 1 - i] = chs[i];
		}
		return Long.valueOf(String.valueOf(chs));
	}

	public static Long getBigPalindrome(Long raw) {
		char[] chs = String.valueOf(raw).toCharArray();
		char[] res = new char[chs.length + 1];
		res[0] = '0'; //最高位多准备一个0，防止999这样的数字需要升位
		for (int i = 0; i < chs.length; i++) {
			res[i + 1] = chs[i];
		}
		int size = chs.length;
		// 在 (size - 1) / 2 + 1 位置处做加法
		for (int j = (size - 1) / 2 + 1; j >= 0; j--) {
			if (++res[j] > '9') {
				res[j] = '0';
			} else {
				break;
			}
		}
		int offset = res[0] == '1' ? 1 : 0;
		size = res.length;
		for (int i = size - 1; i >= (size + offset) / 2; i--) {
			res[i] = res[size - i - offset];
		}
		return Long.valueOf(String.valueOf(res));
	}

	public static Long getSmallPalindrome(Long raw) {
		char[] chs = String.valueOf(raw).toCharArray();
		char[] res = new char[chs.length];
		int size = res.length;
		for (int i = 0; i < size; i++) {
			res[i] = chs[i];
		}
		for (int j = (size - 1) / 2; j >= 0; j--) {
			if (--res[j] < '0') {
				res[j] = '9';
			} else {
				break;
			}
		}
		if (res[0] == '0') { //最高位减为0了
			res = new char[size - 1];
			for (int i = 0; i < res.length; i++) {
				res[i] = '9';  //后面位置全是9，然后返回
			}
			return size == 1 ? 0 : Long.parseLong(String.valueOf(res)); //空字符串直接返回0即可；
		}
		//最高位不是0，直接拷贝返回即可；
		for (int k = 0; k < size / 2; k++) {
			res[size - 1 - k] = res[k];
		}
		return Long.valueOf(String.valueOf(res));
	}
}
```

