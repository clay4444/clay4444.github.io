---
title: 迭代器模式详解
categories:
  - 设计模式
abbrlink: 34ec76cc
date: 2017-12-05 19:18:37
---



###  场景理解：

假设有一个蛋糕店和一个餐厅，蛋糕店的菜单使用List实现，餐厅的菜单使用String[]  实现，现在两家店进行合并，需求：提供一个打印所有菜单的方法，

### 一般做法( 代码实现 )

菜单实体 :

~~~java
/**
 * 菜单实体
 */
public class MenuItem {

  private String name,description;
  private boolean vegatable;
  private float price;

  public MenuItem(String name, String description, boolean vegatable, float price) {
    this.name = name;
    this.description = description;
    this.vegatable = vegatable;
    this.price = price;
  }

  public String getName() {
    return name;
  }

  public String getDescription() {
    return description;
  }

  public boolean isVegatable() {
    return vegatable;
  }

  public float getPrice() {
    return price;
  }

  public void setName(String name) {
    this.name = name;
  }

  public void setDescription(String description) {
    this.description = description;
  }

  public void setVegatable(boolean vegatable) {
    this.vegatable = vegatable;
  }

  public void setPrice(float price) {
    this.price = price;
  }
}
~~~

蛋糕店:

~~~java
/**
 * 蛋糕店
 */
public class CakeHouseMenu {

  private ArrayList<MenuItem> menuItems;

  public CakeHouseMenu() {
    menuItems = new ArrayList<MenuItem>();

    addItem("KFC Cake Breakefast","boild eggs&toast&cabbage",true,3.99f);
    addItem("MDL Cake Breakefast","fried eggs&toast",false,3599f);
    addItem("staw3bery Cake Breakefast","fresh stawberry",true,3.29f);
    addItem("Regular Cake Breakefast","toast&sausage",true,2.59f);
  }

  private void addItem(String name, String descriptaion, boolean vegatable,float price){

    MenuItem menuItem = new MenuItem(name,descriptaion,vegatable,price);
    menuItems.add(menuItem);
  }

  public ArrayList<MenuItem> getMenuItems() {
    return menuItems;
  }
}
~~~

主食店:

~~~java
/**
 * 主食店
 */
public class DinerMenu {

  private final static int Max_Items = 5;
  public int numberIfItems = 0;
  private MenuItem[] menuItems;

  public DinerMenu() {

    menuItems = new MenuItem[Max_Items];
    addItem("vegatable Blt","bacon&lettuce&tomato&cabbage",true,3.58f);
    addItem("Blt","bacon&lettuce&tomato",true,3.58f);
    addItem("bean soup","bean&potato&salad",true,3.28f);
    addItem("hotdog","onions&cheese",false,3.05f);

  }

  private void addItem(String name,String description,boolean vegetable, float price){

    MenuItem menuItem = new MenuItem(name,description,vegetable,price);

    if(numberIfItems >= Max_Items){
      System.err.println("sorry, menu is full, can not add another item");
    }else{
      menuItems[numberIfItems] = menuItem;
      numberIfItems++;
    }
  }

  public MenuItem[] getMenuItems(){
    return menuItems;
  }
}
~~~

服务员：打印菜单

~~~java
public class Waitress {

  private CakeHouseMenu mCakeHouseMenu;
  private DinerMenu mDinerMenu;
  private ArrayList<MenuItem> cakeItems;
  private MenuItem[] dinerItems;

  public Waitress() {

    mCakeHouseMenu = new CakeHouseMenu();
    cakeItems = mCakeHouseMenu.getMenuItems();

    mDinerMenu = new DinerMenu();
    dinerItems = mDinerMenu.getMenuItems();
  }

  public void printMenu(){
    MenuItem menuItem;

    for (int i = 0, len = cakeItems.size(); i < len; i++){
      menuItem = cakeItems.get(i);
      System.out.println(menuItem.getName() + "***" + menuItem.getPrice() + "****" + menuItem.getDescription());
    }

    for (int i = 0, len = mDinerMenu.numberIfItems; i < len; i++){
      menuItem = dinerItems[i];
      System.out.println(menuItem.getName() + "***" + menuItem.getPrice() + "****" + menuItem.getDescription());
    }
  }
}
~~~

Main测试

~~~java
public class DeckerMain {

  public static void main(String[] args) {

    Waitress waitress = new Waitress();

    CakeHouseMenu cakeHouseMenu = new CakeHouseMenu();
    DinerMenu dinerMenu = new DinerMenu();

    waitress.printMenu();
  }
}
~~~

### 这样做的问题：

- 扩展性问题：此时又来一个新的店面，在新的功能类中，还要再for循环新的店的菜单，就变成了对修改时开放的，
- 耦合性也增加了，每个店都暴露了自己的数据结构，新的功能必须知道以前的存储结构是怎样的，在这个基础上进行开发。对可维护性也是不好的。

### 针对接口进行开发，让类之间的耦合度降低。

Iterator迭代器接口：

~~~java
public interface Iterator {

  public boolean hasNext();
  public Object next();
}
~~~

主食店此时的实现变为：

~~~java
public class DinerMenu {

  private final static int Max_Items = 5;
  public int numberIfItems = 0;
  private MenuItem[] menuItems;

  public DinerMenu() {

    menuItems = new MenuItem[Max_Items];
    addItem("vegatable Blt","bacon&lettuce&tomato&cabbage",true,3.58f);
    addItem("Blt","bacon&lettuce&tomato",true,3.58f);
    addItem("bean soup","bean&potato&salad",true,3.28f);
    addItem("hotdog","onions&cheese",false,3.05f);

  }

  private void addItem(String name,String description,boolean vegetable, float price){

    MenuItem menuItem = new MenuItem(name,description,vegetable,price);

    if(numberIfItems >= Max_Items){
      System.err.println("sorry, menu is full, can not add another item");
    }else{
      menuItems[numberIfItems] = menuItem;
      numberIfItems++;
    }
  }

  public MenuItem[] getMenuItems(){
    return menuItems;
  }

  public Iterator getIterator(){
    return new DinerIterator();
  }

  class DinerIterator implements Iterator{

    public int position;
    public DinerIterator(){
      position = 0;
    }

    public boolean hasNext() {
      if(position < numberIfItems){
        return true;
      }
      return false;
    }

    public Object next() {

      MenuItem menuItem = menuItems[position];
      position ++;
      return menuItem;
    }
  }
}

~~~

蛋糕店同理，此处省略

~~~
...
~~~

服务生的实现此时变为：

~~~java
public class Waitress {

  private ArrayList<Iterator> iterators = new ArrayList<Iterator>();

  public void addIterator(Iterator iterator) {
    iterators.add(iterator);
  }

  //打印菜单
  public void printMenu(){

    Iterator iterator;
    MenuItem menuItem;

    for(int i = 0, len = iterators.size(); i < len; i++){
      iterator = iterators.get(i);

      while(iterator.hasNext()){
        menuItem = (MenuItem) iterator.next();
        System.out.println(menuItem.getName() + "***" + menuItem.getPrice() + "***" + menuItem.getDescription());
      }
    }

  }
}
~~~

Main方法：

~~~java
public class DeckerMain {

  public static void main(String[] args) {

    Waitress waitress = new Waitress();

    CakeHouseMenu cakeHouseMenu = new CakeHouseMenu();
    DinerMenu dinerMenu = new DinerMenu();

    //waitress.addIterator(cakeHouseMenu.getIterator());
    waitress.addIterator(dinerMenu.getIterator());
    waitress.printMenu();

    waitress.printMenu();
  }
}
~~~



### 迭代器模式原理

提供一种方法顺序访问一个聚合对象中的各个对象。

### 内置迭代器

集合类



