---
title: 并发类容器
categories:
  - 多线程编程
abbrlink: 2b949ee4
date: 2017-07-20 12:07:52
---

- 由于同步类容器(Vector或者HashTable)的同步性只是单个方法间的同步性，而且是用synchronized关键字修饰的，所以同一时间只能有一个线程访问内个方法，这显然不符合高并发性，而且针对复合操作同步类容器是没有原子性的，只能通过synchronized加锁修饰这个复合操作(遍历，根据index获取元素.....)的方法，但是也就意味着同一时间只能有一个线程访问此复合方法，也就无法满足并发性

## 为了解决上述问题：并发类容器

- 并发类容器是专门针对并发设计的，使用ConcurrentHashMap来代替给予散列的传统的HashTable，而且在ConcurrentMap中，添加了一些常见复合操作的支持，以及使用了CopyOnWriteArayList代替Vector，并发的CopyOnWriteAraySet，以及Queue，ConcurrentLinkedQueue和LinkedBlockingQueue，前者是高性能的队列，后者是阻塞形式的队列，具体实现Queue还有很多，例如ArrayBlockingQueue，PriorityBlockingQueue，SynchronousQueue等

## (1). ConcurrentMap

- 有两个重要的实现，ConcurrenthashMap
- ConcurrentSkipListMap(支持并发排序功能，弥补ConcurrenthashMap)
- 总结：就是把一个大的HashTable分成很多小的HashTable，每一个小的HashTbale就是一个段，这样数据就会分散的存储在这些"段"上，如果此时t1线程访问段1上的数据进行写操作(insert,update,delete)，t2线程访问段2上的数据进行写操作(insert,update,delete)，此时t1和t2就可以并发的进行，这样设计的思想无非就是减小锁的粒度，它最多支持16个线程同时访问，也就是分成了16个段
- ConcurrenthashMap内部使用段(Segment)来表示这些不通过的部分，每个段其实就是一个小的HashTable，他们有自己的锁，只要多个修改操作发生在不同的段上，他们就可以并发进行。把一个整体分成了16段(Segment)，也就是最高支持16个线程的并发修改操作。这也是在多线程应用场景时减小锁的粒度从而降低锁竞争的一种方案，并且代码中大多共享变量使用valatile关键字声明，目的是第一时间获取修改的内容，性能非常好。

## (2). Copy-On-Write容器

- Copy-On-Write简称COW,是一种用于程序设计中的优化策略
- JDK中的COW有两种： CopyOnWriteArrayList和CopyOnWriteArraySet，COW容器非常有用，可以在非常多的并发场景中使用到
- Copy-On-Write容器即写时复制的容器，通俗的理解是当我们往一个容器中添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器中添加元素，添加完元素之后，再将原容器的索引指向新的容器，这样做的好处是我们可以对Copy-On-Write容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素，所以Copy-On-Write容器也是一种读写分离的思想，读和写不同的容器
- Copy-On-Write容器适用的是读多写少的场景，此时读的时候是不需要加锁的，如果是写多的情况的话，每次写都需要复制一份数据，还不如加锁进行同步
- 写操作是不会造成数据的一致性的，因为写操作是加锁的，

### 这两个容器的使用方法和普通的Map和List是完全一样的。