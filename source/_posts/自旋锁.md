---
title: 自旋锁
categories:
  - 多线程编程
abbrlink: 6d00129c
date: 2018-06-02 16:14:54
---

### 自旋锁

自旋锁可以使线程在没有取得锁的时候，不被挂起，而转去执行一个空循环，（即所谓的自旋，就是自己执行空循环），若在若干个空循环后，线程如果可以获得锁，则继续执行。若线程依然不能获得锁，才会被挂起。  

使用自旋锁后，线程被挂起的几率相对减少，线程执行的连贯性相对加强。因此，***对于那些锁竞争不是很激烈，锁占用时间很短的并发线程***，具有一定的积极意义，但对于锁竞争激烈，单线程锁占用很长时间的并发程序，自旋锁在自旋等待后，往往毅然无法获得对应的锁，不仅仅白白浪费了CPU时间，最终还是免不了被挂起的操作 ，反而浪费了系统的资源。

 在JDK1.6中，Java虚拟机提供-XX:+UseSpinning参数来开启自旋锁，使用-XX:PreBlockSpin参数来设置自旋锁等待的次数。 在JDK1.7开始，自旋锁的参数被取消，虚拟机不再支持由用户配置自旋锁，自旋锁总是会执行，自旋锁次数也由虚拟机自动调整。 

<br/>

#### 可能引起的问题：

1. 过多占据CPU时间：如果锁的当前持有者长时间不释放该锁，那么等待者将长时间的占据cpu时间片，导致CPU资源的浪费，因此可以设定一个时间，当锁持有者超过这个时间不释放锁时，等待者会放弃CPU时间片阻塞；
2. 死锁问题：试想一下，有一个线程连续两次试图获得自旋锁（比如在递归程序中），第一次这个线程获得了该锁，当第二次试图加锁的时候，检测到锁已被占用（其实是被自己占用），那么这时，线程会一直等待自己释放该锁，而不能继续执行，这样就引起了死锁。因此递归程序使用自旋锁应该遵循以下原则：递归程序决不能在持有自旋锁时调用它自己，也决不能在递归调用时试图获得相同的自旋锁。  
3. **aba问题**：java中自旋锁一般是利用CAS（compare And set）操作实现。 

```java
我们先来看一个多线程的运行场景：
时间点1 ：线程1查询值是否为A
时间点2 ：线程2查询值是否为A
时间点3 ：线程2比较并更新值为B
时间点4 ：线程2查询值是否为B
时间点5 ：线程2比较并更新值为A
时间点6 ：线程1比较并更新值为C
在这个线程执行场景中，2个线程交替执行。线程1在时间点6的时候依然能够正常的进行CAS操作，尽管在时间点2到时间点6期间已经发生一些意想不到的变化， 但是线程1对这些变化却一无所知，因为对线程1来说A的确还在。通常将这类现象称为ABA问题。ABA发生了，但线程不知道。又或者链表的头在变化了两次后恢复了原值，但是不代表链表就没有变化。
ABA问题隐患：
获取上面的描述ABA问题带来的隐患没有直观的认识，那我们来看下维基百科上面的形象描述：
你拿着一个装满钱的手提箱在飞机场，此时过来了一个火辣性感的美女，然后她很暖昧地挑逗着你，并趁你不注意的时候，把用一个一模一样的手提箱和你那装满钱的箱子调了个包，然后就离开了，你看到你的手提箱还在那，于是就提着手提箱去赶飞机去了。
```