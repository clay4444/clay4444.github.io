---
title: 并发编程实战(八)
categories:
  - 多线程编程
tags:
  - 并发编程实战读书笔记
abbrlink: 969c35d
date: 2018-03-01 15:49:57
---

## 第八章：线程池的使用

本章将介绍对线程池进行配置与调优的一些高级选项，并分析在使用任务执行框架时需要注意的各种危险，以及一些使用Executor 的高级示例。

<br/>

### 需要明确指定执行策略的任务

- 依赖性任务。

<br/>

只有当任务都是同类型的并且相互强立时，线程池的性能才能达到最佳。如果将运行时间较长的与运行时问较短的任务混合在一起，那么除非线程池很大，否则将可能造成 “ 阻塞 ”。如果提交的任务依赖于其他任务，那么除非线程池无限大，否则将可能造成死锁。

<br/>

如果某些任务依赖于其他的任务，那么会要求线程池足够大，从而确保他们的依赖任务不会被放入等待队列中而被拒绝。而采用线程封闭机制的任务需要串行执行。

<br/>

只要线程池中的任务需要无限期地等持一些必须由池中其他任务才能提供的资源或条件，例如某个任务等待另一个任务的返回值或执行结果，那么除非线程池足够大，否则将发生线程饥饿死锁。

```java
public class ThreadDeadLock {

    ExecutorService exec = Executors.newSingleThreadExecutor();

    public class RenderPageTask implements Callable<String>{

        @Override
        public String call() throws Exception {
            Future<String> header,footer;
            header = exec.submit(new LoadFileTask("header.html"));
            footer = exec.submit(new LoadFileTask("footer.html"));
            String page = readerBody();
            //将发生死锁，由于任务在等待子任务的结果

            return header.get() + page + footer.get();
        }
    }
}
```

<br/>

- 使用线程封闭机制的任务，任务要求其执行所在的Executor是单线程的

<br/>

- 对响应时间敏感的任务            

<br/>

有一项技术可以缓解执行时间较长任务造成的影响，即限定任务等待资源的时间，而不要毫无限制地等待。在平台类库的大多数方法中，都同时定义了限时版本和不限时版本，例如Thread.join 、BlockingQueue.put、CountDownLatch.await 以及Selector.select 等。如果等待超时，那么可以把任务标识为失败，然后终止任务或者将任务重新放回队列以便随后执行。这样，无论任务的最终结果是否成功，这种办法都能确保任务总能继楼执行下去，并将线程释放出来以执行一些能更快完成的任务。如果在线程也中总是充满了被阻塞的任务，那么也可能表
明线程池的规模过小。

<br/>

- 使用ThreadLocal的任务

<br/>



### 设置线程池大小

如果线程池过大，那么大量的线程将在相对较少的CPU 和内存资源上发生竞争，这不仅会导致更高的内存使用量，而且还可能耗尽资源。如果线程池过小，那么导致许多空闲的处理器无法执行工作。

<br/>

要想正确地设置线程池的大小，必须分析计算环境、资源预算和任务的特性。在部署的系统中有多少个CPU ？多大的内存？任务是计算密集型、IO 密集型还是二者皆可？它们是否需要像JDBC 连接这样的稀缺资源？如果需要执行不同类别的任务，并且它的之间的行为相差很大，那么应该考虑使用多个线程池，从而使每个线程池可以提据各自的工作负载来调整。

<br/>



### 线程的创建和销毁

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {}
```

​	线程池的基本大小（ Core Pool Size、最大大小（ Maximum Pool Size ）以及存活时间等因素共同负责线程的创建与销毁。基本大小也就是线程池的目标大小，即在没有任务执行时线程池的大小，并且只有在工作队列满了的情况下才会创建超过这个数量的线程。线程池的最大大小表示可同时活动的线程数量的上限。如果某个线程的空闲时间超过了存活时间，那么将被标记为可回收的，并且当线程池的当前大小超过了基本大小时，这个线程将被终止。

<br/>



### ThreadPoolExecutor  和 饱和策略

见博客：[Executor线程池应用及其源代码解析](https://clay4444.github.io/posts/8b920ef3/)



<br/>

### 线程工厂

自定义线程工厂（每当线程池需要创建一个线程时，都是通过线程工厂方法来完成的）

```java
public class MyThreadFactory implements ThreadFactory{
  private final String poolName;
  
  public MyThreadFactory(String poolName){
    this.poolName = poolName;
  }
  
  public Thread newThread(Runnable runnable){
    return new MyAppThread(runnable,poolName);
  }
}
```

<br/>

在MyAppThread 中还可以定制其他行为，如下程序所示，为线程指定名字，设置自定义UncaughtExceptio向Logger 中写入信息，维护一些统计信怠（包括有多少个线程被创建和销毁），以及在线程被创建或者终止时把调试信息写入日志。

```java
public class MyAppThread extends Thread {

  public static final String DEFAULT_NAME = "MyAppThread";
  private static volatile boolean debugLifecycle = false;
  private static final AtomicInteger created = new AtomicInteger();//创建的线程数

  private static final AtomicInteger alive = new AtomicInteger();//存活的线程数
  private static final Logger log = Logger.getAnonymousLogger();

  public MyAppThread(Runnable runnable,String name){
    super(runnable, name + "-" + created.incrementAndGet());
    setUncaughtExceptionHandler(new UncaughtExceptionHandler() {
      @Override
      public void uncaughtException(Thread t, Throwable e) {
        log.log(Level.SEVERE,"uncaught in thread" + t.getName(),e);
      }
    });
  }

  @Override
  public void run(){
    //复制debug标志以确保一致的值
    boolean debug = debugLifecycle;
    if(debug){
      log.log(Level.FINE,"Create " + getName());
    }
    try {
      alive.incrementAndGet();
      super.run();
    }finally {
      alive.decrementAndGet();
      if(debug){
        log.log(Level.FINE,"exiting " + getName());
      }
    }
  }

  public static int getThreadsCreated(){
    return created.get();
  }
  public static int getThreadsAlive(){
    return alive.get();

  }
  public static boolean getDebug(){
    return debugLifecycle;
  }
  public static void setDebug(boolean b){
    debugLifecycle = b;
  }
}
```



<br/>

### 在调用构造函数后在定制 ThreadPoolExecutor

```java
ExecutorService exec = Executors.newCachedThreadPool();
if(exec instanceof ThreadPoolExecutor){
  ((ThreadPoolExecutor)exec).setCorePoolsSize(10);
}else{
  throw new AsseertionError("Oops, bad assumption");
}
```

 <br/>

在Executors 中包含一个unconfigurableExecutorService 工厂方法，该方法是对一个现有的ExecutorService 进行包装，使其只暴漏出 ExecutorService 的方法，因此不能对它进行配置。newSingleτhreadExecutor 返回按这种方式封装的ExecutorService，而不是最初的ThreadPoolExecutor. 虽然单线程的的Executor 实际上被实现为一个只包含唯一线程的线程池，但它同样保证了不会并发地执行任务。如果在代码中增加单线程Executor 的线程池大小，那么将破坏它的执行语义。

<br/>

我们可以在自己的 Executor 中使用这项技术以防止执行策略被修改。如果将 ExecutorService 暴露给不信任的代码，又不希望对其进行修改，就可以通过 unconfigurableExecutorService 来包装它。



<br/>

### 扩展ThreadPoolExecutor

ThreadPoolExecutor 是可扩展的，它提供了几个可以在子类化中改写的方法： beforeExecute 、afterExecute 和terminated，这些方法可以用于扩展 ThreadPoolExecutor 的行为。

<br/>

无论任务是从 run 中正常返回，还是抛出一个异常而返回， afterExecute 都会被调用。（如果任务在完成后带有一个Error，那么就不会请用 afterExecute。）

如果beforeExecute 抛出一个RuntimeException，那么任务将不被执行，并且 afterExecute 也不会被调用。

<br/>

在线程池完成关闭操作时调用terminated。也就是在所有任务都已经完成并且所有工作者线程也已经关闭后。terminated 可以用来释放 Executor 在其生命周期里分配的各种资源，此外还可以执行发送通知、记录日志或者收集finalize 统计信息等操作。

```java
public class TimingThreadPool extends ThreadPoolExecutor {

  private final ThreadLocal<Long> startTime = new ThreadLocal<Long>();

  private final Logger log = Logger.getLogger("TimingThreadPool");
  private final AtomicLong numTasks = new AtomicLong();//已处理的任务数
  private final AtomicLong totalTime = new AtomicLong();//总的处理时间

  public TimingThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) {
    super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
  }

  @Override
  protected void beforeExecute(Thread t, Runnable r) {
    super.beforeExecute(t,r);
    log.fine(String.format("Thread %s: start %s",t,r));
    startTime.set(System.nanoTime());
  }

  @Override
  protected void afterExecute(Runnable r, Throwable t) {
    try {
      long endTime = System.nanoTime();
      long taskTime = endTime - startTime.get();
      numTasks.incrementAndGet();
      totalTime.addAndGet(taskTime);
      log.fine(String.format("Thread %s: end %s, time=%dns", t,r,taskTime));
    }finally {
      super.afterExecute(r,t);
    }
  }

  @Override
  protected void terminated() {
    try {
      log.info(String.format("terminated: avg time = %dns", totalTime.get() / numTasks.get()));
    }finally {
      super.terminated();
    }
  }
}
```

