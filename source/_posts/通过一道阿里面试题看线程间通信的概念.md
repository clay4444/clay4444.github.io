---
title: 通过一道阿里面试题看线程间通信的概念
categories:
  - 多线程编程
abbrlink: 9a01ed74
date: 2017-07-06 18:26:15
---

## 线程之间通信的概念

> 线程是操作系统中独立的个体，但是这些个体如果不经过特殊的处理就不能成为一个整体，线程之间的通信就成为整体的必用方式之一。当线程存在通信指挥，系统之间的交互性就会更强，在提高CPU利用率的同时还会是开发人员对线程任务在处理的过程中进行有效的把握和监督

- 使用 wait/notify 方式实现线程之间的通信。
- 注意这两个方法都是object的类的方法，换句话说，java为所有的对象都提供了这两个方法
- wait和notify必须配合synchronized关键字使用
- wait方法释放锁，notify方法不释放锁


- 题目：10个元素长的数组，线程1不断添加，当正好有5个元素时，线程2终止
- 实例代码：不用wait和notify的方式

~~~java
public class ListAdd1 {

  private volatile static List list = new ArrayList();	

  public void add(){
    list.add("bjsxt");
  }
  public int size(){
    return list.size();
  }

  public static void main(String[] args) {

    final ListAdd1 list1 = new ListAdd1();

    Thread t1 = new Thread(new Runnable() {
      @Override
      public void run() {
        try {
          for(int i = 0; i <10; i++){
            list1.add();
            System.out.println("当前线程：" + Thread.currentThread().getName() + "添加了一个元素..");
            Thread.sleep(500);
          }	
        } catch (InterruptedException e) {
          e.printStackTrace();
        }
      }
    }, "t1");

    Thread t2 = new Thread(new Runnable() {
      @Override
      public void run() {
        while(true){
          if(list1.size() == 5){
            System.out.println("当前线程收到通知：" + Thread.currentThread().getName() + " list size = 5 线程停止..");
            throw new RuntimeException();
          }
        }
      }
    }, "t2");		

    t1.start();
    t2.start();
  }
}
~~~

<br/>

- 实例代码：使用nofify的方式
- 分析：线程2一定要先执行，否则线程1先执行线程2就不会先wait，即使调用了notify方法也不会释放锁，注意这里没有涉及抢夺CPU执行权的问题，因为线程1和线程2根本没有共同执行的代码，所以一定是线程1先执行完毕再执行线程2，此时list中的元素就是10个了，线程2就会处于一直wait的状态。所以一定要先让线程2执行，先让它wait

~~~java
public class TestListAdd2 {

  private static List list1 = new ArrayList();

  private void add(){
    list1.add("LS");
  }

  public static void main(String[] args) {

    final Object lock = new Object();

    final TestListAdd2 test = new TestListAdd2();

    Thread t1 = new Thread(new Runnable() {

      @Override
      public void run() {
        synchronized(lock){
          for(int i = 0; i < 10; i++){
            test.add();
            System.out.println("当前线程  " + Thread.currentThread().getName() + "添加一个元素");
            try {
              Thread.sleep(500);
            } catch (InterruptedException e) {
              e.printStackTrace();
            }
            if(list1.size() == 5){
              lock.notify();            
              System.out.println("已经通知线程2");
            }
          }
        }
      }
    });

    Thread t2 = new Thread(new Runnable() {

      @Override
      public void run() {
        synchronized(lock){
          if(list1.size() != 5){
            try {
              lock.wait();
            } catch (InterruptedException e) {
              e.printStackTrace();
            }
          }
          System.out.println("线程2已经终止");
          throw new RuntimeException();
        }
      }
    });

    t2.start();
    t1.start();
  }
}
~~~

- 上述程序的弊端：不能做到实时性，即必须等到线程1都执行完毕，线程2才收到通知和运行，我们的目的是要实现实时性

<br/>

- 实例代码
- 分析：使用 java.util.concurrent包下的CountDownLatch 可以看成wait和notify的升级版，可以做到实时性，又不影响线程1的继续执行

~~~~java
public class ListAdd2 {
  private volatile static List list = new ArrayList();	

  public void add(){
    list.add("bjsxt");
  }
  public int size(){
    return list.size();
  }

  public static void main(String[] args) {

    final ListAdd2 list2 = new ListAdd2();

    // 1 实例化出来一个 lock
    // 当使用wait 和 notify 的时候 ， 一定要配合着synchronized关键字去使用
    //final Object lock = new Object();

    final CountDownLatch countDownLatch = new CountDownLatch(1);

    Thread t1 = new Thread(new Runnable() {
      @Override
      public void run() {
        try {
          //synchronized (lock) {
          for(int i = 0; i <10; i++){
            list2.add();
            System.out.println("当前线程：" + Thread.currentThread().getName() + "添加了一个元素..");
            Thread.sleep(500);
            if(list2.size() == 5){
              System.out.println("已经发出通知..");
              countDownLatch.countDown();
              //lock.notify();
            }
          }						
          //}
        } catch (InterruptedException e) {
          e.printStackTrace();
        }

      }
    }, "t1");

    Thread t2 = new Thread(new Runnable() {
      @Override
      public void run() {
        //synchronized (lock) {
        if(list2.size() != 5){
          try {
            //System.out.println("t2进入...");
            //lock.wait();
            countDownLatch.await();
          } catch (InterruptedException e) {
            e.printStackTrace();
          }
        }
        System.out.println("当前线程：" + Thread.currentThread().getName() + "收到通知线程停止..");
        throw new RuntimeException();
        //}
      }
    }, "t2");	

    t2.start();
    t1.start();
  }
}
~~~~

