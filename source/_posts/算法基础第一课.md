---
title: 算法基础第一课
date: 2019-02-17 21:33:50
categories:
- leetcode
---

### 时间复杂度

常数时间的操作：一个操作如果和数据量没有关系，每次都是 固定时间内完成的操作，叫做常数操作。

<br/>

时间复杂度为一个算法流程中，常数操作数量的指标。常用O （读作big O）来表示。具体来说，在常数操作数量的表达式中， 只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分 如果记为f(N)，那么时间复杂度为O(f(N))。

<br/>

评价一个算法流程的好坏，先看时间复杂度的指标，然后再分 析不同数据样本下的实际运行时间，也就是常数项时间。

<br/>

#### 一个简单的理解时间复杂度的例子

一个有序数组A，另一个无序数组B，请打印B中的所有不在A中的数，A数 组长度为N，B数组长度为M。

<br/>

算法流程1：对于数组B中的每一个数，都在A中通过遍历的方式找一下；

时间复杂度 O(N*M)

<br/>

算法流程2：对于数组B中的每一个数，都在A中通过二分的方式找一下；

时间复杂度 O(logN*M)

<br/>

算法流程3：先把数组B排序，然后用类似外排的方式打印所有在A中出现 的数；

时间复杂度 O(logM*M) + O(N+M)；O(logM*M)  是对B数组进行排序，O(N+M)是外排的过程

{% asset_img picture1.png %}

<br/>

a指针指向数组A，b指针指向数组B，a小于b时，a移动，b等于a时，说明出现了，b不打印，直接移动，b小于a时，说明a之前没有出现过b指的数，b打印并移动。

<br/>

### 对数器的概念和使用

1. 有一个你想要测的方法a， 
2. 实现一个绝对正确但是复杂度不好的方法b， 
3. 实现一个随机样本产生器 ，
4. 实现比对的方法 
5. 把方法a和方法b比对很多次来验证方法a是否正确。 
6. 如果有一个样本使得比对出错，打印样本分析是哪个方法出 错 
7. 当样本数量很多时比对测试依然正确，可以确定方法a已经 正确。

<br/>

如果绝对正确的方法是错的，那么同样是可以得到结果的，我们可以设置随机发生器小一点，打印找到不同的数据，肉眼观察出正确结果，来反复迭代修改绝对正确的方法，使其最终正确。

<br/>

### 冒泡排序

时间复杂度O(N^2)，额外空间复杂度O(1)

<br/>

第一个循环end--，决定每次循环把最大的数放在哪个位置；

第二个循环从0到end，前面的数比后面的数大，就往后移动，每次都把最大的数移动到end - 1 的位置

```java
public class Code_00_BubbleSort {

    public static void bubbleSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }

        for(int end = arr.length-1; end > 0; end --){   //每次外循环把最大的数放在末尾；

            for (int j = 0; j < end; j++){   //
                if(arr[j] > arr[j+1]){   // 0 位置 > 1位置，交换，1位置 > 2位置，交换 ....
                    swap(arr,j,j+1);
                }
            }
        }
    }

    public static void swap(int[] arr, int i, int j) {
        arr[i] = arr[i] ^ arr[j];
        arr[j] = arr[i] ^ arr[j];
        arr[i] = arr[i] ^ arr[j];
    }

    // for test
    // 准备一个绝对正确的算法；好实现，但时间复杂度不好，
    public static void comparator(int[] arr) {
        Arrays.sort(arr);
    }

    // for test
    // 产生随机样本（数组）
    public static int[] generateRandomArray(int maxSize, int maxValue) {
        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
        }
        return arr;
    }

    // for test
    public static int[] copyArray(int[] arr) {
        if (arr == null) {
            return null;
        }
        int[] res = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            res[i] = arr[i];
        }
        return res;
    }

    // for test
    public static boolean isEqual(int[] arr1, int[] arr2) {
        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
            return false;
        }
        if (arr1 == null && arr2 == null) {
            return true;
        }
        if (arr1.length != arr2.length) {
            return false;
        }
        for (int i = 0; i < arr1.length; i++) {
            if (arr1[i] != arr2[i]) {
                return false;
            }
        }
        return true;
    }

    // for test
    public static void printArray(int[] arr) {
        if (arr == null) {
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    // for test
    public static void main(String[] args) {
        int testTime = 500000;
        int maxSize = 100;
        int maxValue = 100;
        boolean succeed = true;
        for (int i = 0; i < testTime; i++) {
            int[] arr1 = generateRandomArray(maxSize, maxValue);
            int[] arr2 = copyArray(arr1);
            bubbleSort(arr1);
            comparator(arr2);
            if (!isEqual(arr1, arr2)) {
                succeed = false;
                break;
            }
        }
        System.out.println(succeed ? "Nice!" : "Fucking fucked!");

        int[] arr = generateRandomArray(maxSize, maxValue);
        printArray(arr);
        bubbleSort(arr);
        printArray(arr);
    }
}
```

<br/>

### 选择排序

时间复杂度O(N^2)，额外空间复杂度O(1)

o到n-1上最小数和0位置上的交换
1到n-1上最小数和1位置上的交换

<br/>

```java
/**
 * 选择排序
 */
public class Code_01_InsertionSort {

    public static void insertionSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }

        for(int i = 0; i < arr.length; i++){

            // 从i位置开始，找到最小的数的下标，赋给 minIndex。
            int minIndex = i;
            for(int j = i+1; j < arr.length; j++){
                if(arr[j] < arr[minIndex]){  // 如果后面的数字发现了更小的，就对minIndex 重新赋值；
                    swap(arr,j,minIndex);
                }
            }
        }
    }

    public static void swap(int[] arr, int i, int j) {
        arr[i] = arr[i] ^ arr[j];
        arr[j] = arr[i] ^ arr[j];
        arr[i] = arr[i] ^ arr[j];
    }

    // for test
    public static void comparator(int[] arr) {
        Arrays.sort(arr);
    }

    // for test
    public static int[] generateRandomArray(int maxSize, int maxValue) {
        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
        }
        return arr;
    }

    // for test
    public static int[] copyArray(int[] arr) {
        if (arr == null) {
            return null;
        }
        int[] res = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            res[i] = arr[i];
        }
        return res;
    }

    // for test
    public static boolean isEqual(int[] arr1, int[] arr2) {
        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
            return false;
        }
        if (arr1 == null && arr2 == null) {
            return true;
        }
        if (arr1.length != arr2.length) {
            return false;
        }
        for (int i = 0; i < arr1.length; i++) {
            if (arr1[i] != arr2[i]) {
                return false;
            }
        }
        return true;
    }

    // for test
    public static void printArray(int[] arr) {
        if (arr == null) {
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    // for test
    public static void main(String[] args) {
        int testTime = 500000;
        int maxSize = 100;
        int maxValue = 100;
        boolean succeed = true;
        for (int i = 0; i < testTime; i++) {
            int[] arr1 = generateRandomArray(maxSize, maxValue);
            int[] arr2 = copyArray(arr1);
            insertionSort(arr1);
            comparator(arr2);
            if (!isEqual(arr1, arr2)) {
                succeed = false;
                break;
            }
        }
        System.out.println(succeed ? "Nice!" : "Fucking fucked!");

        int[] arr = generateRandomArray(maxSize, maxValue);
        printArray(arr);
        insertionSort(arr);
        printArray(arr);
    }
}
```

<br/>

<br/>

### 插入排序

复杂度和数据状况有关，如果是排好序，那么是O(n)，因为不用再进行交换了，如果是倒序，那么是O（n^2），因为每个数都要交换到底

扑克牌插牌，拿到一张牌，依次和前面拿的牌比较，找到位置

第一个for循环就是前面的都有序了，i位置应该放哪里
第二个for循环就是如果真的发生交换了，要往前看，能不能再交换，

<br/>

```java
/**
 * 插入排序
 */
public class Code_02_SelectionSort {

    public static void selectionSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }

        for(int i = 1; i < arr.length; i++){//当前i位置上的数要往之前的有序区里面插入了，0到i-1是有序的，所以i就是当前要考察的数
            for(int j = i-1; j >= 0 && arr[j] > arr[j+1]; j--){//j+1不就是i吗？，每一次交换完了，还要去看还能不能再往前插入，所以j--
                swap(arr,j,j+1);
            }
        }
    }

    public static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    // for test
    public static void comparator(int[] arr) {
        Arrays.sort(arr);
    }

    // for test
    public static int[] generateRandomArray(int maxSize, int maxValue) {
        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
        }
        return arr;
    }

    // for test
    public static int[] copyArray(int[] arr) {
        if (arr == null) {
            return null;
        }
        int[] res = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            res[i] = arr[i];
        }
        return res;
    }

    // for test
    public static boolean isEqual(int[] arr1, int[] arr2) {
        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
            return false;
        }
        if (arr1 == null && arr2 == null) {
            return true;
        }
        if (arr1.length != arr2.length) {
            return false;
        }
        for (int i = 0; i < arr1.length; i++) {
            if (arr1[i] != arr2[i]) {
                return false;
            }
        }
        return true;
    }

    // for test
    public static void printArray(int[] arr) {
        if (arr == null) {
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    // for test
    public static void main(String[] args) {
        int testTime = 500000;
        int maxSize = 100;
        int maxValue = 100;
        boolean succeed = true;
        for (int i = 0; i < testTime; i++) {
            int[] arr1 = generateRandomArray(maxSize, maxValue);
            int[] arr2 = copyArray(arr1);
            selectionSort(arr1);
            comparator(arr2);
            if (!isEqual(arr1, arr2)) {
                succeed = false;
                printArray(arr1);
                printArray(arr2);
                break;
            }
        }
        System.out.println(succeed ? "Nice!" : "Fucking fucked!");

        int[] arr = generateRandomArray(maxSize, maxValue);
        printArray(arr);
        selectionSort(arr);
        printArray(arr);
    }
}
```

<br/>

<br/>

### 剖析递归行为和递归行为时间复杂度的估算

<br/>

递归就是系统帮你压栈，保存现场，子过程完成之后，还原现场。

任何递归行为都可以改成非递归行为，自己压栈即可，就变成迭代了

<br/>

master公式的使用

T(N) = a*T(N/b) + O(N^d)

n/b   是子过程样本量
a是子过程发生的次数
O(n^d)是除了子过程之外剩下的过程

<br/>

1) log(b,a) > d -> 复杂度为O(N^log(b,a))

2) log(b,a) = d -> 复杂度为O(N^d * logN)

3) log(b,a) < d -> 复杂度为O(N^d)

<br/>

### 归并排序

时间复杂度

T(N) = 2*T(N/2) + O(N)    => O(N*logN)

<br/>

先把左边排好序，再把右边拍好序，最后把两个子数组进行外排序

{% asset_img picture2.png %}

<br/>

```java
/**
 *  冒泡，选择，插入，时间复杂度高的原因：
 *  浪费比较次数，每次一轮循环的比较，都只找出一个数。
 *
 *  归并时间复杂度低的原因。
 *  小范围合并大范围的过程中，也就是merge的过程中，是利用了外排序。
 *  不会浪费两个已经排好序的数组的比较次数，
 *  小范围组内排序被利用起来了。
 *  O(n * logN)
 *  空间复杂度：O（N）
 */
public class Code_05_MergeSort {

    public static void mergeSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        mergeSort(arr, 0, arr.length - 1);
    }

    public static void mergeSort(int[] arr, int l, int r) {
        if (l == r) {
            return;
        }
        int mid = (l + r) / 2;

        // 把左部分排好
        mergeSort(arr,l,mid);

        // 把右部分排好
        mergeSort(arr,mid+1,r);

        // 左右部分都排好了，但整体还是无序的，merge 就是让他们整体有序
        merge(arr,l,mid,r);
    }

    /**
     * 外排序
     * 注意点：很多地方都是从L开始，是针对子数组排序，
     * 所以不是从0开始。
     *
     * 函数功能：让整体有序
     */
    private static void merge(int[] arr, int l,int mid, int r) {

        int[] help = new int[r - l + 1];//辅助数组的作用：承接排好序的数组。不能直接覆盖原数组。
        int i = 0;
        int p1 = l;         //注意点：这里是从l开始
        int p2 = mid+1;

        while(p1 <= mid && p2 <= r){
            if(arr[p1] < arr[p2]){
                help[i++] = arr[p1++];
            }else{
                help[i++] = arr[p2++];
            }
        }

        while(p1 <= mid){
            help[i++] = arr[p1++];
        }
        while(p2 <= r){
            help[i++] = arr[p2++];
        }

        for(i = 0; i < help.length; i++){
            arr[l++] = help[i];//这里为什么是[l + i]？  画一下树形图就知道了，每次是把两个在固定位置的子数组merge。
        }
    }

    // for test
    public static void comparator(int[] arr) {
        Arrays.sort(arr);
    }

    // for test
    public static int[] generateRandomArray(int maxSize, int maxValue) {
        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
        }
        return arr;
    }

    // for test
    public static int[] copyArray(int[] arr) {
        if (arr == null) {
            return null;
        }
        int[] res = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            res[i] = arr[i];
        }
        return res;
    }

    // for test
    public static boolean isEqual(int[] arr1, int[] arr2) {
        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
            return false;
        }
        if (arr1 == null && arr2 == null) {
            return true;
        }
        if (arr1.length != arr2.length) {
            return false;
        }
        for (int i = 0; i < arr1.length; i++) {
            if (arr1[i] != arr2[i]) {
                return false;
            }
        }
        return true;
    }

    // for test
    public static void printArray(int[] arr) {
        if (arr == null) {
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    // for test
    public static void main(String[] args) {
        int testTime = 500000;
        int maxSize = 100;
        int maxValue = 100;
        boolean succeed = true;
        for (int i = 0; i < testTime; i++) {
            int[] arr1 = generateRandomArray(maxSize, maxValue);
            int[] arr2 = copyArray(arr1);
            mergeSort(arr1);
            comparator(arr2);
            if (!isEqual(arr1, arr2)) {
                succeed = false;
                printArray(arr1);
                printArray(arr2);
                break;
            }
        }
        System.out.println(succeed ? "Nice!" : "Fucking fucked!");

        int[] arr = generateRandomArray(maxSize, maxValue);
        printArray(arr);
        mergeSort(arr);
        printArray(arr);

    }
}
```

<br/>

<br/>

### 小和问题

在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组 的小和。

例子： [1,3,4,2,5] 

1左边比1小的数，没有；

 3左边比3小的数，1； 

4左边比4小的数，1、3； 

2左边比2小的数，1； 

5左边比5小的数，1、3、4、2； 

所以小和为1+1+3+1+1+3+4+2=16

<br/>

这个问题等同于：当前数组中的每一个数，都看看右边有多少个数比cur大，就产生多少个乘cur这么多小和。1右边有4个数比它大，3右边有两个数比它大。。。。

<br/>

Mergesort 为什么能加速这个过程呢？

想像一个数在merge 的时候发生了什么，cur所在的小组先合并了，因为右侧部分都是排好序的，所以在当前小组合并的过程中，你可以知道在这个小组范围内，有多少个数比cur大，排好一个范围之后，右侧来一个更大的范围，因为右侧又是拍好序的，所以又可以一次知道，右侧当前范围内有多少个数比cur大，然后两个范围形成一个范围，再和另外一个更大的范围合的时候，又求出来在这个更大的范围中，有多少个数比cur大，所以merge的过程中，小组中产生的小和不会漏算，而且同一个组内已经产生的小和是不会再次产生的，因为在组内merge完之后，是和一个更大的范围进行merge的(merge时查看这个更大的范围中有多少个数比cur大)，所以既不会算少，也不会算重，用merge这件事，一次分批量的把右边范围所有比cur大的数，全部榨取出来，利用个数乘以它本身来分批进行加速，而不再像之前遍历那样，每次找一个，这是问题的本质

<br/>

{% asset_img picture3.png %}

<br/>

{% asset_img picture4.png %}

<br/>

```java
/**
 * 每次找到 cur 在和右边的组合并的时候，右边的组中比当前cur大的数字的个数，
 * 也就是每次左边小组和右边小组合并的时候，榨出右边小组中比左边小组中大的数字的个数，
 * 每次合并都会榨取一遍，最终会把一个数字的小数个数都榨出来。
 * 具体可看图示。
 */
public class Code_12_SmallSum {

    public static int smallSum(int[] arr) {
        if (arr == null || arr.length < 2) {
            return 0;
        }
        return mergeSort(arr, 0, arr.length - 1);
    }

    public static int mergeSort(int[] arr, int l, int r) {
        if (l == r) {
            return 0;
        }
        int mid = l + ((r - l) >> 1);
        return mergeSort(arr, l, mid) + mergeSort(arr, mid + 1, r) + merge(arr, l, mid, r);
    }

    private static int merge(int[] arr, int l, int mid, int r) {

        int[] help = new int[r - l + 1];
        int i = 0;
        int p1 = l;
        int p2 = mid + 1;
        int res = 0;

        while (p1 <= mid && p2 <= r) {
            if (arr[p1] < arr[p2]) {
                res += (r - p2 + 1) * arr[p1];
                help[i++] = arr[p1++];
            } else {
                help[i++] = arr[p2++];
            }
        }

        while (p1 <= mid) {
            help[i++] = arr[p1++];
        }
        while (p2 <= r) {
            help[i++] = arr[p2++];
        }
        for(i = 0; i < help.length; i++){
            arr[l++] = help[i];
        }

        return res;
    }

    // for test
    public static int comparator(int[] arr) {
        if (arr == null || arr.length < 2) {
            return 0;
        }
        int res = 0;
        for (int i = 1; i < arr.length; i++) {
            for (int j = 0; j < i; j++) {
                res += arr[j] < arr[i] ? arr[j] : 0;
            }
        }
        return res;
    }

    // for test
    public static int[] generateRandomArray(int maxSize, int maxValue) {
        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
        }
        return arr;
    }

    // for test
    public static int[] copyArray(int[] arr) {
        if (arr == null) {
            return null;
        }
        int[] res = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            res[i] = arr[i];
        }
        return res;
    }

    // for test
    public static boolean isEqual(int[] arr1, int[] arr2) {
        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
            return false;
        }
        if (arr1 == null && arr2 == null) {
            return true;
        }
        if (arr1.length != arr2.length) {
            return false;
        }
        for (int i = 0; i < arr1.length; i++) {
            if (arr1[i] != arr2[i]) {
                return false;
            }
        }
        return true;
    }

    // for test
    public static void printArray(int[] arr) {
        if (arr == null) {
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    // for test
    public static void main(String[] args) {
        int testTime = 500000;
        int maxSize = 100;
        int maxValue = 100;
        boolean succeed = true;
        for (int i = 0; i < testTime; i++) {
            int[] arr1 = generateRandomArray(maxSize, maxValue);
            int[] arr2 = copyArray(arr1);
            if (smallSum(arr1) != comparator(arr2)) {
                succeed = false;
                printArray(arr1);
                printArray(arr2);
                break;
            }
        }
        System.out.println(succeed ? "Nice!" : "Fucking fucked!");
    }
}
```

 