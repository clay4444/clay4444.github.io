---
title: 并发编程实战(二)
categories:
  - 多线程编程
tags:
  - 并发编程实战读书笔记
abbrlink: 4427b4f0
date: 2018-02-23 18:45:20
---

主要介绍了如何通过同步来避免多个线程在同一时刻访问相同的数据

<br/>

### 核心

要对状态访问操作进行管理，特别是对共享的（ Shared ）和可变的（ Mutable ）状态的访问。

“共享“ 意味着变量可以由多个线程间同时访问，而 “可变” 则意味着变量的值在其生命周期内可以发生变化

<br/>

### 对象的状态

从非正式的意义上来说，对象的状态是指存储在状态变量（例如实例或静态域〉中的数据

<br/>

### 线程安全

要使得对象是结程安全的，需要采用同步机制来协同对对象可变状态的访问。

<br/>

### 修复并发错误的三种方式

不在线程之间共享该状态变量

将状态变量修改为不可变的变量

在访问状态变量时使用同步

<br/>

### 面向对象技术的优势（封装）

面向对象这种技术不仅有助于搞写出结构优雅、可维护性高的类，还有助于编写出线程安全的类。访问某个变量的代码越少，就越容易确保对变量的所有访问都实现正确同步，同时也更容易找出变量在哪些条件下被访问。Java语言并没有强制要求将状态都封装在类中，开发人员完全可以将状态保存在某个公开的域〈甚至公开的静态域〉中，或者提供一个对内部对象韵公开应用。然而，程序状态的封装性越好，就越容易实现程序的线程安全性，并且代码的维护人员也越容易保持这种方式。

<br/>

### 线程安全类和线程安全程序

完全由线程安全类构成的程序并不一定就是线程安全的，而在线程安全类中也可以包含非线程安全的类

在任何情况下，只有当类中仅包含自己的状态时，线程安全的类才是有意义的。

<br/>

### 线程安全性的定义

<br/>

**核心**： 正确性：某个类的行为与其规范完全一敦。在良好的规范中通常会定义各种不变性条件（ Invariant ）来约束对象的状态，以及定义各种后验条件（ Postcondition ）来描述对象操作的结果。由于我们通常不会为类编写详细的规范，那么如何知道这个类是否正确的？我的无法知道，但这持不妨碍我们在确信“类的代码能工作”后使用它们。这种“代码可信性”非常接近于我们对正确性的理解，因此我们可以将单线程的正确性近似定义为“所见即所知（we know it when we see it) ”。在对“正确性”给出了一个较为清晰的定义后，就可以定义线程安全性：当多个线程语问某个类时，这个类始终都能表现出正确的行为，那么就称这个类时线程安全的。

<br/>

### 无状态对象：一定是线程安全的

既不包含任何域，也不包含任何对其他类中域的引用。计算过程中的临时状态仅存在于线程栈上的局部变量中，井
且只能由正在执行的线程访问。访问此类的线程不会影响另一个访问同一个类的线程的计算结果，因为这两个线程并没有共享状态，就好像它们都在访问不同的实例。由于线程访问无状态对象的行为并不会影响其他线程中操作的正确性，因此无状态对象是钱程安全的。

<br/>

大多数Servlet 都是无状态的，从而极大地降低了在实现Servlet 线程安全性时的复杂性。只有当Servlet 在处理请求时需要保存一些信息，线程安全性才会成为一个问题。

<br/>

当在无状态的类中添如一个状态时，如果该状态完全由线程安全的对象来管理，那么这个类仍然是线程安全的。



### 竞态条件

```java
@NotThreadSafe
public class UnsafeCountingFactorizer implements Servlet {
	private long count= O;	
	public long getCount｛｝ { return count; }
	public void service(ServletRequest req, ServletResponse resp){
		BigInteger i = extractFormRequest (req);
		BigInteger[] factors = factor(i);
		++count;
		encodeintoResponse(resp, factors);
	}
}
```

在基于Web 的服务中，命中计数器值的少量偏差或许是可以接受的，在某些情况下也确实如此。但如果该计数器被用来生成数值序列或者唯一的对象标识符，那么在多次调用中返回相同的值将导致严重的数据完整性问题

<br/>

这种由于不恰当的执行时序而出现不正确的结果是一件非常重要的情况就叫做竞态条件。

当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件。

<br/>

最常见的竞态条件类型就是 ：”先检查后执行“  操作，即通过一个可能失效的观测结果来决定下一步的动作。

<br/>

本质：基于一种可能失效的观察结果来做出判断或者执行某个计算。这种类型的竞态条件称为“先检查后执行’。首先观察到某个条件为真〈剖如文件X 不存在），然后根据这个观察结果采用相应的动作（创建文件X ），而事实上，在你观察到这个结果以及开始创建文件之间，观察结果可能变得无效（另一个线程在这期间创建了文件X ），从而导致各种问题（未预期的异常、数据被覆盖、文件被破坏等〉。

<br/>

### 延迟初始化中的竞态条件

延迟初始化的目的是将对象的初始化操作推迟到实际被使用时才进行，同时要确保只被初始住一次，

<br/>

### 复合操作

包含了一组必须以原子方式执行的操作以确保线程安全性。

<br/>

### 内置锁

每个Java 对象都可以用做一个实现同步的锁，这些锁被称为内置锁（IntrinsicLock）或监视器锁（Monitor Lock）

Java 的内置锁相当于一种互斥体〈或互斥锁〉

<br/>

### 锁的重入

由于内置锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。

“重入”意味着获取锁的操作的粒度是“线程”，而不是 ”调用“

重入的一种实现方式时为每个锁关联一个获取计数值和一个所有者线程。当计数值为0 时，这个锁就被认为是没
有被任伺线程持有。当线程请求一个未被持有的锁时， JVM 将记下锁的持有者，并且将获取计数值置为1. 如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。当计数佳为0 时，这个锁将被释放。

<br/>

重入进一步提升了加锁行为的封装性，因此简化了面向对象并发代码的开发

<br/>

如果内置锁不是可重入的，那么这段代码将发生死锁：

```java
public class Widget {
	public synchronized void doSomething { 
	。。。
	}
}
	
	
public class LoggingWidget extends Widget {
	public synchronized void doSomething() {
		System.out.println (tostring () ＋ ”：calling doSomething”};
		super,doSomething{);	
     }
}
```

<br/>

### 内置锁的状态保护

对象的内置锁与其状态之间没有内在的关联。虽然大多数类都将内置锁用做一种有效的加锁机制，但对象的域并不一定要通过内置锁来保护。当获取与对象关联的锁时，并不能阻止其他对象访问该对象，某个线程在获得对象的锁之后，只能阻止其他线程获得同一个锁。之所以每个对象都有一个内置锁，只是为了免去显式的创建对象。

<br/>

需求：等虑一个处理大规模数据的单线程程序，由于任何数据都不会在多个钱程之间共享，因此在单线程程序中不需要同步， 现在，假设希望添加一个新功能，即定期地对数据处理进度生成快照，这样程序崩溃或者必须停止时无须再次从头开始。你可能会选择使用TimerTask ，每十分钟触发一次，并将程序状态保存到某个文件中。

<br/>

由于TimerTask 在另一个〈由Timer 管理的〉线程中调用，因此现在就有两个线程同时访问快照中的数据： 程序的主线程和Timer 线程。这意味着，当访问程序的状态时，不仅TimerTask代码必须使用同步，而且程序中所有访问相同数据的代码路径也必须使用同步。原本在程序中不需要使用同步，现在变成了在程序的各个位置都需要使用同步。

<br/>

### 原子性

并发环境中的原子性与事务应用程序中的原子性有着相间的含义：一组语句作为一个不可分割的单元被执行。

<br/>

### 性能问题

原始代码：

```java
@ThreadSafe
public class SynchronizedFactorizer implements Servlet {
	@GuardedBy("this") private Biginteger lastnumber;
	@GuardedBy("this") private Biginteger [] lastFactors;

     public synchronized void service(ServletRequest req,ServletResponse resp)
		biginteger i ＝extractFromRequest (req) ;
         if (i.equals(lastNumber))
			encodeintoResponse(resp, lastFactors);
		else {
            Biginteger[] factors = factor(i);
            lastNumber = i;
            lastFactors ＝ factors;
            encodeintoResponse{resp, factors);
         }
    }
}
```

正确的做法：

<br/>

通过缩小同步代码块的样用范围，我们很容易做到既确保Servlet 的并发性，同时又维护线程安全性。要确保同步代码块不要过小，并且不要将本应是原子的操作拆分到多个同步代码块中。应该尽量将不影响共享状态且执行时间较长的操作从同步代码快中分离出去，从而在这些操作的执行过程中，其他线程可以访问共享状态。

```java
@ThreadSafe
public class CachedFactorizer implements Servlet{
  @GuardedBy("this") private Biginteger lastNumber;
  @GuardedBy("this'') private Biginteger [] lastFactors;
  @GuardedBy("this") private long hits;
  @GuardedBy("this”） private long cacheHits;
             
  public synchronized long getHits() { return hits; }
  public synchronized double getCacheHitRatio () {
	return (double) cacheHits / (double) hits;
  }
	
   public void service(ServletRequest req, ServletResponsE! resp)
		Biginteger i = extractFromRequest(req);
		BigInteger[] factors ＝ null;
		synchronized {this) {		//保护判断是否只需返回缓存结果的“先检查后执行” 的操作序列
            ++hits;
            if (i.equals(lastNumber)){
                ++cacheHits;
                factors= lastFactors.clone();
             }
        }
		if (factors ＝ null) {
            factors = factor(i);
            synchronized (this) {	//确保对缓存的数值和因数分解结果进行同步更新
              	lastnumber = i;
                lastFactors = factors.clone();
            }
         }
		encodeIntoResponse(resp, factors);
    }
}
```

不变性条件：在lastFactors 中缓存的因数之积应该等于在lastNumber 中缓存的数值，也就是说两个值应该始终保持一致，

<br/>

不能违反此约束条件

<br/>

重新构造后的CachedFactorizer 实现了在简单性〈对整个方法进行同步〉与并发性〈对尽可能短的代码路径进行同步〉之间的平衡。

<br/>

当访问状态变量或者在复合操作的执行期间，CachedFactorizer 需要持有锁，但在执行时间较长的因数分解运算之前要释放锁。这样既确保了线程安全性，也不会过多地影响并发性，



 <br/>

## 面试题：servlet是否是线程安全的？

Servlet不是线程安全的。

 <br/>

要解释为什么Servlet为什么不是线程安全的，需要了解Servlet容器（即Tomcat）使如何响应HTTP请求的。

 <br/>

当Tomcat接收到Client的HTTP请求时，Tomcat从线程池中取出一个线程，之后找到该请求对应的Servlet对象并进行初始化，之后调用service()方法。要注意的是每一个Servlet对象再Tomcat容器中只有一个实例对象，即是单例模式。如果多个HTTP请求请求的是同一个Servlet，那么着两个HTTP请求对应的线程将并发调用Servlet的service()方法。

{% asset_img 二1.png %}

上图中的Thread1和Thread2调用了同一个Servlet1，所以**此时如果Servlet1中定义了实例变量或静态变量，那么可能会发生线程安全问题**（因为所有的线程都可能使用这些变量）。

<br/>

比如下面的Servlet中的 `name` 和 `i`变量就会引发线程安全问题。

~~~java
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class ThreadSafeServlet extends HttpServlet {

  public static String name = "Hello";   //静态变量，可能发生线程安全问题
  int i;  //实例变量，可能发生线程安全问题
  SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");

  @Override
  public void init() throws ServletException {
    super.init();
    System.out.println("Servlet初始化");
  }

  @Override
  protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    System.out.printf("%s：%s[%s]\n", Thread.currentThread().getName(), i, format.format(new Date()));
    i++;
    try {
      Thread.sleep(5000);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
    System.out.printf("%s：%s[%s]\n", Thread.currentThread().getName(), i, format.format(new Date()));
    resp.getWriter().println("<html><body><h1>" + i + "</h1></body></html>");
  }
}
~~~

在Tomcat中启动这个Servlet并在浏览器发起多个HTTP访问，最后会发现变量 `i` 是多线程共享的。

<br/>

如果需要更加深入透彻地了解Tomcat接收HTTP的细节，以及与Servlet交互的细节，可以深入看看Tomcat的架构和源码。