---
title: 算法进阶第六课
categories:
  - leetcode
abbrlink: ff78c689
date: 2019-04-04 21:57:24
---

### 题目：换钱的方法数

换钱的方法数 

【题目】 给定数组arr，arr中所有的值都为正数且不重复。每个值代表 一种面值的货币，每种面值的货币可以使用任意张，再给定一 个整数aim代表要找的钱数，求换钱有多少种方法。

【举例】 arr=[5,10,25,1]，aim=0。 组成0元的方法有1种，就是所有面值的货币都不用。所以返回1。 

arr=[5,10,25,1]，aim=15。 组成15元的方法有6种，分别为3张5元、1张10元+1张5元、1张 10元+5张1元、10张1元+1张5元、2张5元+5张1元和15张1元。所 以返回6。

 arr=[3,5]，aim=2。 任何方法都无法组成2元。所以返回0。

<br/>

#### 尝试的暴力解法

{% asset_img picture1.jpg %}

0张200的，剩下的组成1000，方法数有a种

1张200的，剩下的组成800，方法数有b种

2张200的，剩下的组成600，方法数有c种

....
5张200的，剩下的组成0，方法数

把所有的方法数加起来就是答案

<br/>

代码

```java
public static int coins1(int[] arr, int aim) {
   if (arr == null || arr.length == 0 || aim < 0) {
      return 0;
   }
   return process1(arr, 0, aim);
}

/**
 * @param arr   钱的种类数组
 * @param index  可以任意自由使用index及其之后的钱
 * @param aim  目标钱数
 * @return   方法数
 */
public static int process1(int[] arr, int index, int aim) {
   int res = 0;
   if (index == arr.length) { //到最终了，剩的目标是0，就找到了一种有效的划分，就返回0，
      res = aim == 0 ? 1 : 0;
   } else {
      for (int zhang = 0; arr[index] * zhang <= aim; zhang++) {
         //aim - arr[index] * zhang 就是下一阶段要找的aim，并且只能使用index + 1之后的货币
         res += process1(arr, index + 1, aim - arr[index] * zhang); //index位置的货币已经使用完了，使用之后的货币
      }
   }
   return res;
}
```

<br/>

for循环图示

{% asset_img picture2.jpg %}

<br/>

暴力递归的缺点

产生了很多的重复计算，而且重复计算的状态的返回值是固定不变的，

{% asset_img picture3.jpg %}

<br/>

#### 优化：记忆化搜索

所以：诞生了第一个优化版本

只要index和aim固定了，计算的结果肯定就是固定的，

无后效性问题：计算一个子过程状态的时候，和怎么到达这个状态的过程和路径都没关系，不管如何到达的，这个子过程的状态都是保持不变的，也就是返回值都是固定不变的，这也是面试最常见的；

有后效性问题：经典的n皇后问题

<br/>

优化：增加一个map缓存，就是所谓的记忆化搜索方法

<br/>

代码

```java
public static Map<String,Integer> map = new HashMap<>();

//记忆化搜索
public static int process_map(int[] arr, int index, int aim) {
    int res = 0;
    if (index == arr.length) {
        res = aim == 0 ? 1 : 0;  //到最终了，剩的目标是0，就找到了一种有效的划分，就返回0，
    } else {
        for (int zhang = 0; arr[index] * zhang <= aim; zhang++) {

            Integer nextAim = aim - arr[index] * zhang;
            String key = String.valueOf(index + 1) + "_" + String.valueOf(nextAim);

            if(map.containsKey(key)){
                res += map.get(key);
            }else{
                //aim - arr[index] * zhang 就是下一阶段要找的aim，并且只能使用index + 1之后的货币
                res += process_map(arr, index + 1, nextAim); //index位置的货币已经使用完了，使用之后的货币
            }
        }
    }
    map.put(String.valueOf(index) + "_" + aim,res);
    return res;
}
```

<br/>

#### 再优化解法：dp

参数的变化范围，就是结果的变化范围，参数的变化范围可以用一张二维表囊括，那么所有的结果也就都可以用这张二维表装下；

index的变化范围是从0到n，aim的变化范围是从0到1000，

<br/>

**思路**

先找出目标点，这里是(0, aim)，

再找出这张表中哪些位置的值是可以直接确定的，不依赖其他位置的， 看递归中的basecase，当index=n时，值是可以直接确定的，所以最后一行第一个位置是1，剩下的都是0；

然后看位置依赖，也就是如何调用递归函数的，相当于在二维表中随便找一个值，(index，aim)，看它的依赖，这个位置只依赖下面一行的数字（准确的说是：下面一行的(inde+1,aim),(inde+1,aim-1*arr[index]),(inde+1,aim-2*arr[index])……..直到越界 ） 

现在有了最后一行，而且之上的每个位置又只依赖下一行的位置，所以可以一直从最后一行往上推，一直推到终点位置

{% asset_img picture4.jpg %}

<br/>

举例

{% asset_img picture5.jpg %}

<br/>

#### 最优化

{% asset_img picture6.jpg %}

如图，绿1的位置=蓝1+2+3+4+5，绿2的位置=绿2底下的值+蓝1+2+3+4+5

所以绿2的位置=绿2底下的值+绿1的位置

<br/>

代码

```java
public class Code_01_CoinsWay {

	public static int coins1(int[] arr, int aim) {
		if (arr == null || arr.length == 0 || aim < 0) {
			return 0;
		}
		return process1(arr, 0, aim);
	}

	/**
	 * @param arr   钱的种类数组
	 * @param index 可以任意自由使用index及其之后的钱
	 * @param aim	目标钱数
	 * @return   	方法数
	 */
	public static int process1(int[] arr, int index, int aim) {
		int res = 0;
		if (index == arr.length) {
			res = aim == 0 ? 1 : 0;  //到最终了，剩的目标是0，就找到了一种有效的划分，就返回0，
		} else {
			for (int zhang = 0; arr[index] * zhang <= aim; zhang++) {
				//aim - arr[index] * zhang 就是下一阶段要找的aim，并且只能使用index + 1之后的货币
				res += process1(arr, index + 1, aim - arr[index] * zhang); //index位置的货币已经使用完了，使用之后的货币
			}
		}
		return res;
	}


	public static Map<String,Integer> map = new HashMap<>();

	//记忆化搜索
	public static int process_map(int[] arr, int index, int aim) {
		int res = 0;
		if (index == arr.length) {
			res = aim == 0 ? 1 : 0;  //到最终了，剩的目标是0，就找到了一种有效的划分，就返回0，
		} else {
			for (int zhang = 0; arr[index] * zhang <= aim; zhang++) {

				Integer nextAim = aim - arr[index] * zhang;
				String key = String.valueOf(index + 1) + "_" + String.valueOf(nextAim);

				if(map.containsKey(key)){
					res += map.get(key);
				}else{
					//aim - arr[index] * zhang 就是下一阶段要找的aim，并且只能使用index + 1之后的货币
					res += process_map(arr, index + 1, nextAim); //index位置的货币已经使用完了，使用之后的货币
				}
			}
		}
		map.put(String.valueOf(index) + "_" + aim,res);
		return res;
	}


	public static int coinsOther(int[] arr, int aim) {
		if (arr == null || arr.length == 0 || aim < 0) {
			return 0;
		}
		return processOther(arr, arr.length - 1, aim);
	}

	public static int processOther(int[] arr, int index, int aim) {
		int res = 0;
		if (index == -1) {
			res = aim == 0 ? 1 : 0;
		} else {
			for (int i = 0; arr[index] * i <= aim; i++) {
				res += processOther(arr, index - 1, aim - arr[index] * i);
			}
		}
		return res;
	}

	public static int coins2(int[] arr, int aim) {
		if (arr == null || arr.length == 0 || aim < 0) {
			return 0;
		}
		int[][] map = new int[arr.length + 1][aim + 1];
		return process2(arr, 0, aim, map);
	}

	public static int process2(int[] arr, int index, int aim, int[][] map) {
		int res = 0;
		if (index == arr.length) {
			res = aim == 0 ? 1 : 0;
		} else {
			int mapValue = 0;
			for (int i = 0; arr[index] * i <= aim; i++) {
				mapValue = map[index + 1][aim - arr[index] * i];
				if (mapValue != 0) {
					res += mapValue == -1 ? 0 : mapValue;
				} else {
					res += process2(arr, index + 1, aim - arr[index] * i, map);
				}
			}
		}
		map[index][aim] = res == 0 ? -1 : res;
		return res;
	}

	/**
	 * dp 不优化版本
	 */
	public static int coins3(int[] arr, int aim) {
		if (arr == null || arr.length == 0 || aim < 0) {
			return 0;
		}
		int[][] dp = new int[arr.length][aim + 1];
		for (int i = 0; i < arr.length; i++) {
			dp[i][0] = 1;
		}
		for (int j = 1; arr[0] * j <= aim; j++) {
			dp[0][arr[0] * j] = 1;
		}
		int num = 0;
		for (int i = 1; i < arr.length; i++) {
			for (int j = 1; j <= aim; j++) {
				num = 0;
				for (int k = 0; j - arr[i] * k >= 0; k++) {
					num += dp[i - 1][j - arr[i] * k];
				}
				dp[i][j] = num;
			}
		}
		return dp[arr.length - 1][aim];
	}

	/**
	 * dp 优化版本，
	 */
	public static int coins4(int[] arr, int aim) {
		if (arr == null || arr.length == 0 || aim < 0) {
			return 0;
		}
		int[][] dp = new int[arr.length][aim + 1];
		for (int i = 0; i < arr.length; i++) {
			dp[i][0] = 1;
		}
		for (int j = 1; arr[0] * j <= aim; j++) {
			dp[0][arr[0] * j] = 1;
		}
		for (int i = 1; i < arr.length; i++) {
			for (int j = 1; j <= aim; j++) {
				dp[i][j] = dp[i - 1][j];
				dp[i][j] += j - arr[i] >= 0 ? dp[i][j - arr[i]] : 0;  //优化的点
			}
		}
		return dp[arr.length - 1][aim];
	}

	public static int coins5(int[] arr, int aim) {
		if (arr == null || arr.length == 0 || aim < 0) {
			return 0;
		}
		int[] dp = new int[aim + 1];
		for (int j = 0; arr[0] * j <= aim; j++) {
			dp[arr[0] * j] = 1;
		}
		for (int i = 1; i < arr.length; i++) {
			for (int j = 1; j <= aim; j++) {
				dp[j] += j - arr[i] >= 0 ? dp[j - arr[i]] : 0;
			}
		}
		return dp[aim];
	}

	public static void main(String[] args) {
		int[] coins = { 10, 5, 1, 25 };
		int aim = 2000;

		long start = 0;
		long end = 0;
		start = System.currentTimeMillis();
		System.out.println(coins1(coins, aim));
		end = System.currentTimeMillis();
		System.out.println("cost time : " + (end - start) + "(ms)");

		start = System.currentTimeMillis();
		System.out.println(coinsOther(coins, aim));
		end = System.currentTimeMillis();
		System.out.println("cost time : " + (end - start) + "(ms)");

		aim = 20000;

		start = System.currentTimeMillis();
		System.out.println(coins2(coins, aim));
		end = System.currentTimeMillis();
		System.out.println("cost time : " + (end - start) + "(ms)");

		start = System.currentTimeMillis();
		System.out.println(coins3(coins, aim));
		end = System.currentTimeMillis();
		System.out.println("cost time : " + (end - start) + "(ms)");

		start = System.currentTimeMillis();
		System.out.println(coins4(coins, aim));
		end = System.currentTimeMillis();
		System.out.println("cost time : " + (end - start) + "(ms)");

		start = System.currentTimeMillis();
		System.out.println(coins5(coins, aim));
		end = System.currentTimeMillis();
		System.out.println("cost time : " + (end - start) + "(ms)");
	}
}
```

<br/>

<br/>

### 题目：排成一条线的纸牌博弈问题

【题目】 

给定一个整型数组arr，代表数值不同的纸牌排成一条线。玩家A和玩家B依次拿走 每张纸牌，规定玩家A先拿，玩家B后拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家A和玩家B都绝顶聪明。请返回最后获胜者的分数。 

【举例】 

arr=[1,2,100,4]。 

开始时玩家A只能拿走1或4。如果玩家A拿走1，则排列变为[2,100,4]，接下来玩 家B可以拿走2或4，然后继续轮到玩家A。如果开始时玩家A拿走4，则排列变为 [1,2,100]，接下来玩家B可以拿走1或100，然后继续轮到玩家A。玩家A作为绝顶 聪明的人不会先拿4，因为拿4之后，玩家B将拿走100。所以玩家A会先拿1，让排 列变为[2,100,4]，接下来玩家B不管怎么选，100都会被玩家A拿走。玩家A会获胜， 分数为101。所以返回101。 

arr=[1,100,2]。 

开始时玩家A不管拿1还是2，玩家B作为绝顶聪明的人，都会把100拿走。玩家B会 获胜，分数为100。所以返回100。

<br/>

举例

{% asset_img picture7.jpg %}

如图所示情况，玩家一二，都是博弈论中非常理智的人，

如果玩家一先拿，是不存在必胜策略的，例如1，100，1  这种情况，先拿的人肯定输

<br/>

**经验**

一道题，想不出来贪心策略，肯定就是暴力递归问题，递归解法出来之后，转化为dp问题

<br/>

暴力尝试版本

直接看代码

```java
public static int win1(int[] arr) {
    if (arr == null || arr.length == 0) {
        return 0;
    }
    return Math.max(f(arr, 0, arr.length - 1), s(arr, 0, arr.length - 1));
}

/**
	 * 表示如果纸牌只剩下标在begin~end之间的几个了，那么作为先拿者，纸牌被拿完后，先拿者能达到的最大分数
	 * @param arr
	 * @param begin
	 * @param end
	 * @return
	 */
public static int f(int[] arr, int begin, int end) {
    if (begin == end) {  // 如果只有一张纸牌，那么该纸牌分数就是先拿者能达到的最大分数，直接返回，无需决策。
        return arr[begin];
    }
    //否则先拿者A的第一次决策只有两种情况：
    //先拿最左边的arr[beginIndex]，那么在A拿完这一张之后就会作为后拿者参与到剩下的(begin+1)~end之间的纸牌的决策了，这一过程可以交给s()来做。
    //先拿最右边的arr[endIndex]，那么在A拿完这一张之后就会作为后拿者参与到剩下的begin~(end-1)之间的纸牌的决策了，这一过程可以交给s()来做。
    return Math.max(arr[begin] + s(arr, begin + 1, end), arr[end] + s(arr, begin, end - 1));
}

/**
	 * 表示如果纸牌只剩下标在begin~end之间的几个了，那么作为后拿者，纸牌被拿完后，后拿者能达到的最大分数
	 * @param arr
	 * @param begin
	 * @param end
	 * @return
	 */
public static int s(int[] arr, int begin, int end) {
    if (begin == end) {  //如果只有一张纸牌，那么作为后拿者没有纸牌可拿，分数为0，直接返回
        return 0;
    }
    //假设先拿者A拿到了arr[beginIndex]，那么去掉该纸牌后，对于剩下的(begin+1)~end之间的纸牌，后拿者B就转变身份成了先拿者，这一过程可以交给f()来处理。
    //假设先拿者A拿到了arr[endIndex]，那么去掉该纸牌后，对于剩下的begin~(end-1)之间的纸牌，后拿者B就转变身份成了先拿者，这一过程可以交给f()来处理。

    //这里取两种情况中结果较小的一种，是因为这两种情况是我们假设的，但先拿者A绝顶聪明，他的选择肯定会让后拿者尽可能拿到更小的分数。
    //比如arr=[1,2,100,4]，虽然我们的假设有先拿者拿1和拿4两种情况，对应f(arr,1,3)和f(arr,0,2)，但实际上先拿者不会让后拿者拿到100，
    //因此取两种情况中结果较小的一种。
    return Math.min(f(arr, begin + 1, end), f(arr, begin, end - 1));
}
```

<br/>

dp

根据递归函数，参数的变化范围i和j都是数组index的变化范围，有两个函数，所以构建两张二维表

i不可能比j大， 因为遇到相等就返回了；所以表的左下区域不用填；

i：数组中index变化范围

j：数组中index变化范围

目标位置：两个表都是0到n-1范围是目标位置，取两个中最大的；

basecase，f表中对角线位置是对应index的值，s表对角线位置都是0

然后看一个普遍的位置是如何依赖的：f(i,j) 依赖s表中的 s(i+1,j) 和s(i,j-1)，同理，s(i,j)也依赖f(i+1,j) 和f(i,j-1)

所以可以从s表的对角线推出f表的倒数第二条对角线，从f表的对角线推出s表的倒数第二条对角线，所以之后的过程就是两个表互相推，直到推到两个表的 0到n-1 位置；

<br/>

### 题目：机器人走路问题

n：1位置到n位置，

m：开始停留到m位置，

当机器人在n位置时，只能往左走，在0位置时，只能往右走，

问：当机器人走p步的时候，正好停在k位置的机会有多少种？

<br/>

暴力解法

```java
public class Easy {
    /**
     * @param N 多少个位置        不变
     * @param M 来到的位置
     * @param P 再走p步
     * @param K 最终停留在k位置    固定不变
     * @return 一共多少种走法
     */
    public static int ways(int N, int M, int P, int K) {

        if (N < 2 || M < 1 || M > N || P < 0 || K < 1 || K > N) {
            return 0;
        }

        if (P == 0) {
            return M == K ? 1 : 0;
        }
        int res = 0;
        if (M == 1) {
            res += ways(N, M + 1, P - 1, K);
        } else if (M == N) {
            res += ways(N, M - 1, P - 1, K);
        } else {
            res += ways(N, M + 1, P - 1, K) + ways(N, M - 1, P - 1, K);
        }

        return res;
    }
}
```

<br/>

dp解法

杨辉三角形，碰到撞墙的地方就只取一个依赖位置，

分析思路和上面的套路完全一致；

{% asset_img picture8.jpg %}

<br/>

### 题目：累加和等于aim的最长子数组

给定一个数组arr，全是正数；一个整数aim，求累加和等于aim的，最长子数组，要求额外空间复杂度O(1)，时间 复杂度O(N)

<br/>

解法：双指针

L、R 初始都指在-1位置，sum值记录子数组累加和，sum<aim，R就往右扩一个，当发现等于aim了，就说明找到了一个字数组，记录这个子数组，然后R再往右扩一个，如果sum>aim 了。L开始往右边走，sum减去出窗口的值，然后再判断sum和aim的情况，继续双指针的移动即可；直到到达最右边界，

{% asset_img picture9.jpg %}

<br/>

注意：sum=aim的情况下，既可以L往右边扩充，也可以R往右边扩充，因为都是正数，如果L往右边扩充，之后肯定是sum<aim了， R往右边扩，如果R往右边扩，之后肯定是sum>aim了，L会往右边扩，两种方法结果是一致的；

<br/>

本质，为什么这样是对的？

{% asset_img picture10.jpg %}

假设矩形是整个数组，椭圆形是最后的答案，假设L已经到达了答案的左边界，那么R如果在答案数组中间，那么此时sum一定小于aim，如果R超过了答案数组的右边界，那么R之前一定经过过答案数组的右边界，而且经过的时候，sum一定等于aim，此时会记录这个答案数组。综上，一定不会错过正确答案；

而且不仅不会错过答案，还会找到以每个位置开头的，符合条件的子数组；

<br/>

代码

```java
public class Code_04_LongestSumSubArrayLengthInPositiveArray {

	public static int getMaxLength(int[] arr, int aim) {
		if (arr == null || arr.length == 0 || aim <= 0) {
			return 0;
		}
		int L = 0;
		int R = 0;
		int sum = arr[0];
		int len = 0;
		while (R < arr.length) {
			if (sum == aim) {
				len = Math.max(len, R - L + 1);
				sum -= arr[L++];
			} else if (sum < aim) {
				R++;
				if (R == arr.length) {
					break;
				}
				sum += arr[R];
			} else {
				sum -= arr[L++];
			}
		}
		return len;
	}

	public static int[] generatePositiveArray(int size) {
		int[] result = new int[size];
		for (int i = 0; i != size; i++) {
			result[i] = (int) (Math.random() * 10) + 1;
		}
		return result;
	}

	public static void printArray(int[] arr) {
		for (int i = 0; i != arr.length; i++) {
			System.out.print(arr[i] + " ");
		}
		System.out.println();
	}

	public static void main(String[] args) {
		int len = 20;
		int k = 15;
		int[] arr = generatePositiveArray(len);
		printArray(arr);
		System.out.println(getMaxLength(arr, k));
	}
}
```

<br/>

<br/>

### 题目：累加和小于等于aim的最长子数组

给定一个数组arr，值可正，可负，可0；一个整数aim，求累加 和小于等于aim的，最长子数组，要求时间复杂度O(N)

<br/>

准备

生成两个数组 min_sum 和 min_sum_index ，和原数组的长度一致

min_sum代表的意思是对应原数组中，以原数组index位置的值作为数组开头的一个累加和最小的子数组的累加和；

min_sum_index代表的意思是对应原数组中，以原数组index位置的值作为数组开头的一个累加和最小的子数组能够到达的右边界；

这另个数组的生成过程很简单，从右往左遍历原数组， 最后的值先填上，然后往左遍历，遍历的时候如果发现右边已经填上的值是负数，此时直接加上右边的值就是以当前位置开头的累加和最小的子数组的累加和，此时到达的右边界和右边数的右边界一致。如果发现左边已经填上的值是正数，那么这个位置本身的值就是以当前位置开头的累加和最小的子数组的累加和，此时到达的右边界也是它自己本身的index；

{% asset_img picture11.jpg %}

<br/>

解法过程

从0位置开始扩，此时L指向0位置，然后从min_sum数组中找出以0位置开始累加和最小的子数组的累加和，然后再从min_sum_index中取出以0位置开始累加和最小的子数组能够到达的右边界，此时判断0到R这个子数组的累加和是否小于aim。如果大于aim，说明以0开头找不到小于aim的子数组，因为刚才取出来的0到R这个子数组就是以0位置开头累加和最小的子数组，如果它都不符合条件，其他以0开头的子数组更不可能符合条件。如果小于等于aim，此时R一下扩到这个边界位置，然后以当前的边界点R为L，找到这个L点的以L位置开头累加和最小的子数组的累加和，把这两个累加和累加起来，看是否小于等于aim，如果还小于等于，R继续跳到这个累加和最小的子数组的后边界，继续以此种方式往右边扩，直到发现全部的累加和大于aim了，停止；此时R的位置，就是以0位置开头能够找到的累加和小于等于aim的最长子数组的右边界；

{% asset_img picture12.jpg %}

<br/>

注意：之后的解法不是找1往右一块一块的扩，找2往右一块一块的扩，这样的解法不会错过答案，但是会使得时间复杂度变成O(n^2)

<br/>

假设从0开始扩到T位置，累加和是小于等于aim的，T+1位置扩不动了，然后计算1位置的时候，T是不会往左缩的，我们会直接计算1位置到T+1位置是不是小于等于aim的，这个步骤的sum是可以计算出来的，sum=sum-aim[0]，因为如果1位置扩不到T+1位置，我们是不关心这个结果的，因为即使计算了以1位置开头的最长子数组，它还是没有以0位置开头的长，这个计算是没有意义的，就是如下的情况

{% asset_img picture13.jpg %}

<br/>

我们只关心最长的子数组，所以这件事就变成了左边界和右边界永远都是往右滑的，永远不会回退，所以时间复杂度是O(N)，这是这道题的精髓

{% asset_img picture14.jpg %}

<br/>

代码

```java
public class Code_05_LongestSubarrayLessSumAwesomeSolution {

	public static int maxLengthAwesome(int[] arr, int aim) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		int[] sums = new int[arr.length];
		int[] ends = new int[arr.length];

		sums[arr.length - 1] = arr[arr.length - 1];
		ends[arr.length - 1] = arr.length - 1;

		//生成两个信息
		for (int i = arr.length - 2; i >= 0; i--) {
			if (sums[i + 1] < 0) {
				sums[i] = arr[i] + sums[i + 1];  //负数
				ends[i] = ends[i+1];  //右边前一个到达的右边界
			} else {
				sums[i] = arr[i];
				ends[i] = i;
			}
		}

		// 利用两个信息做计算,
		int R = 0;  //右边界
		int sum = 0;   //start 到 R 的累加和
		int len = 0;
		for (int start = 0; start < arr.length; start++) {
			while (R < arr.length && sum + sums[R] <= aim) {  //越界了或者累加和超过aim了。
				sum += sums[R];
				R = ends[R] + 1;
			}
			sum -= R > start ? arr[start] : 0;  // R > start 说明窗口有值，
			len = Math.max(len, R - start);  //更新长度
			R = Math.max(R, start + 1);  //需要考虑一个数都扩不动的情况；此时R也需要向右扩，否则R就不动了；
		}
		return len;
	}

	public static int maxLength(int[] arr, int k) {
		int[] h = new int[arr.length + 1];
		int sum = 0;
		h[0] = sum;
		for (int i = 0; i != arr.length; i++) {
			sum += arr[i];
			h[i + 1] = Math.max(sum, h[i]);
		}
		sum = 0;
		int res = 0;
		int pre = 0;
		int len = 0;
		for (int i = 0; i != arr.length; i++) {
			sum += arr[i];
			pre = getLessIndex(h, sum - k);
			len = pre == -1 ? 0 : i - pre + 1;
			res = Math.max(res, len);
		}
		return res;
	}

	public static int getLessIndex(int[] arr, int num) {
		int low = 0;
		int high = arr.length - 1;
		int mid = 0;
		int res = -1;
		while (low <= high) {
			mid = (low + high) / 2;
			if (arr[mid] >= num) {
				res = mid;
				high = mid - 1;
			} else {
				low = mid + 1;
			}
		}
		return res;
	}

	// for test
	public static int[] generateRandomArray(int len, int maxValue) {
		int[] res = new int[len];
		for (int i = 0; i != res.length; i++) {
			res[i] = (int) (Math.random() * maxValue) - (maxValue / 3);
		}
		return res;
	}

	public static void main(String[] args) {
		for (int i = 0; i < 1000000; i++) {
			int[] arr = generateRandomArray(10, 20);
			int k = (int) (Math.random() * 20) - 5;
			if (maxLengthAwesome(arr, k) != maxLength(arr, k)) {
				System.out.println("oops!");
			}
		}
	}
}
```

<br/>

<br/>

### 题目：环形单链表的约瑟夫问题

【题目】

 据说著名犹太历史学家Josephus有过以下故事：在罗马人占领乔塔帕特后， 39个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个 人开始报数，报数到3的人就自杀，然后再由下一个人重新报1，报数到3的人 再自杀，这样依次下去，直到剩下最后一个人时，那个人可以自由选择自己的命运。这就是著名的约瑟夫问题。现在请用单向环形链表描述该结构并呈现整个自杀过程。

 输入：

一个环形单向链表的头节点head和报数的值m。 

返回：

最后生存下来的节点，且这个节点自己组成环形单向链表，其他节点都删掉。 

进阶： 

如果链表节点数为N，想在时间复杂度为O(N)时完成原问题的要求，该怎么实 现？

<br/>

暴力解法：

遍历一次杀死一个节点，时间复杂度 O(M*N)

<br/>

y=x%i 函数图像

{% asset_img picture15.jpg %}

<br/>

O(N) 的解法:

每杀死一个节点，剩下的节点就按照环形链表的顺序往下重新编号，也就是说被杀死节点的下一个节点编号为1，剩下的节点按照这个顺序重新编号，那么杀到最后只剩下一个节点的时候，存活节点的编号肯定是1，废话，因为只剩下一个了，如果有一个公式，可以还原出在还剩两个节点的时候，也就是这个节点在还剩两个节点的时候的编号，那么就可以从下往上一直递推，找到最开始一个节点都没杀的时候，最后存活节点的编号，也就是最终的结果，这样就不用杀死节点了。 

{% asset_img picture16.jpg %}

<br/>

找这个公式的思路

先找出编号和报数之间的关系，编号一直是从1到i，报数是一直递增的，根据对应数字描点画图，我们得到如下的图像

{% asset_img picture17.jpg %}

通过观察，可以发现编号和报数之间的关系函数是由y=x%i 函数图像 向上平移一位，再向右平移一位，得到的，所以我们得到编号和报数之间的关系是：

编号=(报数-1)%i+1（当长度为i的时候）

<br/>

然后再找旧号(长度i)和新号之间的函数关系(长度i-1)，旧号杀死一个节点之后，链表长度变为i-1；

用举例的方式分析函数图像，如下：假设s是被杀死的节点

{% asset_img picture18.jpg %}

<br/>

函数分析

这个函数的图像，是由 y=(x-1)%i+1  向左平移S个位置得到的，

其实左右平移看第一个斜线最高点时x坐标的位置就知道了，y=x%i 中，这个坐标是i-1位置， y=(x-1)%i+1 中，这个坐标是i位置，所以是向右平移了一位，而在最后这个函数图像中，这个坐标是i-s位置，所以是向左平移了S位，上下没有变化；

<br/>

所以最终的函数就是： 旧 = ( 新-1+s ) % i +1

{% asset_img picture19.jpg %}

<br/>

根据这两个公式，我们可以推出 旧编号 和 新编号 之间的 对应关系，如下图所示，在 旧 = ( 新-1+s ) % i +1 中，只有 s 是未知的，而s就是被杀掉的节点的编号，也就是 s=(m-1)%i+1，其中m是每次杀人时报的数字，把s 带入 旧 = ( 新-1+s ) % i +1 中，得出新的公式，在新的公式中 参数 就只有m和i，m是固定不变的，i是每次传的长度，就得到了新旧编号之间的对应关系，

i=1时不用求旧编号，直接作为basecase，返回给i=2时公式中的新编号即可；

{% asset_img picture20.jpg %}

<br/>

最终的公式

旧 = ( 新 + m - 1 ) % i + 1

<br/>

推倒最终公式的过程

{% asset_img picture21.jpg %}

<br/>

得到这个公式之后，就先算i=2时的旧编号，此时新编号是i=1时的编号，就是1，代入旧 = ( 1 + m - 1 ) % 2 + 1 公式中，求出i=2时的旧编号，然后求i=3时的旧编号，此时i=2求出来的旧编号是作为i=3时的新编号的，所以代入旧 = ( 1 + m - 1 ) % 2 + 1 公式中，求出i=3时的旧编号，然后按照这个过程一直往上求，直到最后，求出这个最终存活的节点在原始链表中的编号；返回

<br/>

代码

```java
public class Code_06_JosephusProblem {

	public static class Node {
		public int value;
		public Node next;

		public Node(int data) {
			this.value = data;
		}
	}

	public static Node josephusKill1(Node head, int m) {
		if (head == null || head.next == head || m < 1) {
			return head;
		}
		Node last = head;
		while (last.next != head) {
			last = last.next;
		}
		int count = 0;
		while (head != last) {
			if (++count == m) {
				last.next = head.next;
				count = 0;
			} else {
				last = last.next;
			}
			head = last.next;
		}
		return head;
	}

	public static Node josephusKill2(Node head, int m) {
		if (head == null || head.next == head || m < 1) {
			return head;
		}
		Node cur = head.next;
		int tmp = 1; // tmp -> list size
		while (cur != head) {
			tmp++;
			cur = cur.next;
		}
		tmp = getLive(tmp, m); // tmp -> service node position
		while (--tmp != 0) {
			head = head.next;
		}
		head.next = head;
		return head;
	}

	/**
	 * 旧 = ( 新 + m - 1 ) % i + 1
	 * 长度为i，报到m 就杀人的时候，
	 * @return  最后存活节点的一开始的旧编号
	 */
	public static int getLive(int i, int m) {
		if (i == 1) {
			return 1; //长度为1，新编号肯定是1，basecase
		}
		//(getLive(i - 1, m)  i-1时的编号，
		return (getLive(i - 1, m) + m - 1) % i + 1;
	}

	public static void printCircularList(Node head) {
		if (head == null) {
			return;
		}
		System.out.print("Circular List: " + head.value + " ");
		Node cur = head.next;
		while (cur != head) {
			System.out.print(cur.value + " ");
			cur = cur.next;
		}
		System.out.println("-> " + head.value);
	}

	public static void main(String[] args) {
		Node head1 = new Node(1);
		head1.next = new Node(2);
		head1.next.next = new Node(3);
		head1.next.next.next = new Node(4);
		head1.next.next.next.next = new Node(5);
		head1.next.next.next.next.next = head1;
		printCircularList(head1);
		head1 = josephusKill1(head1, 3);
		printCircularList(head1);

		Node head2 = new Node(1);
		head2.next = new Node(2);
		head2.next.next = new Node(3);
		head2.next.next.next = new Node(4);
		head2.next.next.next.next = new Node(5);
		head2.next.next.next.next.next = head2;
		printCircularList(head2);
		head2 = josephusKill2(head2, 3);
		printCircularList(head2);
	}
}
```

<br/>

<br/>

### 题目：字符串匹配问题

注意：*号用 ! 替代了，因为markdown 会把星号解析

【题目】

给定字符串str，其中绝对不含有字符'.'和'!'。再给定字符串exp， 其中可以含有'.'或'!'，'!'字符不能是exp的首字符，并且任意两个 '!'字符不相邻。exp中的'.'代表任何一个字符，exp中的'!'表示'!' 的前一个字符可以有0个或者多个。请写一个函数，判断str是否能被 exp匹配。 

【举例】 

str="abc"，exp="abc"，返回true。 

str="abc"，exp="a.c"，exp中单个'.'可以代表任意字符，所以返回 true。 

str="abcd"，exp=".!"。exp中'!'的前一个字符是'.'，所以可表示任 意数量的'.'字符，当exp是"...."时与"abcd"匹配，返回true。 

str=""，exp="..*"。exp中'*'的前一个字符是'.'，可表示任意数量 的'.'字符，但是".!"之前还有一个'.'字符，该字符不受'!'的影响， 所以str起码有一个字符才能被exp匹配。所以返回false。

<br/>

<br/>

递归版本

递归函数：f(i,j)  ：代表str从i开始及其之后的字符，是否能被exp从j位置开始直到结束，这个子exp完全匹配；

! 这个字符比较特殊：

第一种情况，exp中j位置后面的字符不是 !，那么i位置字符和j位置要么一样，要么j位置字符为 . ，否则，直接返回false，因为这样不可能匹配到；如果i位置字符和j位置一样或者j位置字符为 . ，那么这个函数的返回值要看exp中j+1位置及其后面的字符能不能匹配到str中i+1及其后面的字符；

所以这种情况下 f(i,j)  依赖于 f(i+1,j+1)

<br/>

第二种情况， exp中j位置后面的字符是 !，比较麻烦，此时假设j位置和i位置不匹配，那么j+1位置的 ! 就要表示匹配0个j位置字符，然后再看j+2位置及其之后的字符能不能匹配i位置开始及其之后的字符，

所以这种情况下 f(i,j)  依赖于 f(i,j+2)

{% asset_img picture22.jpg %}

如果j位置和i位置可以匹配上， 就会产生很多分支，比如a! 匹配一个a，然后看j+2及之后位置是否能匹配i+1之后的位置，比如a! 匹配两个a，然后看j+2及之后位置是否能匹配i+2之后的位置，比如a! 匹配三个a，然后看j+2及之后位置是否能匹配i+3之后的位置，比如a! 匹配四个a，然后看j+2及之后位置是否能匹配i+4之后的位置，这个如果匹配不到，就说明真匹配不到，返回false；

所以这种情况下 f(i,j)  依赖于 多种情况，例如 f(i,j+2)：匹配0个a，f(i+1,j+2)：匹配一个a，f(i+2,j+2)：匹配两个a，等等，其中只要有一个返回true，结果就是true；

{% asset_img picture23.jpg %}

<br/>

dp版本

basecase 位置 最后一列

目标位置：f (0,0)

分析普遍位置，一个普遍位置(i,j)，需要依赖 (i+1,j+1)，和  横坐标为 i+2 的这一列。 

所以 如果要把整张表填完，就需要倒数两列和最后一排的位置，

当我们的basecase 不足以让我们把地基打完的时候，就要还原回原题意，把欠缺的位置继续填上。

<br/>

倒数第二列的意义：express剩下最后一个字符了，但是str还有字符，倒数第二列的最后一个值代表的是exp还剩下一个字符，str为空串，所以是 false，倒数第二列的倒数第二个值代表的意义是exp还剩下一个字符，str也还剩一个字符，此时需要看一下，这两个字符是否匹配，匹配这个值就是true，不匹配就是false。倒数第二列的其他位置的值表示的就是exp还剩下一个字符，str还剩不止一个字符，所以其他值都是false。

倒数第一行的意义是：str是空串，但是 exp 还有后缀，此时 就要看exp 字符的形式，如果是!a!b!c!a …的形式，那最后一行的格式就是false，true，false，true，false，true .....  如果中间某一个字符破坏了这种形式，那之后的值就就都是false，注意：! 一定要和一个字符配合才能匹配空串，只有  ！ 自己的话，是匹配不了的；

<br/>

代码

```java
public class Code_03_RegularExpressionMatch {

	public static boolean isValid(char[] s, char[] e) {
		for (int i = 0; i < s.length; i++) {
			if (s[i] == '*' || s[i] == '.') {
				return false;
			}
		}
		for (int i = 0; i < e.length; i++) {
			if (e[i] == '*' && (i == 0 || e[i - 1] == '*')) {
				return false;
			}
		}
		return true;
	}

	public static boolean isMatch(String str, String exp) {
		if (str == null || exp == null) {
			return false;
		}
		char[] s = str.toCharArray();
		char[] e = exp.toCharArray();
		return isValid(s, e) ? process(s, e, 0, 0) : false;
	}

	/**
	 * 暴力递归
	 * str[i,len(i)]这个字符串能不能被exp[j,len(exp)] 这个字符串，匹配出来
	 */
	public static boolean process(char[] str, char[] exp, int i, int j) {
		if (j == exp.length) { //j到了终止位置，后面什么都没有了，此时i及其之后的位置只能配 "" 空串了，
			return i == str.length; //如果exp耗尽了，那么只有str也耗尽了，才能返回true；
		}
		//j 上面还有字符，考察 j+1 的情况，也就是第一种情况
		if (j + 1 == exp.length || exp[j + 1] != '*') {
			//j上面还有字符，此时如果i已经到末尾了，直接返回false
			return i != str.length && (exp[j] == str[i] || exp[j] == '.')
					&& process(str, exp, i + 1, j + 1);
		}
		//exp[j + 1] 不仅有字符，而且还是 *
		//当i没到最后的情况下，而且i和j的字符还能配上，就走接下来的每一条路
		while (i != str.length && (exp[j] == str[i] || exp[j] == '.')) {
			if (process(str, exp, i, j + 2)) {
				return true;
			}
			i++;  // i++
		}
		return process(str, exp, i, j + 2);
	}

	public static boolean isMatchDP(String str, String exp) {
		if (str == null || exp == null) {
			return false;
		}
		char[] s = str.toCharArray();
		char[] e = exp.toCharArray();
		if (!isValid(s, e)) {
			return false;
		}
		boolean[][] dp = initDPMap(s, e); //填好最后两列和最后一行；
		for (int i = s.length - 1; i > -1; i--) {
			for (int j = e.length - 2; j > -1; j--) {
				if (e[j + 1] != '*') {
					dp[i][j] = (s[i] == e[j] || e[j] == '.')
							&& dp[i + 1][j + 1];
				} else {
					int si = i;
					while (si != s.length && (s[si] == e[j] || e[j] == '.')) {
						if (dp[si][j + 2]) {
							dp[i][j] = true;
							break;
						}
						si++;
					}
					if (dp[i][j] != true) {
						dp[i][j] = dp[si][j + 2];
					}
				}
			}
		}
		return dp[0][0];
	}

	public static boolean[][] initDPMap(char[] s, char[] e) {
		int slen = s.length;
		int elen = e.length;
		boolean[][] dp = new boolean[slen + 1][elen + 1];
		dp[slen][elen] = true;
		for (int j = elen - 2; j > -1; j = j - 2) {
			if (e[j] != '*' && e[j + 1] == '*') {
				dp[slen][j] = true;
			} else {
				break;
			}
		}
		if (slen > 0 && elen > 0) {
			if ((e[elen - 1] == '.' || s[slen - 1] == e[elen - 1])) {
				dp[slen - 1][elen - 1] = true;
			}
		}
		return dp;
	}

	public static void main(String[] args) {
		String str = "abcccdefg";
		String exp = "ab.*d.*e.*";
		System.out.println(isMatch(str, exp));
		System.out.println(isMatchDP(str, exp));
	}
}

```

