---
title: 深入理解java虚拟机
tags:
  - jvm
abbrlink: 5bedbc4e
date: 2019-05-05 13:38:10
---

-XX:+HeapDumpOnOutOfMemoryError 堆内存溢出时dump出一个快照文件，后续可以使用工具进行解析

-Xms20m

-Xmx20m

堆内存设置为20m

<br/>

jps：列出所有的java进程

jconsole：性能分析工具

<br/>

java 语言 -> java 编译器 -> class文件  -> java虚拟机

scala 语言 -> scala 编译器  -> class文件 -> java虚拟机

只是一些规范而已

<br/>

classic VM

第一款商用的虚拟机，只有纯解释器，如果想要编译，就必须外挂jit，但是会导致所有代码都要jit编译，不管这段代码有没有编译价值，这就是运行慢的原因；

<br/>

HotSpot VM

直到现在最常用的；

<br/>

<br/>

### 虚拟机内存管理

{% asset_img picture1.jpg %}

<br/>

#### 1.程序计数器

1. 是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器
2. 属于线程独占区
3. 如果线程执行的是java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址，如果正在执行的是native方法，这个计数器的值为undefined
4. 此区域是唯一一个在java虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域

<br/>

#### 2.虚拟机栈

1. 虚拟机栈描述的是**java 方法执行的动态内存模型**
2. 栈帧：**每个方法执行，都会创建一个栈帧**，创建完后，执行压栈，调用另外一个方法的时候，再压栈，执行完后依次出栈。伴随着方法从创建到执行完成，用于存储局部变量表，操作数栈，动态链接，方法出口等
3. 局部变量表：**存放编译期可知的各种基本数据类型**，**引用类型**，returnAddress类型；它的内存大小在编译期完成分配，当进入一个方法时，这个方法需要在栈帧中分配多少内存是固定的，在方法运行期间是不会改变局部变量表的大小的，因为引用类型存储的只是一个引用，真正的对象数据存放在堆中；
4. 栈的大小：栈是有大小的，如果一直堆栈，就会引发：**StackOverflowError**，栈溢出；例如：死递归

<br/>

#### 3.本地方法栈

1. 虚拟机栈为虚拟机执行 java 方法服务，本地方法栈为虚拟机执行 native 方法服务

<br/>

#### 4.java堆

1. 存放对象的实例
2. 垃圾收集器管理的主要区域
3. 新生代，老年代
4. OutOfMemory
5. -Xmx  -Xms   参数

<br/>

#### 5.方法区

1. 存储虚拟机加载的类信息（类的版本、字段、方法、接口等），常量，静态变量，即时编译器编译后的代码等数据；
2. 方法区和永久代（HotSpot使用永久代实现方法区，所以很多人把方法区称为永久代，这样的好处是虚拟机对方法区的垃圾收集可以像对堆进行垃圾收集一致；但是这只是针对HotSpot来讲的，对于其他的虚拟机并不是这样）这两者在虚拟机规范中并不等价；
3. 垃圾回收在方法区的行为：也会进行垃圾回收，但是效率很低，所以进行的会比较少；
4. 异常的定义：OutOfMemory

<br/>

<br/>

### 运行时常量池

属于方法区

存放编译器生成的**各种字面量以及符号引用**，这部分内容将在类加载后进入方法区的运行时常量池中存放

<br/>

代码

```java
public class Testc {

    public static void main(String[] args) {

        String s1 = "abc";
        String s2 = "abc";

        System.out.println(s1 == s2);   //true

        String s3 = new String("abc");

        System.out.println(s1 == s3);   //false
        
        System.out.println(s1 == s3.intern());  // true
    }
}
```

<br/>

分析

直接指定字符串，是放在运行时常量池中的，会维护一个类似HashSet的结构，所以不会有重复的，重复的都是指向的一个内存地址的，而new出来的对象实例，都是放在堆中的；

intern() 方法的作用把堆中的内存移动到常量池中，是一个native方法；

{% asset_img picture2.jpg %}

<br/>

<br/>

### 直接内存

堆外内存

不受制于java垃圾收集的管理；但是会受到操作系统物理内存的制约

<br/>

<br/>

### 对象的创建

1. new类名
2. 根据new的参数在常量池中定位一个类的符号引用
3. 如果没有找到这个符号引用，说明类还没有被加载，则进行类的加载，解析和初始化，
4. 虚拟机为对象分配内存（位于堆中）
5. 将分配的内存初始化为零值（不包括对象头）
6. 调用对象的<init> 方法：静态代码块，构造器等

<br/>

#### 给对象分配内存

1. 指针碰撞，假设已经使用的内存和未使用的内存是完全规整的两块区域，那么为对象分配内存的过程就是指针移动的过程
2. 空闲列表，大部分情况下，已经使用的内存和未使用的内存是不会完全规整的，此时就需要一张表，来记录哪些内存是空闲的，哪些是已经使用的，分配内存的时候，直接从表里查，然后再标记为已使用；

<br/>

**那到底使用哪种分配方式呢？**

使用哪种方式取决于内存是否规整，而内存的是否规整是取决于垃圾回收策略，如果垃圾回收器带有压缩整理的功能，在垃圾回收的时候，自动进行内存整理，此时就可以使用指针碰撞。如果垃圾回收器没有这个功能，就不能使用指针碰撞，必须使用空闲列表的方式

<br/>

#### 创建对象的线程安全性问题

1. 加锁，性能太低，每次创建对象都要等，在并发度很高时很影响效率
2. 本地线程分配缓冲(**TLAB**)：针对每个线程，在堆内存中，单独的分配一块区域，每个线程操作不同的区域，此时就不会产生线程安全的问题了；

{% asset_img picture3.jpg %}

<br/>

<br/>

### 对象的结构

#### header 对象头：就是对象的元数据

1. 自身运行时数据（Mark Word）

- 哈希值
- GC分代年龄：就是分了GC算法 ( 分代收集算法 ) 所服务的，
- 锁的状态标志
- 线程持有的锁
- 偏向线程ID
- 偏向时间戳

{% asset_img picture4.jpg %}

<br/>

2. 类型指针

对象指向类的元数据的一个指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，

<br/>

#### InstanceData

对象的实例信息，也就是我们在代码中所看到的类的有效信息 

<br/>

#### Padding

对齐填充，是一种占位符，这部分数据并不是特别存在的，也没有特别的含义，

hotspot 的自动内存管理系统要求对象的起始地址 必须是8个字节的整数倍，也就是说对象的大小必须是8个字节的整数倍；

<br/>

<br/>

### 对象的访问定位

也就是栈内存中的引用类型如何找到堆内存中的对象实例

hotspot使用的就是直接指针方法

<br/>

1. 直接指针

栈内存中的引用类型直接指向堆内存中的对象内存地址

2. 使用句柄

在堆内存中维护一个句柄池，句柄池中存放的是具体对象的内存地址，而栈内存中存放的是句柄池中的一个地址，通过句柄池获取对象实例的真实地址；

<br/>

使用句柄的好处是：如果堆内存中对象实例的地址发生变化了，栈内存中的数据不用变化，变化的只是句柄池中的地址；

<br/>

使用直接指针的好处是：效率很高，而且对象实例的访问定位频率是非常高的；

<br/>

{% asset_img picture5.jpg %}

<br/>

<br/>

### 垃圾回收

#### 如何判定对象为垃圾对象

1. 引用计数法

在对象中添加一个引用计数器，当有地方引用这个对象的时候，引用计数器的值就+1，当引用失效的时候，计数器的值就-1。但是这个方法在Java中基本不会使用，因为栈中可能有几块内存地址相互引用，但是栈中没有指向他们引用，此时是可以回收堆中的这些内存的，但是这个方法却不会回收，因为这几块内存地址的引用计数器并不为0。

{% asset_img picture6.jpg %}

<br/>

打印GC日志的vm参数

-verbose:gc 

-XX:+PrintGCDetails

<br/>

测试代码

```java
public class Test1 {
    Object inst;
    public Test1(){
        byte[] m = new byte[20 * 1024 * 1024];
    }
    public static void main(String[] args) {
        Test1 t1 = new Test1();
        Test1 t2 = new Test1();

        t1.inst = t2;
        t2.inst = t1;

        t1 = null;
        t2 = null;
        
        System.gc();
    }
}
```

<br/>

2. 可达性分析算法

**现在主流的垃圾收集器所使用的判定算法基本都是可达性分析算法**

<br/>

从 GCRoot 开始一直往下找，如果能找到这个对象实例，说明这个对象是活着的，如果从所有的GCRoot都找不到这个对象，就说明这个对象可以被回收了；

从 GCRoot 这个节点向下搜索，所走过的路径称为引用链，当一个对象对GCRoot这个节点，没有任何引用链相连接的时候，就认为这个对象是不可用的，是应该被回收的；

<br/>

作为 GCRoot 的对象

- 虚拟机栈（ 默认指的都是虚拟机栈 栈帧 中的局部变量表 ）
- 方法区的类属性所引用的对象；
- 方法区中常量所引用的对象；
- 本地方法栈中引用的对象；

<br/>

如果一个对象在这些 RCRoot 的引用链中找不到这个对象，说明是应该被回收的；

<br/>

#### 如何回收

1. 回收的策略

- 标记 - 清除算法

简单的分为 标记 和 清除 两个步骤，

效率不高，

空间问题：导致内存空间不连续，造成了内存浪费；

<br/>

- 复制算法

堆内存是垃圾回收主要关注的区域，所以又分为**新生代**和**老年代**，新生代是垃圾回收器主要关注的区域，所以新生代又分为三个区域：**eden区**，**survivor区**, 和 Tenured Gen ，一个对象刚被创建的时候进eden区，经历一次垃圾收集之后如果没有被回收，就进入survivor区，如果在survivor多次存活，说明优先级比较高，就进入Tenured Gen；

复制算法的原理就是把内存划分为两片区域，每次只使用一半，经历一次垃圾回收之后，要被回收的对象就被标记了，然后就把没有被回收的对象按照顺序拷贝到另一半内存中，然后使用这一半新内存分配新对象，把之前一半的对象数据全部清除，当经历下一次垃圾回收的时候，就把这一半新内存中没有被回收的对象拷贝回第一次回收之前使用的内一半内存，把当前使用的这一半新内存数据全部清除，重复此步骤即可；

解决了之前的内存空间不连续问题和效率问题，但是又引用了另一个问题，就是每次只使用一半内存，造成了极大的浪费，这也是我们把堆内存如上划分的原因，

将Heap 内存划分为新生代与老年代，又将新生代划分为Eden(伊甸园) 与2块Survivor Space(幸存者区) ,然后在Eden –>Survivor Space 以及From Survivor Space 与To Survivor Space 之间实行Copying 算法。 不过jvm在应用coping算法时，并不是把内存按照1:1来划分的，这样太浪费内存空间了。一般的jvm都是8:1。也即是说,Eden区:From区:To区域的比例是

> 8:1:1

始终有90%的空间是可以用来创建对象的,而剩下的10%用来存放回收后存活的对象。

{% asset_img picture7.jpg %}

1、当Eden区满的时候,会触发第一次young gc,把还活着的对象拷贝到Survivor From区；当Eden区再次触发young gc的时候,会扫描Eden区和From区域,对两个区域进行垃圾回收,经过这次回收后还存活的对象,则直接复制到To区域,并将Eden和From区域清空。 
2、当后续Eden又发生young gc的时候,会对Eden和To区域进行垃圾回收,存活的对象复制到From区域,并将Eden和To区域清空。 

3、可见部分对象会在From和To区域中复制来复制去,如此交换15次(由JVM参数**MaxTenuringThreshold**决定,这个参数默认是15),最终如果还是存活,就存入到老年代

<br/>

注意：当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。

内存的分配担保就好比我们去银行借款，如果我们信誉很好，在98%的情况下都能按时偿还，于是银行可能会默认我们下一次也能按时按量的偿还贷款，只需要有一个担保人能保证，如果我不能还款时，可以从他的账户扣钱，那银行就认为没有风险了。内存的分配担保也一样，如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接用内存分配担保机制进入老年代。

<br/>

这个算法适用的情况是：每次存活的对象都比较少，小于10%，所以**只适用于新生代**；大于10%，就需要进行内存担保；

<br/>

- 标记 - 整理算法

主要是针对老年代的对象进行回收的，针对的情况就是：回收的效率不高，垃圾较少的情况。

**标记：它的第一个阶段与标记/清除算法是一模一样的，均是遍历GC Roots，然后将存活的对象标记。**

**整理：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。因此，第二阶段才称为整理阶段。**

一次GC完毕之后，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。

不难看出，**标记/整理算法不仅可以弥补标记/清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价**，可谓是一举两得，一箭双雕，一石两鸟

不过任何算法都会有其缺点，**标记/整理算法唯一的缺点就是效率也不高**，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法。

<br/>

- 分代收集算法

并不是一个单独的算法，而是把标记整理算法和复制算法进行了一个结合，

根据新生代和老年代各自的特点，选择不同的垃圾回收算法；

新生代：复制算法

老年代：标记整理算法

<br/>

2. 垃圾回收器

- Serial

是一个针对新生代的垃圾收集器；

实现的算法就是复制算法；

最基本，历史最悠久的垃圾回收器，是单线程工作的；**需要停顿**

适用于桌面应用这种内存分配比较小的app，因为单线程工作，没有线程切换的开销，对于内存比较小的桌面应用，垃圾收集的速度是非常高的，停顿的时间非常短；

{% asset_img picture8.jpg %}

<br/>

- Parnew

是一个针对新生代的垃圾收集器；

实现的算法就是复制算法；

和 Serial 唯一的不同点就是停顿进行垃圾回收的时候，是多线程进行的；**也需要停顿**

比较适用于服务端等内存比较大的应用，如果内存比较小，可能线程切换的开销都大于了垃圾收集的开销，此时还是单线程收集效率比较高；

<br/>

- Parallel Scavenge 

是一个针对新生代的垃圾收集器；

实现的算法就是复制算法；

也是多线程进行回收的，**也需要停顿**

和Parnew 的不同点是: 

Parnew 关注的是最短停顿时间，比较适用于人机交互比较多的客户端，更短的停顿时间有利于用户体验

Parallel 关注的是可控制的吞吐量，比较适用于大型服务端项目，这种项目一般关注与高并发，高可用，吞吐量这样的整体性能指标；

吞吐量 = ( 执行用户代码时间 )  / ( 执行用户代码时间 + 垃圾回收所占用的时间 )，

有两个参数可以精确控制吞吐量

-XX:MaxGCPauseMillis    垃圾收集器停顿时间

-XX:GCTimeRatio    吞吐量大小 (0,100)，

<br/>

- Cms： concurrent  mark  Sweep

是一个针对老年代的垃圾收集器

也是多线程进行回收的，**也需要停顿**，但是这个多线程并发回收**指的是和用户的线程一起执行，边工作边回收**

 工作过程

1. 初始标记：只标记RCRoot直接引用的对象
2. 并发标记：继续往下标记
3. 重新标记：修正并发标记期间，因用户程序急需运作而产生变动的内部分标记记录，也就是针对并发标记进行一个修正；
4. 并发整理：和用户线程共同并发清除；

优点

1. 并发收集
2. 低停顿

缺点：

1. 占用大量的cpu资源
2. 无法处理浮动垃圾：打扫的过程中产生了新的垃圾，只能下次继续打扫了；
3. 出现Concurrent  Mode  Failure：在并发收集的过程中，需要指定一片内存区域，收集的过程中创建的对象，就往这个内存结构中扔，如果这个区域指定的过小，存不下了，就会报这个错误，出现这个错误的时候，就会调用一个Serial收集器，开始收集，更加浪费时间；
4. 出现空间碎片

{% asset_img picture9.jpg %}

<br/>

- G1

优势

1. 并行和并发：充分利用多核CPU的优势，减少停顿时间，
2. 分代收集：分为一个一个的region(单独的内存区域)，而不是新生代和老年代，用一张表给每个region打分，分数越高说明回收效率越高， 
3. 空间的整合：回收算法类似**标记整理**，所以不会产生空间碎片，
4. 可预测的停顿：

与cms的比较

1. 在提高吞吐量上，和cms差不多；
2. 在减少停顿方面，g1比cms要强大很多； 

步骤：

1. 初始标记
2. 并发标记
3. 最终标记
4. 筛选回收：通过Remember Set 一张表，记录对象之间的引用关系，这样在使用可达性分析法判断对象是否应该被回收的时候，就不用使用类似dfs 的方式扫描整个内存，只用遍历单个region就可以，然后再结合Remember Set 这张表记录的引用信息，就可以标记好要回收的对象了，

{% asset_img picture10.jpg %}

<br/>

<br/>

### 内存分配策略

1. 优先分配到eden，如果eden区不够用了，就会向老年代借，这就是内存分配担保

2. 大对象直接分配到老年代    -XX:PretenureSizeThreshold，因为新生代gc频率高，而且采用复制算法

3. 长期存活的对象分配到老年代   -XX:MaxTenuringThreshold   jdk6是新生代复制一次，年龄+1

4. 空间分配担保     -XX:+HandlePromotionFailure

   先检查是否能容纳此时新生代的所有对象，可以容纳的话检查内个参数是否开启，不够容纳的话，还会验证老年代最大的可用连续空间是否大于历次晋升到老年代的平均大小，如果大于，也是可以分配的，否则失败；

5. 动态对象年龄判断

<br/>

<br/>

### 逃逸分析与栈上分配

- 栈上分配

对象随着栈帧出栈而直接从内存中释放，不需要垃圾收集器的介入了，效率会有很大提高，那什么样的对象可以被分配到栈上呢？

<br/>

- 逃逸分析

筛选出未发生逃逸的对象，然后把没有发生逃逸的对象，在栈上进行分配

它的目标就是分析对象的作用域，在一个方法内声明的一个对象，没有外部引用，就说明这个对象不会发生逃逸现象，就可以被分配到栈上；

<br/>

<br/>

### 虚拟机工具

<br/>

#### jps

java process status

-l 显示主类，-m 显示附加参数， -v  显示虚拟机参数

<br/>

#### jstat

类装载，内存，垃圾收集，jit编译信息；

需要jsp的process id

<br/>

#### jinfo

实时查看和调整虚拟机的各项参数

<br/>

#### jmap

<br/>

#### jhat

Jvm heap analysis tools

一般不会再服务器上直接dump文件进行分析，而是会拷贝到本地进行分析

<br/>

#### jstack

用于生成虚拟机当前时刻的线程快照，也就是当前虚拟机内每一个线程正在执行的方法的堆栈的集合，只要目的就是定位线程长时间停顿的原因；

<br/>

#### jconsole

内存监控

线程监控

死锁

<br/>

#### visualVM

<br/>

<br/>

### 性能调优案例

知识

工具

数据

经验

<br/>

#### 案例一

场景：

绩效考核系统，会针对每个考核员工，生成一个各考核点的考核结果，形成Excel文档，供用户下载，文档中包含用户提交的考核点信息以及分析信息。Excel文档由用户请求的时候生成，下载，并保存到内存服务器一份

<br/>

环境

2个cpu，64G内存，centos，Tomcat7.0，jdk7

<br/>

查询的使用使用了redis缓存，资源很充裕，于是堆指定了50G内存。

<br/>

问题

经常有用户访问长时间出现卡顿现象

<br/>

处理思路

1. 优化sql，建索引，但是并不是某个功能变慢了，而是某个不固定的时间段卡顿，
2. 监控线程CPU，没问题，
3. 于是监控内存，内存使用量正常，但是经常发生Full GC，而且每次Full GC时间很长，每次会持续20到30s，这就是卡顿的原因，而频繁Full GC的原因就是各项指标和老师join之后，在内存中的对象太大，直接放到了老年代，而且项目使用的时间点都是某个固定的时间段 ( 学期末 ) 所有人都同时在用；造成了频繁full gc的现象，又因为堆内存设置的很大，所以导致full gc 的时间很长；

<br/>

解决方案

单纯把堆内存减小，就造成了资源的浪费，所以可以部署多个web容器，每个web容器的堆内存制定为4G，也就是单机的tomcat集群，前端加一个nginx，负载策略采用ip哈希的方式，也没有使用redis做session的共享，

<br/>

#### 案例2

场景：

简单数据抓取系统，抓取网站上的一些数据，分发给其他应用

<br/>

环境：

windows server

jdk5

2G内存

i3

<br/>

问题

不定期内存溢出，把堆内存加大也无济于事，导出堆转储快照信息，没有任何信息，内存监控也正常；

<br/>

处理思路

换机器，换到一台win7 8G内存上，问题没有再出现，监控捕获堆栈信息，发现bytebuffer 错误，程序中使用了很多的nio，它会申请很多堆外内存，所以定位问题是堆外内存溢出，把堆外内存地址调大，问题解决；

<br/>

<br/>

### class 文件

<br/>

#### 结构

class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在Class文件之中，中间没有添加任何分隔符，整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在

当遇到8位字节以上的空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储

Class文件中有两种数据类型，分别是无符号数和表（无符号数可以理解为基本数据类型，表可以理解为引用数据类型，其中可以包括基本数据类型和引用数据类型）

<br/>

#### 魔数

开头的四个字节，表明是一个java程序

<br/>

#### class文件版本

魔数后面四个字节表示版本

<br/>

#### 常量池

存放各种变量，类信息等等，是可变长度的，所以前两个字节表示常量池占用的长度

<br/>

#### 访问标志

两个字节，标识public、final、super、interface、enum 等关键字

interface 会默认加上abstract

<br/>

#### 类索引，父类索引，接口索引集合

类索引和父类索引用两个字节表示，表示引用常量池哪个位置的变量；

接口索引前两个字节表示长度，后面的字节表示引用常量池哪个位置的变量；

<br/>

#### 字段表集合

用于描述接口或者类中声明的变量，

两个字节表示长度，两个字节表示访问标志，两个字节表示字段名称，指向常量池的哪个位置的变量，两个字节表示数据类型，也代表指向常量池的哪个位置的变量，两个字节表示属性表数量，

<br/>

常量池中Ljava.lang.Object   L表示引用类型，Object 表示引用的类

[Ljava.lang.Object ，[表示数组，L表示数组中是引用类型，Object 表示引用的类

<br/>

#### 方法表集合

长度最少是一，因为默认会添加上空参构造器，说明这件事在编译阶段就做了，

两个字节表示长度（最少是1），两个字节表示访问标志，两个字节表示方法名称，指向常量池的哪个位置的变量，两个字节表示字段描述符和方法描述符（例如：(II)I 就表示两个int类型的参数，返回值是int类型 ），

<br/>

还有几个字节表示属性表集合，其中方法体的内容在属性表的code域中定义；

<br/>

#### 属性表集合

类似于这样的数据库表设计，动态增加一些字段，也就是描述额外的属性的，例如方法表中的方法体，就是借用属性表描述的。

{% asset_img picture11.jpg %}

<br/>

两个字节的名称，引用常量池中的变量位置，四个字节的长度，后面表示表的具体内容，

<br/>

<br/>

### 字节码指令

方法体中的运行过程会翻译为字节码指令，jvm只能读取字节码指令；

java虚拟机的指令由一个字节长度的，代表着某种特定操作含义的数字，称之为操作码，以及跟随其后的零至多个代表此操作所需参数的操作数而构成，

操作码的长度为1个字节，因此最大只有256条，

基于栈的指令集架(区别去基于寄存器的指令集架构)

<br/>

#### 字节码与数据类型

在虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息

iload  把局部变量表中的数据加载到栈中，第一个i表示int类型，fload

也有不包含类型信息的，例如goto，ArrayLength，

<br/>

#### 加载与存储指令

加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输

将局部变量表加载到操作数栈：iload，lload，fload，dload，aload

将一个数值从操作数栈存储到局部变量表，istore，ifda

将一个数值加载到操作数栈，bipush，sipush，ldc，ldc_w，ldc2_w，aconst_null，iconst_m1，iconst

扩充局部变量表的访问索引的指令：wide

<br/>

#### 运算指令

运算或算术指令用于对两个操作数栈上的值进行某种特定的运算，并把结果存储到操作数栈顶

加法指令：add

减法指令：sub

乘法指令：mul

除法指令：div

取余指令：rem

取反指令：neg

<br/>

栈的深度最多为2

<br/>

#### 类型转换指令

可以将两种不同的数值类型进行相互转换，这些转换操作一般用于实现用户代码中的显示类型转换操作以及用来处理字节码指令集中的数据类型相关指令无法与数据类型一一对应的问题；

宽化类型处理（int  to long）和窄化类型处理 ( object  to user )，窄化可能出错

i2b、i2c、i2s、l2i（long转为int）。。。。

<br/>

一个内存越界问题：内存越界

原因我们看字节码文件的操作指令就可以看出，乘的时候都是按照int去计算的，然后最后转为long类型，所以内存越界了；

{% asset_img picture12.jpg %}

<br/>

#### 对象创建与访问指令

创建类实例的指令：new

创建数组的指令：newarray、anewarray、multianewarray

访问类字段：getfield、putfield、getstatic、putstatic

把数组元素加载到操作数栈的指令：baload、csllfda、

把操作数栈的值存储到数组元素：astore

取数组长度的指令：arraylength

检查实例类型的指令：instanceof checkcast

<br/>

#### 操作数栈管理指令

操作数栈指令用于直接操作操作数栈

将操作数栈的一个或两个元素出栈，pop  pop2

复制栈顶一个或两个数组并将复制或双份复制值重新压入栈顶，dup  dup2，dup_x1，dup_x2

将栈顶的两个数值替换   swap

<br/>

#### 控制转移指令

可以让java虚拟机有条件或无条件的从指定的位置指令而不是控制转移指令的下一条指令继续执行程序，可以认为控制转移指令就是在修改pc寄存器的值；

条件分治：ifeq、iflt、ifle、ifne、ifgt、ifnull、ifcmple

复合条件分支：tableswith、lookupswitch

无条件分支：goto、goto_w、jsr、jsr_w、ret

<br/>

#### 方法调用指令

invokevirtual指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是java语言中最常见的方法分派方式

invokeinterface指令用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用

invokespecial指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法，私有方法和父类方法

invokestatic指令用于调用类方法（static方法）

<br/>

**为什么要方法的调用要分为这么多指令呢？**

<br/>

#### 方法的返回指令

方法的调用指令与数据类型无关，而方法返回指令则是根据返回值的类型区分的，包括有ireturn（当返回值是boolean、byte、char、short和int类型时使用），lreturn、freturn、dreturn和areturn，另外还有一条return指令供声明为void的方法、实例初始化方法、类和接口的类初始化方法使用

<br/>

#### 异常处理指令

在程序中显示抛出异常的操作会由athrow指令实现，除了这种情况，还有别的异常会在其他java虚拟机指令检测到异常状况时由虚拟机自动抛出

<br/>

**程序中使用大量 try-catch 是否会影响性能？**

jdk早期可能会影响，但是较新的版本都完全不会影响性能，因为早期的jdk是使用专门的字节码指令处理try-catch的，较新的版本都是用 Exception table 指令来处理异常的，如果不发生异常，和不用 try-catch 翻译完的字节码是一样的，

{% asset_img picture13.jpg %}

<br/>

#### 同步指令

java虚拟机的指令集中有monitorcenter和monitorexit两条指令来支持synchronized关键字的语义；

<br/>

<br/>

### 类加载机制

虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的java类型，这就是虚拟机的类加载机制；

懒加载

<br/>

整体流程

{% asset_img picture14.jpg %}

<br/>

#### 类加载的时机

<br/>

加载(装载)、验证、准备、解析、初始化和卸载这五个阶段顺序是固定的，类的加载过程必须按照这种顺序开始，而解析阶段不一定；它在某些情况下可以在初始化之后再开始，这是为了**运行时动态绑定特性**。值得注意的是：这些阶段通常都是互相交叉的混合式进行的，通常会在一个阶段执行的过程中调用或激活另外一个阶段。

初始化时机：

1. 遇到new、getstatic、putstatic、或invokestatic这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化，生成这四条指令的最常见的java代码是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段的时候（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候，
2. 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化
3. 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化
4. 当虚拟机启动时，用户需要指定一个要执行的主类（ 包含main方法的内个类），虚拟机会先初始化这个主类

<br/>

不被初始化的例子

1. 直接引用父类的静态字段，子类是不会被初始化的
2. 通过数组定义引用类
3. 调用类的常量

<br/>

#### 类加载的过程 - 加载

- 通过类的全限定名来获取定义此类的二进制流
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构，
- 在内存中生成一个代表这个类的Class对象，作为这个类的各种数据的访问入口，这个Class对象的存放位置在不同的虚拟机实现上是不同的，在hotspot中，是存放在方法区中的；

<br/>

加载源

1. 文件：class文件，jar文件
2. 网络
3. 计算生成一个二进制流，$Proxy ，动态代理
4. 由其他文件生成，jsp
5. 数据库

<br/>

#### 类加载的过程 - 验证

验证是连接的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全

1. 文件格式校验，验证class文件格式规范，例如： class文件是否已魔术0xCAFEBABE开头 ， 主、次版本号是否在当前虚拟机处理范围之内等
2. 元数据校验，这个阶段是对字节码描述的信息进行语义分析，以保证起描述的信息符合java语言规范要求。验证点可能包括：这个类是否有父类(除了java.lang.Object之外，所有的类都应当有父类)、这个类是否继承了不允许被继承的类(被final修饰的)、如果这个类的父类是抽象类，是否实现了起父类或接口中要求实现的所有方法。
3. 字节码验证，进行数据流和控制流分析，这个阶段对类的方法体进行校验分析，这个阶段的任务是保证被校验类的方法在运行时不会做出危害虚拟机安全的行为.如：保证访法体中的类型转换有效，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但不能把一个父类对象赋值给子类数据类型、保证跳转命令不会跳转到方法体以外的字节码命令上。
4. 符号引用校验，符号引用中通过字符串描述的全限定名是否能找到对应的类、符号引用类中的类，字段和方法的访问性(private、protected、public、default)是否可被当前类访问。

<br/>

#### 类加载的过程 - 准备

准备阶段正式为**类变量**（被static修饰的变量）分配内存并设置**变量的初始值**（默认值），这些变量使用的内存都将在方法区中进行分配；

但是如果被final修饰，那么在这个过程中，用户设置的常量值会被一同指定；

<br/>

#### 类加载的过程 - 解析

解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程

类或者接口的解析：

字段解析：首先解析出类的方法表的class_index项中索引的字段所属的类或接口的符号引用，然后继续搜索：先在类本身中查找字段，再在类的实现的接口中查找字段，然后在类的父类中查找字段，否则，查找失败

类方法解析：首先解析出类的方法表的class_index项中索引的方法所属的类或接口的符号引用，然后继续搜索，类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的是个接口，直接报错。在类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有直接返回，在类实现的父类中查找是否有简单名称和描述符都与目标相匹配的方法，如果有直接返回，在类实现的接口列表及他们的父接口中查找是否有简单名称和描述符都与目标相匹配的方法，如果有直接报错，否则，查找失败，

接口方法解析：首先解析出类的方法表的class_index项中索引的方法所属的类或接口的符号引用。正好与接口相反。

<br/>

直接引用

直接引用可以是直接指向目标对象的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机内存布局实现相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同，如果有了直接引用，那引用的目标必定已经在内存中存在。

<br/>

符号引用

符号引用是一组符号来描述所引用的目标对象，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标对象并不一定已经加载到内存中。

<br/>

虚拟机规范并没有规定解析阶段发生的具体时间，只要求了在执行anewarry、checkcast、getfield、instanceof、invokeinterface、invokespecial、invokestatic、invokevirtual、multianewarray、new、putfield和putstatic这13个用于操作符号引用的字节码指令之前，先对它们使用的符号引用进行解析，所以虚拟机实现会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。

<br/>

#### 类加载的过程 - 初始化

​	类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码（或者说是字节码）。

​        在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程。

​        <clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在他之后的变量，在前面的静态语句块可以赋值，但是不能访问，如下面代码示例。

```java
public class Test {
    static {
        i = 0;  //  给变量复制可以正常编译通过
        System.out.print(i);  // 这句编译器会提示“非法向前引用”  
    }
    static int i = 1;
}
```

 <clinit>()方法与类的构造函数（或者说实例构造器<init>()）不同，他不需要显示的调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。因此在虚拟机中第一个被执行的<clinit>()方法的类肯定是java.lang.Object。

​        由于父类的<client>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作，如下面代码示例中，字段B的值将会是2而不是1。

```java
static class Parent {
        public static int A = 1;
        static {
            A = 2;
        }
}

static class Sub extends Parent {
        public static int B = A;
}

public static void main(String[] args) {
        System.out.println(Sub.B);
}
```

<br/>

 <clinit>()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。

​        接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。

​        虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。下面代码示例演示了这种场景。

```java
static class DeadLoopClass {
    static {
        // 如果不加上这个if语句，编译器将提示“Initializer does not complete normally”并拒绝编译
        if (true) {
            System.out.println(Thread.currentThread() + "init DeadLoopClass");
            while (true) {
            }
        }
    }
}

public static void main(String[] args) {
    Runnable script = new Runnable() {
        public void run() {
            System.out.println(Thread.currentThread() + "start");
            DeadLoopClass dlc = new DeadLoopClass();
            System.out.println(Thread.currentThread() + " run over");
        }
    };

    Thread thread1 = new Thread(script);
    Thread thread2 = new Thread(script);
    thread1.start();
    thread2.start();
}
```

<br/>

#### 类加载器 

虚拟机的设计团队把类加载阶段中的 “ 通过一个类的全限定名来获取描述此类的二进制字节流 ”，这个动作放到java虚拟机外部去执行，一遍让应用程序自己决定如何去获取所需要的类，实现这个动作的代码模块称之为类加载器，

只有被同一个类加载器加载的类才可能会相等，相同的字节码被不同的类加载器加载的类不相等；

<br/>

分类：

- 启动类加载器

由c++实现，是虚拟机的一部分，用于加载javahome下的lib目录下的类

- 扩展类加载器

加载javahome下 /lib/ext   目录中的类

- 应用程序类加载器  / 系统类加载器

加载用户类路径上的所指定的类库

- 自定义类加载器

定义一个类，继承classloader；重写loadclass方法；实例化Class对象

<br/>

优势

1. 类加载器是java语言的一项创新，也是java语言流行的重要原因之一，它最初的设计是为了满足java Applet的需求而开发出来的，
2. 高度的灵活性
3. 通过自定义类加载器可以实现热部署
4. 代码加密

<br/>

#### 双亲委派模型

这么多类加载器是如何协同工作的？

从jdk1.2开始，java虚拟机规范推荐开发者使用双亲委派模型进行类加载，其加载过程如下

1. 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器去执行
2. 每一层的类加载器都把类加载请求委派给父类加载器，直到所有的类加载请求都应该传递给底层的启动类加载器
3. 如果顶层的启动类加载器无法完成加载请求，子类加载器尝试去加载，如果连最初发起类加载请求的类加载器也无法完成加载请求时，将会抛出classnotfoundexception，而不再调用其子类加载器去进行类加载，
4. 双亲委派模型的类加载机制的优点是java类和它的类加载器一起具备了一种带优先级的层次关系，越是基础的类，越是被上层的类加载器进行加载，保证了java程序的稳定运行；

<br/>

<br/>

### 虚拟机字节码执行引擎

<br/>

#### 运行时栈帧结构

##### 1. 局部变量表

每一个变量都会储存在Slot中，64位机器的Slot占64位，32位机器的Slot占32位，每个Slot都可以存储java数据类型和引用类型。

局部变量表的第0位默认是调用此方法的实例对象的引用，也就是this。其他参数按照顺序，占用从1开始的Slot。

为了节省栈帧空间，局部变量中的**Slot是可以重用的**，因为作用域不一定覆盖整个方法体。

对于局部变量表中变量的初始化，它不像类变量(static修饰)在类加载过程中的 “准备” 和 “初始化” 两次初始化，而是如果没初始化就不能使用。例如

```java
class A {
    public static int a;
    public void haha {
        int b;
        System.out.printf(a);//1
        System.out.printf(b);//2
    }
}
```

//1编译通过而//2编译错误。

<br/>

##### 2.操作数栈

当一个方法开始执行的时候，不同于局部变量表从一开始分配好内存， 操作数栈一开始是空的，执行过程中，会有很多字节码指令往操作数栈中写入和提取内容，也就是执行入栈，出栈操作。例如加法操作就是通过操作数栈来进行的。

在概念模型中，两个栈帧是互相独立的，但是在大多数情况下都会做一些优化。

{% asset_img picture15.jpg %}

<br/>

可以看的出来，下面的栈帧的部分操作数栈与上面的局部表重叠在一起。这也很容易理解，例如：

```java
class A {
    main方法{
        int a = 1;
        int b = 2;
        int c = add(a , b);  //执行到这里
    }

    public func int add(int a , int b){
        return a + b;
    }
}
```

<br/>

<br/>

##### 3. 动态链接

每个栈帧中都包含一个指向运行时常量池中该栈帧中所属方法的引用，持有这个引用是为了支持动态连接。

动态连接是什么？ 

Class常量池中有很多符号引用，一部分 符号引用 会在类加载过程中转化成直接引用，叫做静态解析，另一部分会在运行时转化成直接引用，叫做动态引用。静态解析的函数类型有静态方法，构造函数，父类方法，私有方法等是“不可修改”的函数。

<br/>

##### 4. 方法返回地址

退出方法有两种形式，正常退出和异常退出。 
正常退出的情况下，方法会返回字节码命令(可能包含返回值)给调用者。而且返回地址是调用函数的PC计数器的值。 
异常退出的情况下，是不会给调用者返回任何返回值的，而且，返回地址是要通过异常处理器来确定的。

因此，方法正常退出时，把返回值压入调用者栈帧的操作数栈中，然后调整PC计数器的值指向下一条命令。异常退出是恢复上层方法中的局部变量表和操作数栈。

<br/>

#### 方法的调用

##### 1. 解析调用

方法调用并不等于方法的执行，方法调用阶段的唯一任务就是确定被调用方法的版本（继承，多态中可能会有多个方法的版本）

解析调用指的就是只有一个版本的方法的调用，这类方法指的就是一些 “ 不可修改的 ” 的方法，也就是在编译阶段就能完全确定的方法的版本，例如：静态方法，构造器方法，私有方法，final修饰的方法；

对应到字节码指令中可能是：

invokestatic

Invokespecial

<br/>

##### 2. 静态分派调用

这里所谓的分派指的是在Java中对方法的调用。Java中有三大特性：封装、继承和多态。分派是多态性的体现，Java虚拟机底层提供了我们开发中“重写”和“重载”的底层实现。其中重载属于静态分派，而重写则是动态分派的过程。除了使用分派的方式对方法进行调用之外，还可以使用解析调用，解析调用是在编译期间就已经确定了，在类装载的解析阶段就会把符号引用转化为直接引用，不会延迟到运行期间再去完成。而分派调用则既可以是静态的也可以是动态（就是这里的静态分派和动态分派）的。

静态分派只会涉及重载，而重载是在编译期间确定的，那么静态分派自然是一个静态的过程（因为还没有涉及到Java虚拟机）。静态分派的最直接的解释是**在重载的时候是通过参数的静态类型而不是实际类型作为判断依据的**。比如创建一个类O，在O中创建了静态类内部类A，O中又有两个静态类内部类B、C继承了这个静态内部类A，那么实际上当编写如下的代码：

```java
public class O{
    static class A{}
    static class B extends A{}
    static class C extends A{}
    public void a(A a){
        System.out.println("A method");
    }
    public void a(B b){
        System.out.println("B method");
    }
    public void a(C c){
        System.out.println("C method");
    }
    public static void main(String[] args){
        O o = new O();
        A b = new B();
        A c = new C();
        o.a(b);
        o.a(c);
    }
}
```

<br/>

运行的结果是打印出连个“A method”。原因在于静态类型的变化仅仅在使用时发生，变量本身的类型不会发生变化。比如我们这里中A b = new B();虽然在创建的时候是B的对象，但是当调用o.a(b)的时候才发现是A的对象，所以会输出“A method”。**也就是说在发生重载的时候，Java虚拟机是通过参数的静态类型而不是实际参数类型作为判断依据的**。因此，在编译阶段，Javac编译器选择了a(A a)这个重载方法。

虽然编译器能够在编译阶段确定方法的版本，但是很多情况下重载的版本不是唯一的，在这种模糊的情况下，编译器会选择一个更合适的版本。

<br/>

##### 3. 动态分派调用

动态分派的一个最直接的例子是重写。对于重写，我们已经很熟悉了，那么Java虚拟机是如何在程序运行期间确定方法的执行版本的呢？

解释这个现象，就不得不涉及Java虚拟机的invokevirtual指令了，这个指令的解析过程有助于我们更深刻理解重写的本质。该指令的具体解析过程如下：

1. 找到操作数栈栈顶的第一个元素所指向的对象的实际类型，记为C
2. 如果在类型C中找到与常量中描述符和简单名称都相符的方法，则进行访问权限的校验，如果通过则返回这个方法的直接引用，查找结束；如果不通过，则返回非法访问异常
3. 如果在类型C中没有找到，则按照继承关系从下到上依次对C的各个父类进行第2步的搜索和验证过程
4. 如果始终没有找到合适的方法，则抛出抽象方法错误的异常

从这个过程可以发现，在第一步的时候就在运行期确定接收对象（执行方法的所有者程称为接受者）的实际类型，所以当调用invokevirtual指令**就会把运行时常量池中符号引用解析为不同的直接引用**，这就是方法重写的本质。

<br/>

**虚拟机的实现**：

前面介绍的分派过程，作为对虚拟机概念模型的解析基本上已经足够了，它已经解决了虚拟机在分派中"会做什么"这个问题。

但是，虚拟机”具体是如何做到的“，可能各种虚拟机实现都会有些差别。

由于动态分派是非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法，因此虚拟机的实际实现中基于性能的考虑，大部分实现都不会真正的进行如此频繁的搜索。面对这种情况，最常用的”稳定优化“手段就是为类在方法区中建立一个**虚方法表**（Virtual Method Table，也称为vtable），使用虚方法表索引来代替元数据查找以提高性能。

{% asset_img picture16.jpg %}

虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都是指向父类的实际入口。如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实际版本的入口地址。

为了程序实现上的方便，具有相同签名的方法，在父类、子类的虚方法表中具有一样的索引序号，这样当类型变换时，仅仅需要变更查找的方法表，就可以从不同的虚方法表中按索引转换出所需要的入口地址。

方法表一般在类加载阶段的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。