---
title: 算法进阶第二课
categories:
  - leetcode
abbrlink: fdbf220
date: 2019-03-16 19:20:17
---

### 窗口内最大值的更新结构

窗口：L和R，都只能向右走，加数的时候R向右走，减数的时候L向右走，求一个窗口的最大值，如果遍历，每次都需要承担一个O(len) 的时间复杂度，要做的就是找到一种结构，可以更快的找到窗口内的最大值；

<br/>

双端队列结构：双向链表

不需要遍历，只需要从头部加减东西，从尾部加减东西，时间复杂度都是O(1)

我们需要保证从头部到尾部放的值是从大到小的；

加数的时候，从双端队列的尾部加入，如果原数组i位置上的数字是value，考察双端队列的尾部， value如果比尾部的值小，直接落在尾部后面，如果比尾部的值大，依次弹出尾部的值，直到value小于尾部某个值，或者弹到空；然后把新的数字从尾部插入；

{% asset_img picture1.jpg %}

减数的时候，L向右走，检查双端队列的头部的index过期还是没过期，这就是为什么双端队列中为什么要存储位置index和value的原因， 如果是过期的，从头部弹出，只要这一个更新逻辑；

{% asset_img picture2.jpg %}

<br/>

原因：

窗口内为什么要留着5，4，1，因为窗口内留着的所有值，是都有可能，当窗口缩减的时候，成为最大值的；

{% asset_img picture3.jpg %}

再缩的时候，1过期了，所以以1为index的4弹出了，此时窗口的最大值是1；

<br/>

那为什么当从尾部加数的时候，尾部比当前的value值小的时候，直接弹呢？因为被弹出的数，永远没有机会成为窗口内的最大值，因为窗口缩的时候，是先缩左，后缩右边的值的，而新进来的数，既值比你大，下标也比你晚过期， 所以直接弹出尾部的值即可；此时如果进来一个数，比之前的数都大，直接弹空即可，index又晚，值又大，没有必要留着之前的数字了；

{% asset_img picture4.jpg %}

<br/>

需要下标的原因：

{% asset_img picture5.jpg %}

此时双端队列内的值只有一个5，如果没有下标，当L往右边走的时候，没办法知道是0位置的5，还是4位置的5，必须需要下标，因为我们需要知道那个数字是过期的，要被从头部弹出的；

其实双端队列的存的值可以只是存下标，因为对应index的值是可以直接通过arr[index] 得到的；

<br/>

### 题目

有一个整形数组 arr 和一个大小为 w 的窗口从数组的最左边滑到最右边，窗口每次向右边滑动一个位置。

例如，数组为 {4,3,5,4,3,3,6,7}，窗口大小为3时：

　　[4 3 5] 4 3 3 6 7              窗口中的最大值为5 

　　4 [3 5 4] 3 3 6 7              窗口中的最大值为5

　　4 3 [5 4 3] 3 6 7              窗口中的最大值为5

　　4 3 5 [4 3 3] 6 7              窗口中的最大值为4

　　4 3 5 4 [3 3 6] 7              窗口中的最大值为6

　　4 3 5 4 3 [3 6 7]              窗口中的最大值为7

如果数组长度为 n，窗口大小为 w，则一共产生 n-w+1 个窗口的最大值。

请实现一个函数：

输入：整型数组 arr，数组大小 len，窗口大小 w。

输出：一个长度为 n-w+1 的数组 res，res[i]表示每一种窗口状态下的最大值。

<br/>

代码

```java
public class Code01_SlidingWindowMaxArray {

    public static int[] getMaxWindow(int[] arr, int w) {//w窗口大小
        if (arr == null || w < 1 || arr.length < w) {
            return null;
        }
        LinkedList<Integer> qmax = new LinkedList<Integer>();  // 只存下标
        int[] res = new int[arr.length - w + 1];//总共收集的结果
        int index = 0;//res[index]写入index
        for (int i = 0; i < arr.length; i++) {//i表示窗口R
            //准备存入i位置的arr[i]
            while (!qmax.isEmpty() && arr[qmax.peekLast()] <= arr[i]) {  //尾部的值小于等于当前值；
                qmax.pollLast();//就从尾部弹出，
            }
            qmax.addLast(i);    //加入arr[i]到尾部
            if (qmax.peekFirst() == i - w) {//如果头部已经要过期了  i - w表示过期的下标
                qmax.pollFirst();//如果已经到窗口极限了，弹出头部，L开始右移动
            }
            if (i >= w - 1) {//当窗口已经形成了，记录每一步的res
                res[index++] = arr[qmax.peekFirst()];
            }
        }
        return res;
    }
    // for test
    public static void printArray(int[] arr) {
        for (int i = 0; i != arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        int[] arr = {4, 3, 5, 4, 3, 3, 6, 7};
        int w = 3;
        printArray(getMaxWindow(arr, w));
    }
}
```

<br/>

时间复杂度

如果窗口从左边滑到最右边，时间复杂度是O(N)，

因为每个值都只是进队列一次，出队列一次；

<br/>

### 题目：最大值减去最小值小于或等于num的子数组数量

描述：给定数组arr和整数num，共返回有多少个子数组满足如下情况：

max(arr[i....j])-min(arr[i....j])<=num

max(arr[i...j])表示子数组arr[i...j]中的最大值，min(arr[i...j])表示子数组arr[i...j]中的最小值。

要求：如果数组长度为N，请实现时间复杂度为O(N)的解法

<br/>

一共多少个子数组？

0开头：N个，1开头：N-1个，2开头：N-2个。。。。 等差数列

数量级 O(N^2)

<br/>

普通的解法：

找到arr的所有子数组，一共有O(N^2)个，然后对每一个子数组做遍历找到其中的最小值和最大值。这个过程时间复杂度为O(N)，然后看看这个子数组是否满足条件。统计所有满足的子数组数量即可。普通解法的容易实现，但是时间复杂度为O(N^3)。

<br/>

O(N)的解法：

如果一个子数组达标了，那么这个子数组中的任意一个子数组都达标，原因：

{% asset_img picture6.jpg %}

<br/>

如果一个子数组不达标，那么这个子数组再往外扩，也不会达标，

{% asset_img picture7.jpg %}

<br/>

一开始，就让L停留在0位置，R开始往右边扩，假设R扩到x位置，再往下扩一个，就开始不达标了，R停止， 此时这个窗口内的最大值可以用窗口内最大值的更新结构得到， 窗口内的最小值可以再用一个双端队列求出一个窗口内最小值的更新结构得到，由此可以非常快的得到一个窗口内的最大值和最小值，所以可以判断R什么时候停止，此时必须以0开头的子数组(符合条件的)总共x+1个，一下就找出了x+1个符合条件的数组，此时，我们就找到了以0开头的所有符合条件的子数组达标的数量(x+1)，因为0到x+1已经不符合条件了，之后的肯定更不符合条件；

接下来。L缩一个位置，窗口内的最大值和最小值都更新一下，因为L缩了一个，所以此时R有可能继续往右边扩了，假设又扩到一个位置，此时以1开头的所有符合条件的子数组也就都一次性得到了；

于是，这道题变成了L每往左缩一下，R就往右走，L每往左缩一下，R就往右走，这样一个结构，一直到把每个数字开头的值的子数组都找到；

L只往右走，不回退，R只往右走，不回退，扫过的就是数组中所有的数，

时间复杂度 O(N)；

{% asset_img picture8.jpg %}

<br/>

代码：

```java
public class Code_03_AllLessNumSubArray {

    public static int getNum(int[] arr, int num) {
        if (arr == null || arr.length == 0) {
            return 0;
        }
        LinkedList<Integer> qmin = new LinkedList<Integer>(); // 最小值更新结构
        LinkedList<Integer> qmax = new LinkedList<Integer>(); // 最大值更新结构
        int start = 0;
        int end = 0;
        int res = 0;
        while (start < arr.length) {	//i是开头

            //while循环的作用：start固定，end扩到不能再扩了，停；
            while (end < arr.length) {//j是窗口最右侧位置，再往右一个
                while (!qmin.isEmpty() && arr[qmin.peekLast()] >= arr[end]) {  //最小值结构更新
                    qmin.pollLast();
                }
                qmin.addLast(end);
                while (!qmax.isEmpty() && arr[qmax.peekLast()] <= arr[end]) {  //最大值结构更新
                    qmax.pollLast();
                }
                qmax.addLast(end);
                if (arr[qmax.getFirst()] - arr[qmin.getFirst()] > num) {
                    break;  // 不达标就break
                }
                end++;
            }

            if (qmin.peekFirst() == start) { //最小值的更新结构看看有没有过期
                qmin.pollFirst();
            }
            if (qmax.peekFirst() == start) { //最大值的更新结构看看有没有过期
                qmax.pollFirst();
            }
            res += end - start; //一次性获得了所有以start位置为头，达标的数量；
            start++;    //换一个开头
        }
        return res;
    }

    // for test
    public static int[] getRandomArray(int len) {
        if (len < 0) {
            return null;
        }
        int[] arr = new int[len];
        for (int i = 0; i < len; i++) {
            arr[i] = (int) (Math.random() * 10);
        }
        return arr;
    }

    // for test
    public static void printArray(int[] arr) {
        if (arr != null) {
            for (int i = 0; i < arr.length; i++) {
                System.out.print(arr[i] + " ");
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        int[] arr = getRandomArray(30);
        int num = 5;
        printArray(arr);
        System.out.println(getNum(arr, num));
    }
}
```

<br/>

<br/>

### 单调栈结构

解决的问题

一个数组中，找到每个数左边离它最近的比它大的数，右边离它最近的比它大的数，时间复杂度O(N)

遍历的解法O(N^2)

<br/>

单调栈解法

准备一个栈，保证从栈底到栈顶是从大到小的顺序，然后开始把数组中的数压栈，如果符合从栈底到栈顶是从大到小的顺序，直接压栈，如果到某一个数字，比栈顶的数要大了，就把栈顶的数字弹出，此时这个数字右边离它最近的比它大的数就是这个让它出栈的数字，左边离它最近的就是下一个栈顶的数字，按照这种方式依次弹出；

如果如果某一时刻，数组中的数遍历完了，栈中还有数字，就依次弹出，最后在栈中的数字右边离它最近的肯定都是null，因为后面没有比它们大的；左边离它们最近的数就是当前数下面内个数；

最后栈底的数字左右都为null；

{% asset_img picture9.jpg %}

<br/>

特殊情况，

相等的情况：不弹出，而是把两个下标压在一起，等待下一个数结算的时候，把下面连在一起的数一起结算；如下图所示：

{% asset_img picture10.jpg %}

<br/>

本质：为什么这样是对的，

假设如下的情况：

{% asset_img picture11.jpg %}

假设c>a，为什么此时a右边离它最近的比a大的数是c？在数组中a肯定是在c的左边，那a和c之间是不可能出现大于a的数的，如果存在，那就轮不到c来释放a了，中间内个数就释放a了；

同理可以证明b是a左边离它最近的比它大的数；

<br/>

### 题目：maxTree

一个数组的MaxTree定义如下：

1. 数组必须没有重复元素
2. MaxTree是一棵二叉树，数组的每一个值对应一个二叉树节点
3. 包括MaxTree树在内且在其中的每一棵子树上，值最大的节点都是树的头。

<br/>

给定一个没有重复元素的数组arr，写出生成这个数组的MaxTree的函数，要求如果数组长度为N，则时间复杂度为O(N)、额外空间复杂度为O(N)；

<br/>

思路一：

构建一个大根堆，然后把所有节点重连即可；

{% asset_img picture12.jpg %}

<br/>

思路二：单调栈结构；

列出每个值的左边距离它最近的数，右边距离它最近的数， 建树的策略是：

1. 如果两边都没有值，就是头结点；
2. 如果两边只有一边有值，直接挂在对应的节点下面；
3.  如果两边都有值，选择小的，挂在下面；
4. 最终形成整个树

<br/>

证明：

1. 是否会形成森林？

数组中没有重复值，所以最大值一定是作为头节点的， 而任何一个节点都会找一个比当前值大的，串在其下面，所以每一个节点都会有归属， 并且最终是以最大值作为头部的， 所以最终肯定是一颗树；

2. 是否会形成多叉树？

换为证明：a的一侧，最多只能有一个孩子挂在a下面，

反证法：假设a的右侧，有两个孩子挂在a下面，b和c，那么a>c ，a> c，

此时假设：1.b>c，a和b都大于c，而且b<a，按照策略c应该挂在b的后面，错误；2.c>b，a和c都大于b，而且c比a小，按照策略b应该挂在c后面，错误；

{% asset_img picture13.jpg %}

<br/>

代码：

```java
public class Code_02_MaxTree {
    private static class Node {
        public int value;
        public Node left;
        public Node right;

        public Node(int data) {
            this.value = data;
        }
    }

    private static Node getMaxTree(int[] arr) {
        Node[] nArr = new Node[arr.length];
        for (int i = 0; i != arr.length; i++) {
            nArr[i] = new Node(arr[i]);
        }
        Stack<Node> stack = new Stack<Node>();
        HashMap<Node, Node> lBigMap = new HashMap<Node, Node>();
        HashMap<Node, Node> rBigMap = new HashMap<Node, Node>();
        for (int i = 0; i < nArr.length; i++) {
            Node currNode = nArr[i];
            while ((!stack.isEmpty()) && stack.peek().value < currNode.value) {
                popStackSetMap(stack, lBigMap);
            }
            stack.push(currNode);
        }
        while (!stack.isEmpty()) {
            popStackSetMap(stack, lBigMap);
        }
        for (int i = nArr.length - 1; i != -1; i--) {
            Node currNode = nArr[i];
            while ((!stack.isEmpty()) && stack.peek().value < currNode.value) {
                popStackSetMap(stack, rBigMap);
            }
            stack.push(currNode);
        }
        while (!stack.isEmpty()) {
            popStackSetMap(stack, rBigMap);
        }
        Node head = null;
        for (int i = 0; i != nArr.length; i++) {
            Node currNode = nArr[i];
            Node left = lBigMap.get(currNode);
            Node right = rBigMap.get(currNode);
            if (left == null && right == null) {
                head = currNode;
            } else if (left == null) {
                if (right.left == null) {
                    right.left = currNode;
                } else {
                    right.right = currNode;
                }
            } else if (right == null) {
                if (left.left == null) {
                    left.left = currNode;
                } else {
                    left.right = currNode;
                }
            } else {
                Node parent = left.value < right.value ? left : right;
                if (parent.left == null) {
                    parent.left = currNode;
                } else {
                    parent.right = currNode;
                }
            }
        }
        return head;
    }

    private static void popStackSetMap(Stack<Node> stack, HashMap<Node, Node> map) {
        Node popNode = stack.pop();
        if (stack.isEmpty()) {
            map.put(popNode, null);
        } else {
            map.put(popNode, stack.peek());
        }
    }

    private static void printPreOrder(Node head) {
        if (head == null) {
            return;
        }
        System.out.print(head.value + " ");
        printPreOrder(head.left);
        printPreOrder(head.right);
    }

    private static void printInOrder(Node head) {
        if (head == null) {
            return;
        }
        printPreOrder(head.left);
        System.out.print(head.value + " ");
        printPreOrder(head.right);
    }

    public static void main(String[] args) {
        int[] uniqueArr = {3, 4, 5, 1, 2};
        Node head = getMaxTree(uniqueArr);
        printPreOrder(head);
        System.out.println();
        printInOrder(head);
    }
}
```

<br/>

<br/>

### 题目：最大矩形问题

数组代表直方图，求组成的直方图中矩形中最大矩形的面积

{% asset_img picture14.jpg %}

数组的值代表直方图的高，以每个数组的值向两边扩一个位置，如果碰到比它大的，就继续扩，直到扩到比当前位置低的，此时向两边扩的距离就是矩形的长，当前位置代表的高就是矩形的宽。

其实本质就是找以每个值作为高的矩形的最大底是多少；

<br/>

做法：

单调栈，从底到顶维持从小到大的顺序，0-4 是因为1-3被弹出的，所以4右边离他最近比它小的，就是3，栈下面没值，所以4左边离他最近比它小的就是-1，所以底就是向两边扩的距离1，高是4。按照这个策略一直往下走即可；

{% asset_img picture15.jpg %}

相等的情况

{% asset_img picture16.jpg %}

<br/>

<br/>

### 题目：求最大子矩阵的大小

题目描述：给定一个整型矩阵map，其中的值只有0和1两种，求其中全是1的所有矩形区域中，最大的矩形区域为1的数量；

例如：

1 1 1 0

其中，最大的矩形区域有3个1，所以返回3

再如：

1 0 1 1

1 1 1 1

1 1 1 0

其中，最大的矩形区域有6个1，所以返回6

<br/>

解法：

本质就是找以每一行为底形成矩形的面积最大的内个矩形；从第二行开始，每一行会对应一个新的数组，新数组的生成是根据前面形成的数组而来的，如果当前值是1，就在上面一行的基础上+1，如果是0，就置为0；然后用上面求直方图的办法求每行的新数组的最大矩形的面积；最后取每行的最大值；

这个新的数组其实代表的就是往上有几个连续的1；

其实每个1可以理解为直方图中的一个小矩形；

{% asset_img picture17.jpg %}

<br/>

时间复杂度

假设整个矩形的底为m，高为n，遍历每一行的时间复杂度为O(m)，一共n行，时间复杂度O(N*m)，相当于遍历一遍就得到了结果，时间复杂度非常底；

<br/>

代码：

```java
public class Code_04_MaximalRectangle {
    // 求最大子矩形
    public static int maxRecSize(int[][] map) {
        if (map == null || map.length == 0 || map[0].length == 0) {
            return 0;
        }
        int maxArea = 0;
        int[] height = new int[map[0].length];  //有多少列，就形成多大长度
        for (int i = 0; i < map.length; i++) {//枚举以i行打底
            for (int j = 0; j < map[0].length; j++) {//生成i行打底的直方图数组
                height[j] = map[i][j] == 0 ? 0 : height[j] + 1;
            }
            maxArea = Math.max(maxRecFromBottom(height), maxArea); //每一行算一次；
        }
        return maxArea;
    }

    /**
     * 求直方图的最大矩形面积
     * example [4,3,2,5,6]
     */
    private static int maxRecFromBottom(int[] height) {
        if (height == null || height.length == 0) {
            return 0;
        }
        int maxArea = 0;
        Stack<Integer> stack = new Stack<>();  //单调栈
        for (int i = 0; i < height.length; i++) { // 遍历每一个数
            while (!stack.isEmpty() && height[i] <= height[stack.peek()]) {  //当前数小于等于栈顶的位置；
                int j = stack.pop(); //弹出，结算
                int k = stack.isEmpty() ? -1 : stack.peek(); //k: 左边界，栈为空，左边界就是-1，否则就是弹出之后的栈顶
                int curArea = (i - k - 1) * height[j]; //x是当前数index，它让j出栈了，x就是j的右边界，k是j的左边界，j是出栈的数，也是被结算的数
                                                    //(i - k - 1) 就是底的长度；也就是向两边延伸的距离
                maxArea = Math.max(maxArea, curArea);
            }
            stack.push(i);//当前数进栈，
        }
        while (!stack.isEmpty()) {  //栈中剩下的东西，结算
            int j = stack.pop();
            int k = stack.isEmpty() ? -1 : stack.peek();
            int curArea = (height.length - k - 1) * height[j];
            maxArea = Math.max(maxArea, curArea);
        }
        return maxArea;
    }

    public static void main(String[] args) {
        int[][] map = {{1, 0, 1, 1}, {1, 1, 1, 1}, {1, 1, 1, 0}};
        System.out.println(maxRecSize(map));
    }
}
```

<br/>

<br/>

### 相关题目：小B负责首都的防卫工作。

首都处于一个四面环山的盆地中，周围的n个小山构成一个环，作为预警措施，小B计划在每个小山上设置一个观察哨，日夜不停的瞭望周围发生的情况。
一旦发生外敌入侵事件，山顶上的岗哨将点燃烽烟。
若两个岗哨所在的山峰之间的那些山峰，高度都不大于这两座山峰，且这两个山峰之间有相连通路，则岗哨可以观察到另一个山峰上的烽烟是否点燃。
由于小山处于环上，任意两个小山之间存在两个不同的连接通路。满足上述不遮挡的条件下，一座山峰上岗哨点燃的烽烟至少可以通过一条通路被另一端观察到。
对于任意相邻的岗哨，一端的岗哨一定可以发现一端点燃的烽烟。
小B设计的这种保卫方案的一个重要特性是能够观测到对方烽烟的岗哨对的数量，她希望你能够帮她解决这个问题。
输入
输入中有多组测试数据。每组测试数据的第一行为一个整数n（3<=n<=10^6），为首都周围的小山数量，第二行为n个整数，依次表示小山的高度h，（1<=h<=10^9）。
输出
对每组测试数据，在单独的一行中输出能相互观察到的岗哨的对数。
样例输入
5
1 2 4 5 3
样例输出

7

<br/>

题目解析：

一个环，每个节点有一个数字，代表一座山，山上可以点烽火，有两个规则：

1. 相邻可见
2. 如果不相邻，肯定有两条路可以走，如果这两条路中有一条路，路中经过的所有数，都比这两座山中数值较小的数小的话，就可以看见，例如：

{% asset_img picture18.jpg %}

其中 1 -> 4，都看不见，3 ->4，从 3->2->4 这条路可以看见

给定一个数组，求可以相互看见的山峰有多少对？

<br/>

假设没有重复数字的情况

{% asset_img picture19.jpg %}

人为规定只能小的找大的，这样大的能找到的小的肯定都已经找过了

假设最高的值，和此高的值，已经都找到了，那么此高和最高之间的每个数肯定都能找到两对能相互看见的，因为其他数肯定都是小于最高和次高的；最后再加上此高到最高的这一对，所以最后的结果就是2n-3；

<br/>

有重复数字的情况：单调栈

先找到数组的最大值，压栈，然后逆时针开始遍历，栈中存储的是每个数字和这个数出现的次数，存储的顺序是从栈底到栈顶是从大到小的顺序。此时遍历到了当前数，假设当前数比栈顶的数要大，此时栈顶的数出栈，如果栈顶的数只出现了一次，那么这个数能够形成的山峰对就是两对，因此此时栈顶的数比它大，当前数也比它大，所以能够形成两对；如果栈顶的数出现了n次，那么能够形成的对数就是Cn:2+2*n 对，Cn:2代表每两个数都能形成一对可以相互看见的山峰，n✖️2代表每个数都还能和当前数还有此时栈顶的数形成两对，

{% asset_img picture20.jpg %}

<br/>

为什么一定要找一个最大值打底？

因为我们一定要保证在顺时针方向上，能够找到一个数比当前数大，我们才能正确结算，当一个数从栈中出来的时候，很确定的能够搞出向顺时针和逆时针都有一个数字比当前数大，此时Cn:2+2*n这个公式的结算才是正确的；

<br/>

最后栈中的数如何处理？

当栈中的数因为其他数从栈中弹出的时候，上面的公式是可以正确结算的，但是当最后处理完后，栈中肯定还有其他数不能因为其他数而出栈，此时：

<br/>

一：当栈中的数字个数大于等于3个时，倒数第三个及以上的数字仍然可以用 Cn:2+2*n 这个公式进行计算，因为此时栈最底部的数字是作为当前栈顶的数字的逆时针方向的最大值的，而即将被弹出的这个数下面内个数就是它顺时针方向的最大值（因为是个环嘛，具体可看下面的图示）；

{% asset_img picture21.jpg %}

<br/>

二：栈中的最后两个数是特殊情况，需要单独处理；

1.针对倒数第二个数，如果倒数第一个最大值出现了两次以上，还是上面的通式，因为这n个数左右两边肯定会各出现一个比当前数大的，不论这个环是怎么排列的；如下图：

{% asset_img picture22.jpg %}

但是如果倒数第一个最大值只出现了一次，那么最后的通式就是Cn:2+1*n，因为这n个数左右两边出现的比这个数大的数肯定是同一个数即最大值；

{% asset_img picture23.jpg %}

所以对于倒数第二个数来说，倒数第一个数的个数是它需要考虑的；

<br/>

2.针对倒数第一个数，如果倒数第一个最大值出现了两次及以上，那么通式就是Cn:2，如果只出现了一次，结果就是0；