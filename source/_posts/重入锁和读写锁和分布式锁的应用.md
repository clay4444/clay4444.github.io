---
title: 重入锁和读写锁和分布式锁的应用
categories:
  - 多线程编程
abbrlink: '282014e2'
date: 2017-08-12 14:07:03
---

## ReentrantLock(重入锁)

- 重入锁，在需要进行同步的时候代码部分加上锁定，但不要忘记最后一定要释放锁定，不然会造成锁永远无法释放，其他线程永远进不来的结果
- 注意：一定要和finally配合使用
- 重入锁也无法像CountDownLatch一样做到实时性

```java
public class UseReentrantLock {

  private Lock lock = new ReentrantLock();

  public void method1(){
    try {
      lock.lock();
      System.out.println("当前线程:" + Thread.currentThread().getName() + "进入method1..");
      Thread.sleep(1000);
      System.out.println("当前线程:" + Thread.currentThread().getName() + "退出method1..");
      Thread.sleep(1000);
    } catch (InterruptedException e) {
      e.printStackTrace();
    } finally {

      lock.unlock();
    }
  }

  public void method2(){
    try {
      lock.lock();
      System.out.println("当前线程:" + Thread.currentThread().getName() + "进入method2..");
      Thread.sleep(2000);
      System.out.println("当前线程:" + Thread.currentThread().getName() + "退出method2..");
      Thread.sleep(1000);
    } catch (InterruptedException e) {
      e.printStackTrace();
    } finally {

      lock.unlock();
    }
  }

  public static void main(String[] args) {

    final UseReentrantLock ur = new UseReentrantLock();
    Thread t1 = new Thread(new Runnable() {
      @Override
      public void run() {
        ur.method1();
        ur.method2();
      }
    }, "t1");

    t1.start();
    try {
      Thread.sleep(10);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
    //System.out.println(ur.lock.getQueueLength());
  }

}
```

- 分析：condition.await(); 等待 condition.signal();唤醒

```java
public class UseCondition {

  private Lock lock = new ReentrantLock();
  private Condition condition = lock.newCondition();

  public void method1(){
    try {
      lock.lock();
      System.out.println("当前线程：" + Thread.currentThread().getName() + "进入等待状态..");
      Thread.sleep(3000);
      System.out.println("当前线程：" + Thread.currentThread().getName() + "释放锁..");
      condition.await();	// Object wait
      System.out.println("当前线程：" + Thread.currentThread().getName() +"继续执行...");
    } catch (Exception e) {
      e.printStackTrace();
    } finally {
      lock.unlock();
    }
  }

  public void method2(){
    try {
      lock.lock();
      System.out.println("当前线程：" + Thread.currentThread().getName() + "进入..");
      Thread.sleep(3000);
      System.out.println("当前线程：" + Thread.currentThread().getName() + "发出唤醒..");
      condition.signal();		//Object notify
    } catch (Exception e) {
      e.printStackTrace();
    } finally {
      lock.unlock();
    }
  }

  public static void main(String[] args) {

    final UseCondition uc = new UseCondition();
    Thread t1 = new Thread(new Runnable() {
      @Override
      public void run() {
        uc.method1();
      }
    }, "t1");
    Thread t2 = new Thread(new Runnable() {
      @Override
      public void run() {
        uc.method2();
      }
    }, "t2");
    t1.start();

    t2.start();
  }

}
```

- 多个condition的情况，使用比wite()和notify()更加的灵活

```java
public class UseManyCondition {

  private ReentrantLock lock = new ReentrantLock();
  private Condition c1 = lock.newCondition();
  private Condition c2 = lock.newCondition();

  public void m1(){
    try {
      lock.lock();
      System.out.println("当前线程：" +Thread.currentThread().getName() + "进入方法m1等待..");
      c1.await();
      System.out.println("当前线程：" +Thread.currentThread().getName() + "方法m1继续..");
    } catch (Exception e) {
      e.printStackTrace();
    } finally {
      lock.unlock();
    }
  }

  public void m2(){
    try {
      lock.lock();
      System.out.println("当前线程：" +Thread.currentThread().getName() + "进入方法m2等待..");
      c1.await();
      System.out.println("当前线程：" +Thread.currentThread().getName() + "方法m2继续..");
    } catch (Exception e) {
      e.printStackTrace();
    } finally {
      lock.unlock();
    }
  }

  public void m3(){
    try {
      lock.lock();
      System.out.println("当前线程：" +Thread.currentThread().getName() + "进入方法m3等待..");
      c2.await();
      System.out.println("当前线程：" +Thread.currentThread().getName() + "方法m3继续..");
    } catch (Exception e) {
      e.printStackTrace();
    } finally {
      lock.unlock();
    }
  }

  public void m4(){
    try {
      lock.lock();
      System.out.println("当前线程：" +Thread.currentThread().getName() + "唤醒..");
      c1.signalAll();
    } catch (Exception e) {
      e.printStackTrace();
    } finally {
      lock.unlock();
    }
  }

  public void m5(){
    try {
      lock.lock();
      System.out.println("当前线程：" +Thread.currentThread().getName() + "唤醒..");
      c2.signal();
    } catch (Exception e) {
      e.printStackTrace();
    } finally {
      lock.unlock();
    }
  }

  public static void main(String[] args) {


    final UseManyCondition umc = new UseManyCondition();
    Thread t1 = new Thread(new Runnable() {
      @Override
      public void run() {
        umc.m1();
      }
    },"t1");
    Thread t2 = new Thread(new Runnable() {
      @Override
      public void run() {
        umc.m2();
      }
    },"t2");
    Thread t3 = new Thread(new Runnable() {
      @Override
      public void run() {
        umc.m3();
      }
    },"t3");
    Thread t4 = new Thread(new Runnable() {
      @Override
      public void run() {
        umc.m4();
      }
    },"t4");
    Thread t5 = new Thread(new Runnable() {
      @Override
      public void run() {
        umc.m5();
      }
    },"t5");

    t1.start();	// c1
    t2.start();	// c1
    t3.start();	// c2


    try {
      Thread.sleep(2000);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }

    t4.start();	// c1
    try {
      Thread.sleep(2000);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
    t5.start();	// c2

  }
}
```

- 公平锁比非公平锁是更加浪费资源的，因为要维护一个顺序

## ReentrantReadWriteLock(读写锁)

- 读写锁ReentrantReadWriteLock，其核心就是实现读写分离的锁，在高并发访问下，尤其是在读多写少的情况下，性能要远高于重入锁
- 之前学synchronized，ReentrantLck时，我们知道，同一时间内，只能有一个线程进行访问被锁定的代码，那么读写锁则不同，其本质是分成两个锁，即读锁，写锁，在读锁下，多个线程可以并发的进行访问，但是在写锁的时候，只能一个一个的顺序访问
- 口诀：读读共享，写写互斥，读写互斥
- 先创建ReentrantReadWriteLock这个对象，通过这个对象可以直接获得readLock和writeLock
- read方法和write方法是自己定义的，区别read方法和write方法的理由是这个方法里面是用哪个锁锁住的。

```java
public class UseReentrantReadWriteLock {

  private ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
  private ReadLock readLock = rwLock.readLock();
  private WriteLock writeLock = rwLock.writeLock();

  public void read(){
    try {
      readLock.lock();
      System.out.println("当前线程:" + Thread.currentThread().getName() + "进入...");
      Thread.sleep(3000);
      System.out.println("当前线程:" + Thread.currentThread().getName() + "退出...");
    } catch (Exception e) {
      e.printStackTrace();
    } finally {
      readLock.unlock();
    }
  }

  public void write(){
    try {
      writeLock.lock();
      System.out.println("当前线程:" + Thread.currentThread().getName() + "进入...");
      Thread.sleep(3000);
      System.out.println("当前线程:" + Thread.currentThread().getName() + "退出...");
    } catch (Exception e) {
      e.printStackTrace();
    } finally {
      writeLock.unlock();
    }
  }

  public static void main(String[] args) {

    final UseReentrantReadWriteLock urrw = new UseReentrantReadWriteLock();

    Thread t1 = new Thread(new Runnable() {
      @Override
      public void run() {
        urrw.read();
      }
    }, "t1");
    Thread t2 = new Thread(new Runnable() {
      @Override
      public void run() {
        urrw.read();
      }
    }, "t2");
    Thread t3 = new Thread(new Runnable() {
      @Override
      public void run() {
        urrw.write();
      }
    }, "t3");
    Thread t4 = new Thread(new Runnable() {
      @Override
      public void run() {
        urrw.write();
      }
    }, "t4");		

    //t1.start();
    //t2.start();

    //t1.start(); // R 
    //t3.start(); // W

    t3.start();
    t4.start();

  }
}
```

## 分布式锁

- 利用java不可能实现，因为同一个web应用程序是部署在两台linux服务器上，意味着有两个jvm，所以可以借助zookeeper等插件完成