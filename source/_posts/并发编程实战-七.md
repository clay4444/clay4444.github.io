---
title: 并发编程实战(七)
categories:
  - 多线程编程
tags:
  - 并发编程实战读书笔记
abbrlink: c03b7c51
date: 2018-02-28 19:14:33
---

## 第七章 取消和关闭

java没有任何机制来安全的终止线程

我们很少希望某个任务、线程或服务立即停止，因为这种立即停止会使共享的数据结构处于不一致的状态。相反，在编写任务和服务时可以使用一种协作的方式：~需要停止时，它们首先会清除当前正在执行的工作，然启再结束。这提供了更好的灵活性，因为任务本身的代码比发出取消请求的代碍更清楚如何执行清除工作。



<br/>

### 任务取消

如果外部代码能在某个操作正常完成之前将其置入“ 完成” 状态，那么这个操作就可以称为可取消的（ Cancellable ）

- 用户请求取消
- 有时间限制的操作
- 应用程序事件
- 错误：网页爬虫程序搜索相关的页面，并将页面或摘要数据保存到硬盘。当一个爬虫任务发生错误时〈例如，磁盘空间已满），那么所有搜索任务都会取消，此时可能会记录它们的当前状态，以便稍后重新启动。
- 关闭，

### 设置 ” 已请求取消 “ 状态

```java
public class PrimeGenerator implements Runnable {

  @GuardedBy("this")
  private final List<BigInteger> primes = new ArrayList<>();

  private volatile boolean cancelled;

  @Override
  public void run() {
    BigInteger p = BigInteger.ONE;
    while(!cancelled){
      p = p.nextProbablePrime();
      synchronized (this){
        primes.add(p);
      }
    }
  }

  public void cancel(){
    cancelled = true;
  }

  public synchronized List<BigInteger> get(){
    return new ArrayList<>(primes);
  }

  List<BigInteger> aSecondOfPrimes() throws InterruptedException{
    PrimeGenerator generator = new PrimeGenerator();
    new Thread(generator).start();
    try{
      Thread.currentThread().sleep(1000);
    }finally {
      generator.cancel();
    }
    return generator.get();
  }
}
```

PrimeGenerator 使用了一种简单的取消策略：客户代码通过cancel 来请求取消，PrimeGenerator 在每次搜索素数前首先检查是否存在取消请求，如果存在则退出。

<br/>



### 中断

```java
public class BrokenPrimeProducer extends Thread{

  private final BlockingQueue<BigInteger> queue;

  private volatile boolean cancelled = false;

  public BrokenPrimeProducer(BlockingQueue<BigInteger> queue){
    this.queue = queue;
  }

  public void run(){
    try {
      BigInteger p = BigInteger.ONE;
      while(!cancelled){
        queue.put(p = p.nextProbablePrime());
      }
    }catch (InterruptedException e){

    }
  }

  public void cancel(){
    cancelled = true;
  }

  void consumePrimes() throws InterruptedException {

    BlockingQueue<BigInteger> primes = new LinkedBlockingQueue<>();

    BrokenPrimeProducer producer = new BrokenPrimeProducer(primes);
    producer.start();
    try{
      while(!cancelled){
        consume(primes);
      }
    }finally {
      producer.cancel();;
    }
  }

  private void consume(BlockingQueue<BigInteger> primes) throws InterruptedException {
    primes.take();
  }
}
```

问题：

如果生产者的速度超过了消费者的处理速度，队列将被填满， put方法会阻塞。当生产者在put 方法中阻塞时，如果消费者希望取消生产者任务？那么将发生什么情况？它可以调用cancel 方法来设置cancelled 标志，但此时生产者却永远不能检查这个标志，因为它无能从阻塞的put 方能中恢复过来（因为消费者此时已在停止从队列中取出素数，所以put 方战将一直保持阻塞状态〉。

<br/>

线程中断是一种协作机制

<br/>

每个线程都有一个boolean 类型的中断状态。当中断线程时，这个线程的中断状态将被设置为true 。在Thread 中包含了中断线程以及查询线程中断状态的方法，如代码所示，interrupt 方法能中断目标线程，而islnterrupted 方法能返回目标线程的中断状态。静态的interrupted 方法将清除当前线程的中断状态，并返望它之前的值，这也是清除中断状态的唯一方法。

```java
public class Thread{
  public void interrupt(){...}
  public boolean isInterrupted(){...}
  public static boolean interrupted(){...}
}
```

<br/>

阻塞库方法，例如 Thread.sleep 和Object.wait 等，都会检查线程何时中断，并且在发现中断时提前返回。它们在响应中断时执行的操作包括清除中断状态，抛出InterruptedException, 表示阻塞操作由于中断而提前结束。

<br/>

调用 interrupt 并不意味着立即停止目标线程正在进行的工作，而只是传递了中断的消息，然后由线程在下一个合适的时刻中断自己。（这些时刻也被称为取消点）。有些方法，例如wait 、slep 和join 等，将严格地处理这种请求，当它们收到中断请求或者在正在执行时发现某个已被设置好的中断状态时，将抛出一个异常。

<br/>

**一个设计良好的方法应该能使调用代码对中断请求进行某种处理，而设计糟糕的方法可能会屏蔽中断请求，从而导致调用栈中的其他代码无法对中断请求做出响应 **

<br/>

在使用静态的interrupted 时应该小心，因为它会清除当前线程的中断状态。如果在调用interrupted时返回 true，那么除非你想屏蔽这个中断，否则必须对它进行处理，可以抛出lnterruptedException ，或者通过再次调用 interrupt 来恢复中断状态。

```java
public class TaskRunnable implemends Runnable{
  BlockingQueue<Task> queue;
  ....
  public void run(){
    try{
      processTask(queue.take());
    }catch(InterruptedException e){
      //恢复被中断的状态
      Thread.currentThread().interrupt();
    }
  }
}
```

<br/>



第一个程序问题的解决办法：

```java
public class PrimeProducer extends Thread {

  private final BlockingQueue<BigInteger> queue;

  public PrimeProducer(BlockingQueue<BigInteger> queue){
    this.queue = queue;
  }

  public void run(){
    try {
      BigInteger p = BigInteger.ONE;
      while(!Thread.currentThread().isInterrupted()){//没有被中断则继续添加
        queue.put(p = p.nextProbablePrime());
      }
    }catch (InterruptedException e){
      //允许线程退出
    }
  }
}
```





<br/>

### 中断策略

中断策略规定线程如何解释某个中断请求，当发现中断请求时，应该做哪些工作（如果需要的话〉，哪些工作单元对于中断来说是原子操作，以及以多快的速度来晌应中断。

<br/>

最合理的中断策略是某种形式的结程级（Thread-Level）取消操作或服务级（Service-Level)取消操作：尽快退出，在必要时进行清理，通知某个所有者该线程已经退出。此外还可以建立其他的中断策略，例如暂停服务或重新开始服务。

<br/>

任务不会在其自己拥有的线程中执行，而是在某个服务〈例如线程池〉拥有的线程中执行，对于非线程所有者的代码来说〈例如，对于非线程池而言，任何在线程池实现以外的代码〉，应该小心的保存中断状态，这样拥有线程的代码才能对中断做出响应，即使“ 非所有者 ” 代码也可以做出响应。（当你为一户人家打扫房屋时，即使主人不在，也不应该把在这段时间内收到的邮件扔掉，而应该把邮件收起来，等主人回来以后再交给他们处理，尽管你可以阅读他们的杂志）

<br/>

这就是为什么大多数可阻塞的操作都只是抛出InterruptedException 作为中断响应。它们永远不会在某个由白己拥有的线程中执行，因此他们为任务或库代码实现了最合理的取消策略：尽快退出执行流程，并把中断信息传递给调用者，从而使调用栈中的上层代码可以采取进一步的操作。

<br/>

当检查到中断请求时，任务并不需要放弃所有的操作，它可以推迟处理中断请求，并直到某个更合适的时刻。因此需要记住中断请求，并在完成当前任务后抛出InterruptedException 或者表示己收到中断请求。这项技术能够确保在更新过程中发生中断时，数据结构不会被破坏。

<br/>

执行任务不应该对其执行所在的线程做出假设，无论任务把中断视为取消，还是其他某个中断响应操作，都应该小心地保存执行线程的中断状态。如果除了将InterruptedException 传递给提用者外还需要执行其他操作，那么应该在捕获InterruptedException 之后恢复中断状态。

```java
Thread.currentThread().interrupt();
```

<br/>

执任取消操作的代码也不应该对线程的中断策略做出假设。**线程应该只能由其所有者中断 **

<br/>

由于每个线程拥有各自的中断策略，因此除非你知道中断对该线程的含义，否则就不应该中断这个线程。

<br/>

批评者曾嘲笑Java 的中断功能，因为它没有提供抢占式中断机制，而且还强迫开发人员必须处理InterruptedException。然而，通过推迟中断请求的处理，开发人员能制定更灵活的中断策略，从而使应用程序在响应性和键壮性之间实现合理的平衡。

<br/>



### 响应中断

当调用可中断的阻塞函数时，例如Thread.sleep() 或BlockingQueue.put() 等，有两种使用策略可用于处理InterruptedException

- 传递异常，从而使你的方法也成为可中断的方法。

```java
BlockingQueue<Task> queue;
...
public Task getNextTask() throws InterruptedException{
	return queue.take();  
}
```

- 恢复中断状态，从而使得调用栈中的上层代码能够对其进行处理：

标准的方法就是通过再次调用interrupt 来恢复中断状态，你不能屏蔽InterruptedException, 例如在catch 块中捕获到异常却不做任何处理，除非在你的代码中实现了线程的中断策略。虽然PrimeProducer 屏蔽了中断，但这是因为它已经知道线程将要结束，因此在调用栈中已经没有上层代码需要知道中断信息。由于大多数代码并不知道它
们将在哪个线程中运行，因此应该保存中断状态。

<br/>

**也就是说，只有实现了线程中断策略的代码才可以屏蔽中断请求，在常规的任何和库代码中都不应该屏蔽中断请求 **

<br/>

对于一些不支持取消但仍可以调用可中断阻塞方法的操作，它们必须在循环中调用这些方法，并在发现中断后重新尝试。在这种情况下，它们应该在本地保存中断状态，并在返回前恢复状态而不是捕获 InterruptException 时恢复状态，如下所示：

```java
/**
 * 不可取消的任务在退出前恢复中断
 */
public class NoncancelableTask {
  public Task getNextTask(BlockingQueue<Task> queue) {
    boolean interrupted = false;
    try {
      while (true) {
        try {
          return queue.take();
        } catch (InterruptedException e) {
          interrupted = true;
          // 重新尝试
        }
      }
    } finally {
      if (interrupted)
        Thread.currentThread().interrupt();
    }
  }

  interface Task {
  }
}
```

<br/>



在取消过程中可能涉及除了中断状态之外的其他状态。中断可以用来获取线程的注意，并且由中断线程保存的信息，可以为中断的线程提供进一步的指示。（当访问这些信息时，要确保使用同步。〉

倒如，当一个由ThreadPoolExecutor 拥有的工作者线程检测到中断时，它会检查线程池是否正在关闭。如果是，它会在结束之前执行一些线程池清理工作，否则 它可能创建一个新线程将线程池恢复到合理的规模。

<br/>



### 计时运行

```java
List<BigInteger> aSecondOfPrimes() throws InterruptedException{
  PrimeGenerator generator = new PrimeGenerator();
  new Thread(generator).start();
  try{
    Thread.currentThread().sleep(1000);
  }finally {
    generator.cancel();
  }
  return generator.get();
}
```

​	PrimeGenerator 可能需要超过1 秒的时间才能停止，但它最终会发现中断，然后停止，并使线程结束。在执行另一个任务时的另一个方面是：你希望知道在任务执行过程中是否会抛出异常。如果 PrimeGenerator 在指定时限内抛出了一个未检查的 异常，那么这个异常可能会被忽略，因为素数生成器在另一个独立的线程中运行，而这个线程并不会显示地处理异常。

<br/>

```java
/**
 * 7.8 在外部线程中安排中断（不要这样做）
 */
public class TimedRun1 {

  private static final ScheduledExecutorService cancelExec = Executors.newScheduledThreadPool(1);

  public static void timedRun(Runnable r,long timeout, TimeUnit unit) {
    final Thread taskThread = Thread.currentThread();
    cancelExec.schedule(new Runnable() {
      public void run() {
        taskThread.interrupt();
        System.out.println("1--"+taskThread.isInterrupted());                
      }
    }, timeout, unit);
    r.run();
    System.out.println("2--"+taskThread.isInterrupted());  
  }
}
```

在调用线程中运行任务，并安排了一个取消任务，在运行指定的时间间隔后中断它。这解决了从任务中抛出未检查异常的问题，因为该异常会被 timedRun 的调用者捕获。

<br/>

　　这是一种非常简单的方法，但却破坏了以下规则：**在中断线程之前，应该了解它的中断策略 ** 。由于 timedRun 可以从任意一个线程中调用，因此它无法知道这个调用线程的中断策略。如果任务在超时之前完成，那么中断timedRun 所在线程的取消任务将在 timedRun 返回到调用者之后启动。我们不知道在这种情况下将运行什么代码，但结果一定是不好的。意思就是调用者的线程任务在没有执行完的时候，被timedRun 给中断了，此时肯会会出现问题。

<br/>

测试程序：

```java
public class TimedRun_Main {
  public static void main(String[] args) {
    TimedRun1 timeRun1 = new TimedRun1();
    Runnable run = new Runnable() {

      @Override
      public void run() {
        int i = 0;
        for (int j = 0; j < 100000000; j++) {
          i++;
          if (i % 10000000 == 0) {
            System.out.println(i + "  "+ Thread.currentThread().getName());
          }
        }
      }
    };
    timeRun1.timedRun(run, 1, TimeUnit.MILLISECONDS);
  }
}
```

​	<br/>

结果：

{% asset_img 七1.png %}

而且，如果任务不响应中断，那么 timedRun 会在任务结束时才返回，此时可能已经超过了指定的时限（或者还没有超过时限）。如果某个限时运行的服务没有在指定的时间内返回，那么将对调用者带来负面影响。

<br/>

```java
/**
 * 在专门的线程中中断任务
 */
public class TimedRun2 {
  private static final ScheduledExecutorService cancelExec = Executors
    .newScheduledThreadPool(1);

  public static void timedRun(final Runnable r, long timeout, TimeUnit unit)
    throws InterruptedException {

    //====================调用timedRun的线程========================================
    class RethrowableTask implements Runnable {
      private volatile Throwable t;//将在两个线程中共享，

      public void run() {
        try {
          r.run();
        } catch (Throwable t) {
          this.t = t;
        }
      }

      void rethrow() {//检查是否有异常抛出，
        if (t != null)
          try {
            throw launderThrowable(t);//如果有异常抛出，将会在调用timedRun 的线程中再次抛出该异常
          } catch (Exception e) {
            e.printStackTrace();
          }
      }
    }

    RethrowableTask task = new RethrowableTask();
    final Thread taskThread = new Thread(task);
    taskThread.start();
    //启动任务线程
    //=============================timeRun线程=========================================

    cancelExec.schedule(new Runnable() {//这就是timeRun线程
      public void run() {
        taskThread.interrupt();//中断任务线程
        System.out.println("1--" + taskThread.isInterrupted());
      }
    }, timeout, unit);

//=======================================================================
    taskThread.join(unit.toMillis(timeout));//限时的join方法。

    task.rethrow();
    System.out.println("2--" + taskThread.isInterrupted());
  }


  public static Exception launderThrowable(Throwable t) {
    if (t instanceof RuntimeException)
      return (RuntimeException) t;
    else if (t instanceof Error)
      throw (Error) t;
    else
      throw new IllegalStateException("Not unchecked", t);
  }
}
```

​	执行任务的线程拥有自己的执行策略，即使任务不响应中断，限时运行的方法仍能返回到它的调用者。在启动任务线程之后， timedRun 将执行一个限时的join 方法。在join 返回后，它将检查任务中是否有异常抛出，如果有的话，则会在调用timedRun 的线程中再次抛出该异常。由于 Throwable 将在两个线程之间共享，因此该变量被声明为volatile 类型，从而确保安全地将其从任务线程发布到 timedRun 线程。timedRun一个线程，调用timedRun的是另外一个线程。相当于在一个单独的线程中进行了对任务线程的执行。

<br/>

测试程序：

```java
public class TimedRun_Main {
  public static void main(String[] args) {
    TimedRun2 timeRun = new TimedRun2();
    Runnable run = new Runnable() {

      @Override
      public void run() {
        int i = 0;
        for (int j = 0; j < 100000000; j++) {
          i++;
          if (i % 10000000 == 0) {
            System.out.println(i + "  "+ Thread.currentThread().getName());
          }
        }
      }
    };
    try {
      timeRun.timedRun(run, 1, TimeUnit.MILLISECONDS);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }
}
```

<br/>

结果：

{% asset_img 七2.png %}

<br/>

​	在这个示例的代码中解决了前面示例中的问题，但由于它依赖一个限时的 join ,因此存在着join的不足，无法知道执行控制是因为线程正常退出而返回还是因为 join 超时而返回。

<br/>



### 通过 Future 来实现取消

​	Future 拥有一个 cancel 方法，该方法带有一个 boolean 类型的参数 maylnterruptlfRunning ，表示取消操作是否成功。

<br/>

（ 这只是表示任务是否能够接受中断，而不是表示任务是否能检测并处理中断。〉如果maylnterruptlfR.unning
为true 并且任务当前正在某个线程 中运行，那么这个线程能被中断。如果这个参数为false ，那么意味着“若任务还没有启动，就不要运行它，这种方式应该用于那些不处理中断的任务中。

<br/>

除非你清楚线程的中断策略，否则不要中断线程，那么在什么情况下调用cancel 可以将参数指定为true？执行任务的线程是由Executor 创建的，它实现了一种中断策略使得任务可以通过中断被取消，所以如果任务在标准的Executor 中执行，井通过它们的Future 来取消任务，那么可以设置 maylnterruptlfR.unning

<br/>

当尝试取消某个程务时，不宜直接中断线程池，因为你并不知道当中断请求到达时正在运行什么任务，只能通过任务的 Future 来实现取消，这是在编写任务时要将中断视为一个取消请求的另一个理由：可以通过任务的Future 来取消它们。

```java
public class TimedRun {
  private static final ExecutorService taskExec = Executors.newCachedThreadPool();

  public static void timedRun(Runnable r,
                              long timeout, TimeUnit unit)
    throws InterruptedException {
    Future<?> task = taskExec.submit(r);
    try {
      task.get(timeout, unit);
    } catch (TimeoutException e) {
      // 接下来任务被取消
    } catch (ExecutionException e) {
      // 如果在任务中抛出了异常，那么重新抛出该异常
      throw launderThrowable(e.getCause());
    } finally {
      // 如果任务已经结束，那么执行取消操作也不会带来任务影响
      task.cancel(true); // 如果任务正在运行，那么将被中断，
    }
  }
}
```

当Future.get 抛出InterruptedException 或 TimeoutException 时，如果你知道不再需要结果，那么就可以调用 Future.cancel 来取消。

<br/>

实例：

```java
public class Task  implements Callable<String>{

  //创建Task类，指定实现Callable接口，并参数化为String类型。
  //实现call()方法，写入一条信息到控制台，并使这个线程在循环中睡眠100毫秒。
  @Override
  public String call() throws Exception {
    while (true) {
      System.out.println("我在执行任务: Test 来自"+Thread.currentThread().getName()+"\n");            
      Thread.sleep(100);        
    }
  }
}
```

<br/>

测试程序：

```java
/**
 * 通过 Future 来取消任务
 */
public class Task_Main {
  public static final ScheduledExecutorService executor = Executors  
    .newScheduledThreadPool(1); 

  public static void main(String[] args) {
    Task task = new Task();
    System.out.printf("Main: 开始\n");
    Future<String> future = executor.submit(task);
    try {
      future.get(300, TimeUnit.MILLISECONDS);//设置超时执行时间
    } catch (InterruptedException e) {
      e.printStackTrace();
    } catch (ExecutionException e) {
      //如果在任务中抛出了异常，那么重新抛出该异常
      throw launderThrowable(e.getCause());
    } catch (TimeoutException e) {
      e.printStackTrace();
      //接下来任务将被取消
    } finally {
      System.out.printf("执行取消任务 \n");
      future.cancel(true);//如果任务正在运行，那么将被中断
    }

    //将isCancelled()方法和isDone()的调用结果写入控制台，验证任务已取消，因此，已完成。
    System.out.printf("Canceled: "+ future.isCancelled()+"\n");
    System.out.printf("Done: "+ future.isDone()+"\n");
    //
    executor.shutdown();
    System.out.printf("The executor has finished\n");

  }
  public static RuntimeException launderThrowable(Throwable t) {  

    if (t instanceof RuntimeException)  
      return (RuntimeException) t;        
    else if (t instanceof Error)  
      throw (Error) t;        
    else  
      throw new IllegalStateException("Not unchecked", t);        
  }  
}
```

<br/>

结果：

{% asset_img 七3.png %}

<br/>

### 处理不可中断的阻塞

　在java库中，许多可阻塞的方法都是通过提前返回或者抛出 InterruptedException 来响应中断请求的，从而使开发人员更容易构建出能响应取消请求的任务。然而，并非所有的可阻塞方法或者阻塞机制都能响应中断：

<br/>

- 造成**线程阻塞**的原因：

1. java.io包中的同步 Socket I/O。如套接字中进行读写操作read, write方法。
2. java.io包中的同步 I/O。如当中断或关闭正在InterruptibleChannel上等待的线程时，会对应抛出ClosedByInterruptException 或 AsynchronousCloseException
3. Selector的异步 I/O。如果一个线程在调用Selector.select时阻塞了，那么调用close, wakeup会使线程抛出ClosedSelectorException。
4. 获取某个锁。当一个线程等待某个锁而阻塞时，不会响应中断。但Lock类的lockInterruptibly允许在等待锁时响应中断。

```java
/**
 * 7.11 通过改写 interrupt 方法将非标准的取消操作封装在 Thread 中
 */
public class ReaderThread extends Thread{

  private static final int BUFSZ = 512;
  private final Socket socket;
  private final InputStream in;

  public ReaderThread(Socket socket) throws IOException{
    this.socket = socket;
    this.in = socket.getInputStream();
  }

  public void interrupt(){
    try {
      socket.close();
    } catch (IOException e) {
      e.printStackTrace();
    } finally{
      super.interrupt();
    }
  }

  public void run(){
    byte[] buf = new byte[BUFSZ];
    while(true){
      try {
        int count = in.read(buf);
        if (count < 0){
          break;
        }else if(count >0 ){
          processBuffer(buf, count);
        }

      } catch (IOException e) {
        //允许线程退出
      }

    }
  }

  private void processBuffer(byte[] buf, int count) {
    // TODO Auto-generated method stub
  }
}
```

​	ReaderThread 管理了一个套接字连接，它采用同步方式从该套接字读取数据，并将接收到的数据传递给processBuffer. 为了结束某个用户的连接或者关闭服务器， ReaderThread 改写了interrupt 方法，使其既能处理标准的中断，也能关闭底层的套接字。因此，无论 ReaderThread 线程 是在read方法中阻塞还是在某个可中断的阻塞方站中阻塞，都可以被中断并停止执行当前的工作。

<br/>

```java
/**
 * 7.12 通过 newTaskFor 将非标准的取消操作封装在一个任务中
 */
public class SocketUsingTask<T> implements CancellableTask<T> {

  @GuardedBy("this")
  private Socket socket;

  protected synchronized void setSocket(Socket socket) {
    this.socket = socket;
  }

  @Override
  public T call() throws Exception {
    //do working
    return null;
  }

  @Override
  public void cancel() {
    try {
      if (socket != null)
        socket.close();
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  @Override
  public RunnableFuture<T> newTask() {
    return new FutureTask<T>(this) {
      public boolean cancel(boolean mayInterruptIfRunning) {
        try {
          SocketUsingTask.this.cancel();
        } finally {
          return super.cancel(mayInterruptIfRunning);
        }
      }
    };
  }

  /**
     * 通过newTaskFor将非标准的取消操作封装在任务中
     */
  public class CancellingExecutor extends ThreadPoolExecutor {

    /**
         * @param corePoolSize
         * @param maximumPoolSize
         * @param keepAliveTime
         * @param unit
         * @param workQueue
         */
    public CancellingExecutor(int corePoolSize, int maximumPoolSize,
                              long keepAliveTime, TimeUnit unit,
                              BlockingQueue<Runnable> workQueue) {
      super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
      // TODO Auto-generated constructor stub
    }

    @Override
    protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
      if (callable instanceof CancellableTask) { // 若是我们定制的可取消任务
        return ((CancellableTask<T>) callable).newTask();
      }
      return super.newTaskFor(callable);
    }
  }

}

/**
 * 可取消的任务接口
 */
interface CancellableTask<T> extends Callable<T> {
  void cancel();

  RunnableFuture<T> newTask();
}
```

​	SocketUsingTask 实现了 CancellableTask，并定义了 Future.cancel 来关闭套接字和调用super.cancel 。如果SocketUsingTask 通过其自己的 Future 来取消，那么底层套接字将被关闭，并且线程将被中断。因此它提高了任务对取消操作的响应性：不仅能够在调用可中断方法的同时确保响应取消操作，而且还能调用可阻塞的套接字I/0 方法。



<br/>



### 停止基于线程的服务

<br/>

应用程序通常会创建拥有多个线程的服务，例如线程池，并且这些服务的生命周期通常比创建它们的方法的生命周期更长。如果应用程序准备退出，那么这些服务所拥有的线程也需要结束。由于无法通过抢占式的方法来停止线程，因此它们需要自行结束。

<br/>

正确的封装原则是：除非拥有某个线程，否则不能对该线程进行操控。例如，中断线程或者修改线程的优先级等。

<br/>

与其他的封装对象一样，线程的所有权是不可传递的：应用程序可以拥有服务，服务也可以拥有工作者线程，但应用程序并不能拥有工作者线程，因此应用程序不能停止工作者线程。相反，服务应该提供生命周期方法，服务就可以关闭所有的线程了。这样，当应用程序关闭服务时，服务就可以关闭所有的线程了。

<br/>

对于持有线程的服务，只要服务的存在时间大于创建线程的方法的存在时间，那么就应该提供生命周期方法。

<br/>

下面程序给出一个日志服务示例，其中日志操作在单独的日志线程中执行。产生日志消息的线程并不会将消息直接写入输出流，而是 LogWriter 通过 BlockingQueue 将消息提交给日志线程，并由日志线程写入。这是一种多生产者单消费者的设计方式：每个调用 log 的操作都相当于一个生产者，而后台的日志线程则相当于消费者。

```java
/**
 * 不支持关闭的生产者-消费者日志服务
 */
public class LogWriter {
  private final BlockingQueue<String> queue;
  private final LoggerThread logger;

  public LogWriter(Writer writer){
    this.queue = new LinkedBlockingDeque<String>();
    this.logger = new LoggerThread(writer);
  }

  public void start(){
    logger.start();
  }

  public void log(String msg) throws InterruptedException{
    queue.put(msg);
  }

  private class LoggerThread extends Thread{
    private final Writer writer;

    public LoggerThread(Writer writer) {
      this.writer = writer;
    }

    @Override
    public void run() {
      try {
        while(true){
          writer.write(queue.take());
        }
      } catch (IOException e) {
        // io exception handle
      } catch (InterruptedException e) {
        // interrupt exceptino handle
      } finally{
        try {
          writer.close();
        } catch (IOException e) {
          e.printStackTrace();
        }
      }
    }
  }
}
```

需要实现一种终止日志线程的方法，从而避免使JVM 无法正常关闭。耍停止日志线程是很容易的，因为它会反复
调用take ，而take 能响应中断。如果将日志线程修改为当捕获到InterruptedException 时退出，那么只需中断日志线程就能停止摄务。

<br/>

然而，如果只是使日志线程退出，那么还不是一种完备的关闭机制，因为这种直接关闭的做法会丢失那些正在等待写入到日志的信息，不仅如此，其他线程将在调用log时被阻塞， 因为日志消息队列是阻塞的，因此这些线程将无法解除阻塞状态，当取消一个生产者·消费者操作时，需要同时取消生产者和消费者，

<br/>

但在这个例子中，由于生产者并不是专门的线程，因此要取消他们非常困难。

<br/>

另一种关闭LogWriter 的方法是：设置某个“ 已请求关闭 ”标志，以避免进一步提交日志消息，如程序所示。在收到关闭请求后，消费者会把队列中的所有消息写入日志，并解除所有调用log时阻塞的生产者，然而，在这个方法中存在着竞态条件问题，使得该方法并不可靠。log 的实现是一种 “先判断再运行” 的代码序列， 生产者发现该报务还没有关闭，因此再关闭服务后仍然会将日志消息放入队列，这同样会使得生产者可能在调用log 时阻塞并且无法接触阻塞状态。

```java
public void log(String msg) throws InterriptedException{
  if(!shutdownRequest){
    queue.put(msg);
  }else{
    throw new IllegalStateException("logger is shut down");
  }
}
```

<br/>

为LogWriter 提供可靠关闭操作的方法是解决竞态条件问题， 因而要使日志消息的提交操作成为原子操作。然而，我们不希望在消息进入队列时持有一个锁，因为put 方法本身就可以阻塞。我们采用的方法是：通过原子方式来检查关闭请求，并且有条件地递增一个计数器来“保持” 提交消息的权利。

<br/>

下面给出 向LogWriter 添加可靠的取消操作的程序：

```java
/**
 * 7.15 向LogWriter 添加可靠的取消操作
 */
public class LogService {

  private final BlockingQueue<String> queue;
  private final LoggerThread loggerThread;
  private final PrintWriter writer;
  
  @GuardedBy("this")
  private boolean isShutdown;//状态标志位。
  
  @GuardedBy("this")
  private int reservations;  //计数器，对它进行原子操作。

  public LogService(Writer writer) {
    this.queue = new LinkedBlockingDeque<String>();
    this.loggerThread = new LoggerThread();
    this.writer = new PrintWriter(writer);
  }

  public void start() {
    loggerThread.start();
  }

  public void stop() {
    synchronized (this) {
      isShutdown = true;
    }
    loggerThread.interrupt();
  }

  /**
     * 为LogService 提供可靠关闭操作的方法是解决竞态条件问题，因而要使日志消息的提交操作作为原子操作，
     * 然而 ，不希望在消息加入队列时去持有一个锁，因为 put 方法本身就可以阻塞
     * 这里 采用的方法是：通过原子方式来检查关闭请求，并且有条件地递增一个计数器来“保持”提交消息的权利
     */
  public void log(String msg) throws InterruptedException {
    synchronized (this) {
      if (isShutdown)
        throw new IllegalStateException();
      ++reservations;
    }
    queue.put(msg);
  }

  /**
     * 消费日志线程
     */
  private class LoggerThread extends Thread {
    public void run() {
      try {
        while (true) {
          try {
            synchronized (LogService.this) {
              if (isShutdown && reservations == 0)
                break;
            }
            String msg = queue.take();
            synchronized (LogService.this) {
              --reservations;
            }
            writer.println(msg);
          } catch (InterruptedException e) {
            /* retry */
          }

        }
      } finally {
        writer.close();
      }
    }
  }
}
```

<br/>



### 关闭 ExecutorService

ExecutorService提供了两种关闭方法：使用shutdown正常关闭，以及使用shutdownNow 强行关闭。在进行强行关闭时， shutdownNow 首先关闭当前正在执行的任务，然后返回所有尚未启动的任务清单。

<br/>

这两种关闭方式的差别在于各自的安全性和响应性：强行关闭的速度更快，但风险也更大，因为任务很可能在执行到一半时被结束；而正常关闭虽然速度慢，但却更安全，因为 ExecutorService 会一直等到队列中的所有任务都执行完成后才关闭。在其他拥有线程的服务中也应该考虑提供类似的关闭方式以供选择。

<br/>

简单的程序可以直接在main 函数中启动和关闭全局的 ExecutorService。而在复杂程序中，通常会将 ExecutorService 封装在某个更高级别的服务中，并且该服务能提供自己的生命周期方法，例如下面程序清单中，LogService的一种变化形式，它将管理线程的工作委托给一个 ExecutorService ，而不是由其自行管理。通过封装 ExecutorService,可以将所有权链从应用程序扩展到服务以及线程，所有权链上的各个成员都将管理它所拥有的服务或线程的生命周期。

```java
/**
 * 7.16 封装ExecutorService实现日志服务
 * @ClassName: LogService2
 * @author xingle
 * @date 2014-11-12 下午4:19:07
 */
public class LogService2 {
  private final ExecutorService exec = Executors.newSingleThreadExecutor();
  private final PrintWriter writer;

  public LogService2(PrintWriter writer){
    this.writer = writer;
  }

  /**
     * 产生日志
     * @param msg 日志内容
     * @throws InterruptedException
     */
  public void log(String msg){
    exec.execute(new WriteTask(msg));
  }

  /**
     * 停止日志服务
     * @throws InterruptedException 
     */
  public void stop(long timeout, TimeUnit unit) throws InterruptedException {
    try {
      exec.shutdown(); // 平缓关闭服务
      // 关闭服务后, 阻塞到所有任务被执行完毕或者超时发生，或当前线程被中断
      exec.awaitTermination(timeout, unit);
    } finally {
      writer.close();
    }
  }
}

class WriteTask implements Runnable
{
    public WriteTask(String msg) {
    }

    public void run()
    {
      //do something here
    }
}
```



<br/>

### 毒丸对象

“毒丸”是指一个放在队列上的对象，其含义是：“当得到这个对象时，立即停止。”在FIFO 队列中，“毒丸”对象将确保消费者在关闭之前首先完成队列中的所有工作，在提交“毒丸”对象之前提交的所有工作都会被处理，而生产者在提交了“毒丸”对象后，将不会在提交任何工作。在下面的程序清单中给出了一个单生产者——单消费者的桌面搜索示例，使用了“毒丸”对象来关闭服务。

```java
/**
 * 7.17 通过“毒丸”对象来关闭服务
 */
public class IndexingService {
  private static final int CAPACITY = 1000;
  private static final File POISON = new File("");
  private final IndexerThread consumer = new IndexerThread();
  private final CrawlerThread producer = new CrawlerThread();
  private final BlockingQueue<File> queue;
  //private final FileFilter fileFilter;
  private final File root;

  public IndexingService(File root) {
    this.root = root;
    this.queue = new LinkedBlockingQueue<File>(CAPACITY);

  }

  private boolean alreadyIndexed(File f) {
    return false;
  }

  //生产者
  class CrawlerThread extends Thread {
    public void run() {
      try {
        crawl(root);
      } catch (InterruptedException e) { /* fall through */
      } finally {
        while (true) {
          try {
            System.out.println("放入“毒丸”");
            queue.put(POISON);
            break;
          } catch (InterruptedException e1) { /* retry */
          }
        }
      }
    }

    private void crawl(File root) throws InterruptedException {
      File[] entries = root.listFiles();
      if (entries != null) {
        for (File entry : entries) {
          if (entry.isDirectory())
            crawl(entry);
          else if (!alreadyIndexed(entry)){
            System.out.println("放入生产者队列文件："+entry.getName()+" 来自线程："+Thread.currentThread().getName());
            queue.put(entry);
          }
        }
      }
    }
  }

  //消费者
  class IndexerThread extends Thread {
    public void run() {
      try {
        while (true) {
          File file = queue.take();
          if (file == POISON){
            System.out.println("遇到“毒丸”，终止");
            break;
          }

          else
            indexFile(file);
        }
      } catch (InterruptedException consumed) {
      }
    }

    public void indexFile(File file) {
      System.out.println("消费者取出文件："+file.getName()+" 来自线程："+Thread.currentThread().getName());
      /* ... */
    };
  }

  public void start() {
    producer.start();
    consumer.start();
  }

  public void stop() {
    producer.interrupt();
  }

  public void awaitTermination() throws InterruptedException {
    consumer.join();
  }

}
```

<br/>

测试代码：

```java
/**
 * 7.17 测试主程序（ 通过“毒丸”对象来关闭服务）
 */
public class IndexingService_Main {
  public static void main(String[] args) {
    File file = new File("D:\\test1/");
    IndexingService c = new IndexingService(file);
    c.start();
    try {
      TimeUnit.MICROSECONDS.sleep(100);// 停止ＸＸ时间，显示出消费速度慢于生产速度　
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
    c.stop();
  }
}
```

<br/>

单次执行结果：

{% asset_img 七4.png %}

<br/>

只有在生产者和消费者的数量都已知的情况下，才可以使用“毒丸”对象。

在IndexingService 中采用的解决方案可以扩展到多个生产者，只需每个生产者都向队列中放入一个“毒丸”对象，并且消费者仅当在接受 producers 个“毒丸”对象时才停止，

这种方法也可以扩展到多个消费者的情况，只需生产者将 consumers 个“毒丸”对象放入队列。

然而，当生产者和消费者的数量较大时，这种方法将变得难以使用。

只有在无界队列中，“毒丸”对象才能可靠地工作。



<br/>

### shutdownNow 的局限性

<br/>

​	当通过 shutdownNow  来强行关闭 ExecutorService 时，它会尝试取消正在执行的任务，并返回所有已提交但尚未开始的任务，从而将这些任务写入日志或者保存起来以便之后进行处理。

<br/>

　　然而，我们无法通过常规方法来找出哪些任务已经开始但尚未结束。这意味着这我们无法在关闭过程中知道正在执行的任务的状态，除非任务本身会执行某种检查。要知道哪些任务还没有完成，你不仅需要知道哪些任务还没有开始，而且还需知道当 Executor 关闭时哪些任务正在执行。

<br/>

​	在下面程序 TrackingExecutor 中给出了如何在关闭过程中判断正在执行的任务。通过封装 ExecutorService 并使得 execute 记录哪些任务是在关闭后取消的，TrackingExecutor 可以找出哪些任务已经开始但还没有正常完成。在 Executor 结束后，getCancelledTasks 返回被取消的任务清单。

<br/>

​	要使这项技术能发挥作用，任务在返回时必须维持的中断状态，在所有设计良好的程序中都会实现这个功能。

<br/>

```java
/**
 * 7.21 在 ExecutorService 中跟踪在关闭之后取消的任务
 */
public class TrackingExecutor extends AbstractExecutorService {
  private final ExecutorService exec;
  private final Set<Runnable> tasksCancelledAtShutdown = Collections
    .synchronizedSet(new HashSet<>());

  public TrackingExecutor(ExecutorService exec){
    this.exec = exec;
  }

  public List<Runnable> getCancelledTasks(){
    if(!exec.isTerminated())
      throw new IllegalStateException();
    return new ArrayList<Runnable>(tasksCancelledAtShutdown);
  }

  @Override
  public void execute(final Runnable runnable) {
    exec.execute(new Runnable() {

      @Override
      public void run() {
        try{
          runnable.run();
        }finally{
          if(isShutdown() && Thread.currentThread().isInterrupted())
            tasksCancelledAtShutdown.add(runnable);
        }
      }
    });
  }

  /**
     * 下面将ExecutorService 的其他方法委托给 exec
     */

  @Override
  public void shutdown() {
    exec.shutdown();
  }

  @Override
  public List<Runnable> shutdownNow() {
    return exec.shutdownNow();
  }

  @Override
  public boolean isShutdown() {
    return exec.isShutdown();
  }

  @Override
  public boolean isTerminated() {
    return exec.isTerminated();
  }

  @Override
  public boolean awaitTermination(long timeout, TimeUnit unit)
    throws InterruptedException {
    return exec.awaitTermination(timeout, unit);
  }

}
```

<br/>

　　在程序 WebCrawler 中给出了 TrackingExecutor 的用法。网页爬虫程序的工作通常是无穷尽的，因此当爬虫程序必须关闭时，我们通常希望保持它的状态，以便稍后重启动。CrawlTask 提供了一个  getPage 方法，该方法能找出正在处理的页面。当爬虫程序关闭时，无论是还没有开始的任务，还是那些被取消的任务，都将记录他们的URL，因此当爬虫程序程序启动时，就可以将这些URL 的页面抓取任务加入到任务队列中。

```java
/**
 * 7.22 使用TrackingExecutorService 来保存未完成的任务以备后续执行
 */
public abstract class WebCrawler {
  private volatile TrackingExecutor exec;
  @GuardedBy("this")
  public final Set<URL> urlsToCrawl = new HashSet<URL>();

  private final ConcurrentMap<URL, Boolean> seen = new ConcurrentHashMap<URL, Boolean>();
  private static final long TIMEOUT = 500;
  private static final TimeUnit UNIT = TimeUnit.MICROSECONDS;

  public WebCrawler(URL startUrl){
    urlsToCrawl.add(startUrl);
  }

  public synchronized void start(){
    exec = new TrackingExecutor(Executors.newCachedThreadPool());
    for (URL url: urlsToCrawl)
      submitCrawlTask(url);
      urlsToCrawl.clear();
  }

   /**
     * 提交爬虫任务
     */
  private void submitCrawlTask(URL url) {
    exec.execute(new CrawlTask(url));
  }

  protected abstract List<URL> processPage(URL url);

   /*
    * 保存未完成的
    */
  private void saveUncrawled(List<Runnable> uncrawled) {
    for (Runnable task:uncrawled){
      URL url = ((CrawlTask)task).getPage();
      System.out.println("保存未完成的URL："+url);
      urlsToCrawl.add(url);    
    }

  }

  //爬虫任务
  private class CrawlTask implements Runnable{
    private final URL url;

    CrawlTask(URL url){
      this.url = url;
    }

    private int count = 1;

    boolean alreadyCrawled() {
      return seen.putIfAbsent(url, true) != null;
    }

    void markUncrawled() {
      seen.remove(url);
      System.out.printf("marking %s uncrawled%n", url);
    }

    @Override
    public void run() {
      for (URL link :processPage(url)){
        if(Thread.currentThread().isInterrupted())
          return;
        System.out.println("提交的爬虫url:"+link);
        submitCrawlTask(link);
      }            
    }

    public URL getPage(){
      return url;
    }        
  }

  public synchronized void stop() throws InterruptedException{
    try {
      saveUncrawled(exec.shutdownNow());
      if (exec.awaitTermination(100, UNIT)){
        saveUncrawled(exec.getCancelledTasks());
      }

    } finally {
      exec = null;
    }
  }    
}
```



<br/>

测试程序：

```java
public class WebCrawler_Main {

  public static void main(String[] args) throws MalformedURLException{
    WebCrawler webc = new WebCrawler(new URL("http://site.baidu.com/")) {

      @Override
      protected List<URL> processPage(URL url) {
        //获取该url下所有的链接
        //这里省略了该功能
        List<URL> url2 = new ArrayList<URL>();
        try {
          url2.add(new URL("https://clay4444.github.io/"));
          //url2.add(new URL("http://www.zhihu.com/"));
        } catch (MalformedURLException e) {
          e.printStackTrace();
        }
        return url2;

      }

    };

    webc.start();
    try {
      Thread.sleep(10);
      webc.stop();
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }

}
```

<br/>

结果

{% asset_img 七5.png %}



<br/>

### 处理非正常的线程终止

我们有可以检测并防止在程序中  “遗漏” 线程的方法。

<br/>

导致线程提前死亡的最主要原因就是RuntimeException.

<br/>

任何代码都可能抛出一个RuntimeException。每当调用另一个方法时，都要对它的行为保持怀疑，不要盲目地认为它一定会正常返回，或者一定会抛出在方法原型中声明的某个已检查异常。对调用的代码越不熟悉，就越应该对其代码行为保持怀疑。

<br/>

如果任务抛出了一个未栓查异常，那么它将使线程终结，但是会首先通知框架该线程已经终结。然而，框架可能会用新的线程来代替这个工作线程，也可能不会，因为线程池正在关闭，或者当前已有足够多的线程能满足需要。

~~~~java
public void run(){
  Throwable thrown = null;
  try{
    while(!isInterrupted()){
      runTask(getTaskFromWorkQueue());
    }
  }catch(Throwable e){
    thrown = e;
  }finally{
    threadExited(this,thrown);
  }
}
~~~~



<br/>

###  未捕获异常的处理

在thread API 中同样提供了  UncaughtExceptionHandler，它能检测出某个线程由于未捕获的异常而终结的情况。这两种方法是互补的，通过将二者结合在一起，就能有效地防止线程泄露问题。

<br/>

当一个线程由于未捕获异常而终止时， JVM 会将这个事件报告给应用程序提供的UncaughtExceptionHandler 异常处理器，如果没有提供任何异常处理器，那么默认的行为是将追踪倍息输出到System.err

<br/>

异常处理器如何处器未捕获异常，取决于对服务质量的需求。最常见的响应方式是将一个错误信息以及相应的栈追踪结息写入应用程序日志中，如程序所示。异常处理器还可以采取更直接的响应，例如尝试重新启动线程，关闭应用程序，或者执行其他修复或诊断等操作。

~~~java
public class UEHLogger implements Thread.UncaughtExceptionHandler{
  public void uncaughtException(Thread t,Throwable e){
    Logger logger = Logger.getAnonymousLogger();
    logger.log(Level.SEVERE,"Thread terminated with exception: " + t.getName(),e);
  }
}
~~~

<br/>

在运行时间较长的应用程序中，通常会为所有线程的未捕获异常指定同一个异常处理器，并且该处理器至少会将异常信息记录到日志中。

<br/>

如果你希望在任务由于发生异常而失败时获得通知，并且执行一些特定于任务的恢复操作，那么可以将任务封装在能捕获异常的Runnable 或 Callable 中，或者改写 ThreadPoolExecutor 的 afterExecute 方法。

<br/>

### JVM关闭

JVM 既可以正常关闭，也可以强行关闭。正常关闭的触发方式有多种，包括：当最后一个 正常（非守护〉”线程结束时，或者当调用了System.exit 时，或者通过其他特定于平台的方法关闲时（例如发送了SIGINT 信号或键入Ctrl-C) 。虽然可以通过这些标准方法来正常关闭 JVM ，但也可以通过调用Runtime. halt 或者在造作系统中“杀死’ JVM 进程(例如发送SIG KILL）来强行关闭JVM。

<br/>

### 关闭钩子

{% asset_img 七7.png %}

在正常关闭中， JVM 首先调用所有已注册的关闭钩子（ Shutdown Hook ）。关闭钩子是指通过 Runtime.addShutdownHook 注册的 但是并未开始的线程。JVM 并不能保证钩子的调用顺序。在关部应用程序线程时，如果有（守护或非守护〉线程仍然在运行，那么这些线程接下来将与共的进程并发执行。当所有的关闭钩子都执行结束时，如果runFinalizersOnExit 为true，那么JVM 将运行终结器，然后再停止。JVM 并不会停止或中断任何在关闭时仍然远行的应用程序线程。当JVM 最终结束时，这些线程将被强行结束， 如果关闭钩子或终结器没有执行究成，那么正常关闭进程“ 挂起”并且JVM 必须 被强行关闭。当被强行关闭时，只是关闭JVM ，而不会关闭钩子( 正常关闭进程 )。

<br/>

关闭钩子可以用于实现服务或应用程序的清理工件，例如删除临时文件，或者清除无法由操作系统自动清除的资源。在一下程序  中给出了如何使程序 LogService 在start 方法中注册一个关闭钩子，从而确保在退出时关闭日志、文件。

~~~java
public void start(){
  Runtime.getRunTime().addShutdownHook(new Thread(){
    public void run(){
      try{
 		LogService.this.stop();      
      }catch(InterruptedException ignored){
      }
    }
  });
}
~~~

<br/>

由于关闭钩子将并发执行，因此在关闭日志文件时可能导致其他需要日志服务的关闭钩子产生问题，为了避免这种情况，关闭勾子不应该依赖那些可能被应用程序或其他关闭钩子关闭的服务。实现这种功能的一种方式是对所有服务使用同一个关闭钩子〈而不是每个服务使用一个不同的关闭钩子〉，并且在该关闭钩子中执行一系列的关闭操作。这确保了关闭操作在单个线程中串行执行，从而避免了在关闭操作之间出现竞态条件或死锁等问题。无论是否使用关闭钩子，都可以使用这项技术，通过将各个关闭操作串行执行，而不是并行执行，可以消除许多潜在的故障。

<br/>

### 守护线程

希望创建一个线程来执行一些辅助工作，而又不希望这个线程阻碍JVM 的关闭。在这种情况下就需要使用守护线程（Daemon Thread）

<br/>

线程可分为两种：普通线程和守护线程。在JVM 启动时创建的所有线程中，除了主线程以外，其他的线程郁是守护线程〈例如垃圾回收器以及其他执行辅助工作的线程〉。

<br/>

默认情况下，主线程创建的所有线程都是普通线程。

<br/>

普通线程与命护线程之间的差异仅在于当线程退出时发生的操作。当一个线程退出时，JVM 会检查其他正在运行的线程，如果这些线程都是守护线程，那么JVM 会正常退出操作。当 JVM 停止时，所有仍要是存在的守护钱程都将被抛弃，既不会执行 finally 代码块，也不会执行回卷栈，而 JVM 只是直接退出。

<br/>

我们应尽可能少地使用守护线程，很少有操作能够在不进行清理的情况下被安全地抛弃。特别是，如果在守护线程中执行可能包含I/O操作的任务，那么将是一种危险的行为。守护线程最好用于 执行“内部” 任务，例如周期性地从内存的缓存中移除逾期的数据。