---
title: 并发编程实战(六)
categories:
  - 多线程编程
tags:
  - 并发编程实战读书笔记
abbrlink: 5f3364db
date: 2018-02-27 17:43:34
---

### 第六章 任务执行

大多数并发应用程序都是围绕“任务执行（ Task Execution ）”来构造的：任务通常是一些抽象的且离散的工作单元。通过把应用程序的工作分解到多个任务中，可以简化程序的组织结构，提供一种自然的事务边界来优化错误恢复过程，以及提供一种自然的并行工作机构来提升并发性。

<br/>



### 串行执行任务

```java
public class SingleThreadWebServer {
  
  public static void main(String[] args) throws IOException{
    ServerSocket socket = new ServerSocket(80);
    while(true){
      Socket connection = socket.accept();
      handleRequest(connection);
    }
  }
}
```

每次只能处理一个请求，新到来的连接必须等待直到请求处理完成，同时，服务器的资源利用率非常低，因为当单线程在等待IO操作完成时，CPU将处于空闲状态。

<br/>



### 显示的为任务创建线程

```java
public class ThreadPerTaskWebServer {
    public static void main(String[] args) throws IOException{
        ServerSocket socket = new ServerSocket(80);
        while(true){
            final Socket connection = socket.accept();
            Runnable task = new Runnable() {
                @Override
                public void run() {
                    handleRequest(connection);
                }
            };
            new Thread(task).start();
        }
    }
}
```

- 任务处理过程从主线程中分离出来，使得主循环能够更快地重新等待下一个到来的连接，这使得程序在完成前面的请求之前可以接受新的请求，从而提高响应性。
- 任务可以并行处理，从而能服务多个请求。如果有多个处理器，或者任务由于某种原因被阻塞，例如等待1/0 完成、获取锁或者资源可用性等，程序的吞吐量将得到提高。
- 任务处理代码必须是线程安全的，因为当有多个任务时会并发地调用这段代码。

<br/>

不足：

- 线程生命周期的开销非常高 ，如果请求的到达率非常高且请求的处理过程是轻量级的，那么为每个请求创建一个新线程将消耗大量的计算资源。
- 资源消耗，如果你已经拥有足够多的线程，使所有CPU 保持忙碌状态，那么再创建更多的线程反而会降低性能。
- 稳定性：在可创建线程的数量上存在一个限制。这个限制造将随着平台的不同而不同，如果破坏了这些限制，那么程可能抛出OutOfMemoryError 异常，

<br/>

“为每个任务分配一个线程 ” 这种方式的问题在于，它没有限制可创建线程的数量，只限制了远程用户提交HTTP 请求 的速率。如果服务器需要提供高可用性，并且在高负载情况下能平缓地降能性能，那么这将是一个严重的故障。



<br/>

### Executor

任务是一组逻辑工作单元，而线程则是使任务异步执行的机制

<br/>

为灵活且强大的异步任务执行框架提供了基础， 该框架能支持多种不同类型的任务执行策略。

<br/>

它提供了一特标准的方法将任务的提交过程与执行过程解耦开来，并用Runnable 来表示任务。Executor 的实现还提供了对生命周期的支持，以及统计信息收集、应用程序管理机制和性能监视等机制。

<br/>

基于生产者-消费者。提交任务相当于生产者，执行任务相当于消费者。

```java
public class TaskExecutionWebServer {

  private static final int NTHREADS = 100;
  private static final Executor executor = Executors.newFixedThreadPool(NTHREADS);

  public static void main(String[] args) throws IOException{

    ServerSocket socket = new ServerSocket(80);
    while(true){
      final Socket connection = socket.accept();
      Runnable task = new Runnable() {
        @Override
        public void run() {
          handleRequest(connection);
        }
      };
      executor.execute(task);
    }
  }
}
```



<br/>

### 执行策略

- 在什么（ What ）线程中执行任务？
- 任务按照什么（ What） 顺序 执行（ FIFO 、LIFO 、优先级〉？
- 有多少个（ How many ）任务能并发执行？
- 在队列中有多少个（ How Many ）任务在等待执行？
- 如果系统由于过载而需要拒绝一个任务，那么应该选择哪一个（ Which ）任务？另外，如何( How )通知应用程序有任务被拒绝？
- 在执行一个任务之前或之后，应该进行哪些（ What) 动作？

<br/>

通过将任务的提交与任务的执行策略分离开来，有助于在部署阶段选择与可用硬件资源最匹配的执行策略。

<br/>



### 线程池

在线程池中执行任务”比“为每个任务分配一个线程”优势更多。通过重用现有的线程而不是创建新线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的在大开销。另一个额外的好处是，当请求拉到达时，工作线程通常巳结存在，因此不会由于等待创建建线程而延迟任务的执行，从而提高了晌应性。通过适当调整线程池的大小，可以创建足够多的线程以便使处理器保持忙碌状态， 同时还可在防止过多线程竞争资源而使应用程序耗尽内存或失败。

<br/>

- newFixedThreadPool
- newCachedThreadPool
- newSingleThreadExecutor
- newScheduledThreadPool

<br/>

从“为每个任务分配一个结程”策略变成基于线程池的策略，将对应用程序的稳定性产生重大的影响 Web 服务器 不会再在高负载情况下失败，由于服务器不会创建数千个统程来争夺有限的CPU 和内存资嚣，因此服务器的性能将平缓的降低。通过使用Executor，可以实现各种调优、管理、监视、记录日志、错误报告和其他功能，如果不使用任务执行框架，那么要增加这些功能是非常困难的。



<br/>

### Executor的生命周期

为了解决执行服务的生命周期问题， Executor 扩展了ExecutorService 接口

<br/>

ExecutorService 的生命周期有3 种状态：运行、关闭和己终止。

<br/>

ExecutorService 在初始创建时处于运行状态。shutdown 方法将执行平缓的关闭过程：不再接受新的任务，同时等待已经提交的任务执行完成，（包括那些还未开始执行的任务）。shutdownNow 方法将执行粗暴的关闭过程：它将尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。

<br/>

在ExecutorService 关闭后提交的任务将由 “拒绝执行处理器（rected Execution Handler)" 来处理，它会抛弃任务，或者使得 execute 方法抛出 一个未检查 的RejectedExecutionException， 等所有任务都完成后，ExecutorService 将进入终止状态。可以调用awaitτermination 来等待executorService 到达终止状态，或者通过调用isTerminated 来轮询ExecutorService是否已经终止。通常在调用 awaitTermination 之后会立即调用shutdown ，从而产生同步的关闭ExecutorService 的效果。

<br/>



### 延迟任务与周期任务

​	Timer 在执行所有定时任务时只会创建一个线程。如果某个任务的执行时间过长，那么将破坏其他TimerTask 的定时准确性。倒如某个周期TimerTask 需要每10s 执行一次，而另一个TimerTask 需要执行40ms ，那么这个周期任务或者在40ms 任务执行完成后快速连续地调用4次，或者彻底“丢失” 4 次调用〈取决于它是基于固定速率来调度还是基于固定延迟来调度〉，线程池能弥补这个缺陷，它可以提供多个线程来执行延时任务和周期任务。

<br/>

Timer 的另一个问题是，如果TimeTask 抛出了一个来检查的异常，那么Timer 将表现出糟糕的行为。Timer 线程并不捕获异常，因此当 TimerTask 抛出 未检查的异常时将 终止 定时线程。这种情况下timer 也不会恢复线程的执行，而是会错误地认为整个Timer 都被取消 。因此，已经被调度 但是尚未执行 的 timerTask 将不会再执行，新的任务也不能被调度。这个问题称为 “ 线程泄露 ”

<br/>

如果要构建自己的调度服务，那么可以使用DelayQueue，具体的使用过程及示例在 **并发Queue详解及其应用 **这篇博客中已经详细介绍，这里不再论述。



<br/>

### 页面渲染器

将HTML 页面 绘制到图像缓存 缓存中。为了筒便，假设 HTML 页爵只包含标签文本，以及预定义大小的图片和URL.

<br/>

串行策略：

它先绘制文本元素，同时为图像预留出矩形的占位空间，在处理完了第一遍文本后，程序再开始下载图像，井将它们绘制到相应的占位空间中。

```java
public calss SingleThreadRenderer{
  void renderPage(CharSequence source){
    renderText(source);
    List<ImageData> imageDaTa = new ArrayList<ImageData>();
    
    for(ImageInfo imageInfo : scanForImageInfo(source)){
      imageData.add(imageInfo.downloadImage());
    }
    
    for(ImageData data: imageData){
      renderImage(data);
    }
  }
}
```

​	图像下载过程的大部分时间都是在等待IO操作执行完成，在这期间CPU 凡乎不做任何工作。因此，这种串行执行方式没有充分地利用CPU。

<br/>



### callable 和 Future

callable是一种更好的异常，将返回一个值，或者抛出一个异常。

<br/>

Executor执行任务的四个阶段：创建，提交，开始，完成

<br/>

已提交但尚未开始的任务可以取消，但对于那些已经开始执行的任务，只有当它们能响应中断时，才能取消。取消一个已经完成的任务不会有任何影响。

<br/>

Future 表示一个任务的生命周期，并提供了相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务等。

<br/>

get 方法的行为取决于任务的状态〈尚未开始、正在运行、已完成〉。如果任务已经完或，那么get 会返回或者抛出一个Exception，如果任务没有完或，那么get 将阻塞并直到任务完成。如果任务抛出了异常，那么get 将该异常封装为ExecutionException 并重新提出。如果任务被取消，那么get 将揭出CancellationException。如果get 抛出了ExecutionException  ，那么可以通过getCause 来在得被封装的初始异常。

<br/>

ExecutorService 中的所有submit 方法都将返回一个Future，从而将一个Runnable 或Callable 提交给Executor，并得到一个Future 用来获得任务的执行结果或者联消任务。还可以显示地为某个指定的Runnable 或Callable 实例化一个FutureTask （由于FutureTask 实现了Runnable，因此可以将它提交给Executor 来执行，或者直接调用它的run方法。〉

<br/>

```java
public class FutureRenderer {

  private final ExecutorService executor = Executors.newCachedThreadPool();

  void renderPage(CharSequence source){

    final List<ImageInfo> imageInfos = scanForImageInfo(source);

    Callable<List<ImageData>> task = new Callable<List<ImageData>>() {
      @Override
      public List<ImageData> call() throws Exception {
        List<ImageData> result = new ArrayList<ImageData>();
        for(ImageInfo imageInfo: imageInfos){
          result.add(imageInfo.downloadImage());
        }
        return result;
      }
    };

    Future<List<ImageData>> future = executor.submit(task);
    renderText(source);

    try{
      List<ImageData> imageData = future.get();
      for(ImageData data : imageData){
        renderImage(data);
      }
    }catch (InterruptedException e){
      //重新设置线程的中断状态
      Thread.currentThread().interrupt();
      //由于不需要结果，因此取消任务
      future.cancel(true);
    }catch (ExecutionException e){
      throw launderThrowable(e.getCause());
    }
  }
}
```

将渲染过程分解为两个任务，一个是渲染所有的文本，另一个是下载所有的图像。（因为其中一个任务是CPU 密集型，而另一个任务是I/0 密集型，因此这种方法即使在单CPU 系统上也能提升性能。

<br/>

Future Render即使得渲染文本任务与下载图像数据的任务并发地执行。所有图像下载完后，会显示到页面上。这将提升用户体验，不仅使用户更快地看到结果，还有效利用了并行。

<br/>

### 异构任务并行化的局限性

Future Renderer 使用了两个任务，其中一个负责渲染文本，另一个负责下载图像。渲染文本的速度远远高于下载图像的速度〈可能性很大），那么程序的最终性能与串行执行时的性能差别不大，而代码都变得更复杂了。

<br/>

只有当大量相互独立且同构的任务可以并发进行处理时，才能体现出将程序的工作负载分配到多个任务中带来的真正性能提升。

<br/>



### CompletionService

CompletionService 将Executor 和BlockingQueue 的功能融合在一起。你可以将Callable 任务提交给它来执行，然后使用类似与队列操作的take 和poll 等方法来获得巳完成的结果，而这些结果会在完成时将被封装为Future . ExecutorCompletionService 实现了 CompletionService,  并将计算部分委托给一个Executor。

<br/>

ExecutorCompletionService 的实现非常简单。在构造函数中创建一个BlockingQueue 来保存计算完成的结果。~计算完成时，调用FutureTask 其中的done 方法。当提交某个任务时，该任务将首先包装为一个QueueingFuture，这是FutureTask 的一个子类，然后再改写子类的done方法，并将结果放入BlockingQueue 中，如程序所示。take 和poll 方法委托给了BlockingQueue ，这些方法会在得出结果之前阻塞。

```java
private class QueueingFuture<V> extends FutureTask<V>{
  QueueingFuture(Callable<V> c){super(c);}
  QueueingFuture(Runnable<V> c){super(t,r);}
  
  protected void done(){
    completionQueue.add(this);
  }
}
```

<br/>



可以通过CompletionService 从两个方面来提高页面渲染器的性能：缩短总运行时间以及提高相应性。为每一幅图像的下载者都创建一个独立任务，并在线程池中执行它们，从而将串行的下载过程转换为并行的过程：这将减少下载所有图像的总时间。此外，通过从CompletionService 中获取结果以及使每张图片在下载完成后立刻显示出来，能使用户获得一个更加动态和更高响应性的用户界面。

```java
public class Renderer {

  private final ExecutorService executor;

  public Renderer(ExecutorService executor ){
    this.executor = executor;
  }

  void renderPage(CharSequence source){

    List<ImageInfo> info = scanForImageInfo(source);
    CompletionService<ImageData> completionService = new ExecutorCompletionService<ImageData>(executor);

    for(final ImageInfo imageInfo : info){
      completionService.submit(new Callable<ImageData>() {
        @Override
        public ImageData call() throws Exception {
          return imageInfo.downloadImage();
        }
      });
    }

    renderText(source);

    try{
      for(int t = 0, n = info.size(); t < n; t++){
        Future<ImageData> f = completionService.take();
        ImageData imageData = f.get();
        renderImage(imageData);
      }

    }catch (InterruptedException e){
      Thread.currentThread().interrupt();
    }catch (ExecutionException e){
      throw launderThrowable(e.getCause());
    }
  }

  /**
     如果Throwabel 是Error，那么抛出它，如果是RuntimeException，那么返回它，否则抛出
     IllegalStateException。
     **/
  public static RuntimeException launderThrowable(Throwable t){
    if(t instanceof RuntimeException){  //未受检查的
      return (RuntimeException)t;
    }else if(t instanceof Error){
      throw (Error)t;
    }else{
      throw new IllegalStateException("not unchecked", t);
    }
  }
}
```

<br/>

上面使用Future的程序之所以做不到此程序的下载每一张图片都即使渲染的原因是因为Future必须自己使用一个容器（List<ImageData>）来保存下载完的所有结果，然后再统一渲染，没有办法提供一个边下载就边提取的容器，而CompletionService 就通过一个blckingQueue 很好的解决了这个问题。

<br/>



### 限时任务

主要困难在于，要确保得到答案的时间不会超过限定的时间，或者在限定的时间内无法获得答案。

<br/>

在支持时间限制的Future.get 中支持这种需求：当结果可用时，它将立即返回，如果在指定时限内没有计算出结果，那么将抛出timeoutException.

<br/>

注意当任务超时后应该立即停止，从而避免计算一个不再使用的结果而浪费计算资源，要实现这个功能，可再次使用Future，如果一个限时的get 方法抛出了TimeoutException，那么 可以通过Future 来取消任务。

<br/>

```java
Page renderPageWithAd() throws InterruptedException{
  long endNanos = System.nanoTime() + TIME_BUDGET；

    Future<Ad> f = executor.submit(new FetchAdTask());
  //在等待广告的同时显示页面
  Page page = rederPageBody();
  Ad ad;

  try {
    //只等待指定的时间长度
    long timeLeft = endNanos - System.nanoTime();
    ad = f.get(timeLeft,TimeUnit.NANOSECONDS);

  }catch (ExecutionException e){
    ad = DEFAULT_AD;
  }catch (TimeoutException e){
    ad = DEFAULT_AD;
    f.cancel(true);
  }
  page.setAd(ad);
  return page;
}
```



<br/>

### 旅行预订门户网站需求及实现

用户输入旅行的日期和其他要求，门户网站获取并显示来自多条航线、旅店或汽车租赁公司的报价。在获取不同公司报价的过程中，可能会调用Web 服务、访问数据库、执行一个EDI事务或其他机制。在这种情况下，不宜让页面的响应时间受限于最慢的响应时间，而应该只显示在指定时间内收到的信息。对于没有及时响应的服务提供者，页面可以忽略它们，或者显示一个提示倍怠，例如“ Did not hear from Air Java in time 。”

<br/>

从一个公司获得报价的过程与从其他公司获得报价的过程无关，因此可以将获取报价的过程当成一个任务，从而使获得报价的过程能并发执行，创建n个任务，将其提交到一个线程池，保留n 个Future，并使用限时的get 方法通过Future 串行地获取每一个结果，这一切都很简单，但还有一个更简单的方住  invokeAll

<br/>

```java
public class Test {
  private ExecutorService exec = Executors.newCachedThreadPool();

  private class QuoteTask implements Callable{

    private final TravelCompany company;
    private final TravelInfo travelInfo;

    public QuoteTask(TravelCompany company, TravelInfo travelInfo){
      this.company = company;
      this.travelInfo = travelInfo;
    }

    @Override
    public Object call() throws Exception {
      return company.solicitQuote(travelInfo);
    }
  }

  public List<TravelQuote> getRankedTravelQuotes(TravelInfo travelInfo,
                                                 Set<TravelCompany> companies,
                                                 Comparator<TravelQuote> ranking,
                                                 long time,
                                                 TimeUnit unit) throws InterruptedException{

    ArrayList<QuoteTask> tasks = new ArrayList<QuoteTask>();

    for(TravelCompany companie: companies){
      tasks.add(new QuoteTask(companie,travelInfo));
    }

    List<Future<TravelQuote>> futures = exec.invokeAll(tasks,time,unit);//执行结果

    List<TravelQuote> quotes = new ArrayList<>(tasks.size());//最终结果

    Iterator<QuoteTask> taskIter = tasks.iterator();

    for(Future<TravelQuote> f: futures){
      QuoteTask task = taskIter.next();
      try{
        quotes.add(f.get());
      }catch (ExecutionException e){
        quotes.add(task.getFailureQuote(e.getCause()));
      }catch (CancellationException e){
        quotes.add(task.getTimeOutQuote(e));
      }
    }

    return quotes;
  }
}
```

将多个任务提交到一个ExecutorService 并获得结果。InvokeAll 方法的参数为一组任务，并返回一组Future。这两个集合有着相同的结构。invokeAll 按照任务集合中迭代器的顺序将所有的Future 添加到返回的集合中，从而使调用者能将各个Future 与其表示的Callable 关联起来。当所有任务都执行完毕时，或者调用线程被中断时，又或者超过指定时限时， invokeAll 将返回。~超过指定时限后，任何还未完成的任务都会取消。当invokeAll 返回后，每个任务要么正常地完成，要么被取消，而客户端代码可以调用 get 或 Cancelled 来判断究竟是何种情况。

<br/>



## 总结：

​	要想在将应用程序分解为不同的任务时获得最大的好处，必须定义清晰的任务边界。某些应用程序中存在着比较明显的任务边界，而在其他一些程序中则需要进一步分析才能揭示出粒度更细的并行性。