---
title: 算法基础第六课
categories:
  - leetcode
abbrlink: 7f010ad5
date: 2019-04-01 13:19:09
---

### 图的存储方式

<br/>

#### 邻接表

边不带权重的：

{% asset_img picture1.jpg %}

如果是无向图，就是彼此都互为邻居，1和2链接，那么1的邻居有2，2的邻居有1。

<br/>

边带权重的；

{% asset_img picture2.jpg %}

<br/>

<br/>

#### 邻接矩阵

边带有权重的：

{% asset_img picture3.jpg %}

图中的数字表示边上的权重；

<br/>

#### 一般的表示法：

第一列表示权重，第二列表示from，第三列表示to

{% asset_img picture4.jpg %}

<br/>

#### 代码

点：

```java
public class Node {

	public int value; //点代表的值

	public int in;  //入度
	public int out; // 出度
	public ArrayList<Node> nexts;   //从我出发能够到达的节点，邻居节点
	public ArrayList<Edge> edges;   //从我出发，能够发散出边的集合；

	public Node(int value) {
		this.value = value;
		in = 0;
		out = 0;
		nexts = new ArrayList<>();
		edges = new ArrayList<>();
	}
}
```

<br/>

边

```java
public class Edge {
	public int weight;
	public Node from;
	public Node to;

	public Edge(int weight, Node from, Node to) {
		this.weight = weight;
		this.from = from;
		this.to = to;
	}
}
```

<br/>

图：点和边的集合

```java
public class Graph {
	public HashMap<Integer,Node> nodes;  //  <点对应的value值，实际对应的节点>
	public HashSet<Edge> edges; 		 //  所有的边的集合

	public Graph() {
		nodes = new HashMap<>();
		edges = new HashSet<>();
	}
}
```

<br/>

图的生成：加入点和边，再把点的信息补充完整；

```java
public class GraphGenerator {

	// 每一行就是长度为3的数组；[权重，from，to]
	public static Graph createGraph(Integer[][] matrix) {
		Graph graph = new Graph();
		for (int i = 0; i < matrix.length; i++) {
			Integer weight = matrix[i][0];
			Integer from = matrix[i][1];
			Integer to = matrix[i][2];

			//如果不包含from点和to点，建立两个节点
			if (!graph.nodes.containsKey(from)) {
				graph.nodes.put(from, new Node(from));
			}
			if (!graph.nodes.containsKey(to)) {
				graph.nodes.put(to, new Node(to));
			}

			//拿出from点，to点，建立一个新的边；
			Node fromNode = graph.nodes.get(from);
			Node toNode = graph.nodes.get(to);
			Edge newEdge = new Edge(weight, fromNode, toNode);

			// 一个节点的内容包括：入度，出度，后续邻居节点，发散出的边，
			// 所以：from节点三个往下走的都需要变化：出度，后续邻居节点，发散出的边，
			//      to节点只需要变化一个：入度
			fromNode.nexts.add(toNode);   //  from节点的后续节点新增一个to节点
			fromNode.out++;				  //  from节点的out出度+1
			toNode.in++;				  //  to节点的入度+1
			fromNode.edges.add(newEdge);  //  从from节点发散出的边增加一条
			graph.edges.add(newEdge);	  //  整个图的边新增一条
		}
		return graph;
	}
}
```

<br/>

<br/>

### 图的遍历

<br/>

#### 宽度优先遍历

1. 利用队列实现
2. 从源节点开始依次按照宽度进队列，然后弹出 
3. 每弹出一个点，把该节点所有没有进过队列的邻接点放入队列 
4. 直到队列变空

<br/>

距离原节点的距离越近，越早输出，可以用距离原节点的距离代表层数

<br/>

代码：

```java
public class Code_02_BFS {

	public static void bfs(Node node) {
		if (node == null) {
			return;
		}
		Queue<Node> queue = new LinkedList<>();
		HashSet<Node> map = new HashSet<>();  //set 表示这个点有没有进过这个队列，set的作用就是不让已经进过队列的节点再次进入；
		queue.add(node);
		map.add(node); // 进过set的就保留下来
		while (!queue.isEmpty()) {
			Node cur = queue.poll();
			System.out.println(cur.value);
			for (Node next : cur.nexts) {   //找到这个节点的所有邻居节点
				if (!map.contains(next)) {    // 只要这个节点没有进过队列，
					map.add(next);
					queue.add(next); // 就加入队列中；
				}
			}
		}
	}
}
```

<br/>

图示

{% asset_img picture5.jpg %}

<br/>

遍历过程

{% asset_img picture6.jpg %}

<br/>

### 深度优先遍历

1. 利用栈实现 
2. 从源节点开始把节点按照深度放入栈，然后弹出 
3. 每弹出一个点，把该节点和下一个没有进过栈的邻接点（两个节点同时）放入栈 
4. 直到栈变空

<br/>

一条路走到死，再返回，对于任何一个节点来说，后续的路都走完了，再往上返回，

可能因为选择的顺序不用，走的路不同，但都叫dfs

<br/>

代码：

```java
public class Code_03_DFS {

	public static void dfs(Node node) {
		if (node == null) {
			return;
		}
		Stack<Node> stack = new Stack<>();
		HashSet<Node> set = new HashSet<>();  // 也是标记这个节点有没有进过栈
		stack.add(node);
		set.add(node);
		System.out.println(node.value);  // 上来就打印

		while (!stack.isEmpty()) {
			Node cur = stack.pop();
			for (Node next : cur.nexts) {
				if (!set.contains(next)) {  // 只要发现一个邻居节点没有进过栈，//表示后续节点要把所有能走的路都走过，
					stack.push(cur);   // 但是break之前，当前节点和,这里之所以要把cur再放进去，是因为只把next放进栈中的话，next走完后续的所有路之后，就找不到返回父节点的路了，
					stack.push(next);  // 下一个邻居节点一起重新回到stack中；
					set.add(next);   //标记这个邻居节点进过栈了；
					System.out.println(next.value);
					break;   // 就直接break，不再找了，
				}
			}
		}
	}
}
```

<br/>

图示：

{% asset_img picture7.jpg %}

<br/>

### 拓扑排序

适用范围：要求有向图，且有入度为0的节点，且没有环

<br/>

应用：调度系统之间任务的依赖，例如如下的图示，表示：

A依赖BCD，B依赖CK，D依赖K，此时应该先编译k和c，在编译B和D，最后编译A

{% asset_img picture8.jpg %}

<br/>

拓扑排序的概念就是按照这个顺序执行，不会block住，一定可以执行完成；

<br/>

原理

首先找到入度为0的节点，他们肯定作为原始节点，肯定先执行，打印，

删除掉入度为0的节点，此时会产生新的入度为0的节点，继续打印，然后重复此步骤；

<br/>

代码：

```java
public class Code_04_TopologySort {

	// directed graph and no loop
	public static List<Node> sortedTopology(Graph graph) {

		HashMap<Node, Integer> inMap = new HashMap<>(); //统计所有节点的入度

		Queue<Node> zeroInQueue = new LinkedList<>();  //入度为0的点，进入这个队列

		for (Node node : graph.nodes.values()) {  //遍历所有的点，
			inMap.put(node, node.in);		//把每个点的入度，登记在map中；
			if (node.in == 0) {
				zeroInQueue.add(node); // 如果这个节点的入度为0，就加入0入度队列中；
			}
		}
		List<Node> result = new ArrayList<>();

		while (!zeroInQueue.isEmpty()) {
			Node cur = zeroInQueue.poll();  //从0入度队列中，拿出一个节点，
			result.add(cur);				//加入结果链表中；
			for (Node next : cur.nexts) {  			//找到这个节点的所有后续邻居节点；
				inMap.put(next, inMap.get(next) - 1);  //把这个节点的后续邻居节点的入度都-1；
				if (inMap.get(next) == 0) {  	//如果这个邻居节点的入度减完之后变成0了，
					zeroInQueue.add(next);  	//就放进入度为0的队列中；
				}
			}
		}
		return result;
	}
}
```

<br/>

<br/>

### 最小生成树：

适用范围：一定是无向图

包含两个算法，一个是k算法，一个是p算法，这连个算法的策略不同，但是生成的结果是一致的；

都会返回一个边的集合，这个集合既能保证所有的边连通在一起，又能保证在所有的选择中，权重是最低的；

<br/>

作用：

边上有权重，返回整颗树能够连通的情况下，边的最小权重和；

<br/>

#### K算法：

通过选择边的策略，来考察应该选哪几条

从小权重的边开始考察，如果选择的边，构成回路了，不要这条边，如果没有构成回路，要这条边，直到发现所有的点都包括了，结束；

<br/>

图示：

{% asset_img picture9.jpg %}

<br/>

代码：

```java
public class Code_05_Kruskal {

	// 并查集的原理之前已经总结过，忘了就看一下之前的博客
	public static class UnionFind {
		private HashMap<Node, Node> fatherMap;
		private HashMap<Node, Integer> rankMap;

		public UnionFind() {
			fatherMap = new HashMap<Node, Node>();
			rankMap = new HashMap<Node, Integer>();
		}

		private Node findFather(Node n) {
			Node father = fatherMap.get(n);
			if (father != n) {
				father = findFather(father);
			}
			fatherMap.put(n, father);
			return father;
		}

		public void makeSets(Collection<Node> nodes) {
			fatherMap.clear();
			rankMap.clear();
			for (Node node : nodes) {
				fatherMap.put(node, node);
				rankMap.put(node, 1);
			}
		}

		public boolean isSameSet(Node a, Node b) {
			return findFather(a) == findFather(b);
		}

		public void union(Node a, Node b) {
			if (a == null || b == null) {
				return;
			}
			Node aFather = findFather(a);
			Node bFather = findFather(b);
			if (aFather != bFather) {
				int aFrank = rankMap.get(aFather);
				int bFrank = rankMap.get(bFather);
				if (aFrank <= bFrank) {
					fatherMap.put(aFather, bFather);
					rankMap.put(bFather, aFrank + bFrank);
				} else {
					fatherMap.put(bFather, aFather);
					rankMap.put(aFather, aFrank + bFrank);
				}
			}
		}
	}

	public static class EdgeComparator implements Comparator<Edge> {
		@Override
		public int compare(Edge o1, Edge o2) {
			return o1.weight - o2.weight;
		}
	}

	public static Set<Edge> kruskalMST(Graph graph) {
		UnionFind unionFind = new UnionFind();
		unionFind.makeSets(graph.nodes.values());  //所有的节点放进并查集；用来判断是否产生了回路；

		//优先级队列，按照权重小的在前边的顺序；
		PriorityQueue<Edge> priorityQueue = new PriorityQueue<>(new EdgeComparator());

		for (Edge edge : graph.edges) {  // 都放进优先级队列中；
			priorityQueue.add(edge);
		}

		Set<Edge> result = new HashSet<>();
		while (!priorityQueue.isEmpty()) {
			Edge edge = priorityQueue.poll();  //每次从小根堆中弹出一个边，
			if (!unionFind.isSameSet(edge.from, edge.to)) {  // 如果选择这条边之后，from节点和to节点就属于同一个集合了，就不要这条边了，因为有回路了，至于为什么代表节点相同，就是回路，自己看着上面的图示，画一下就直到了
				result.add(edge);  // 否则：就要这条边，
				unionFind.union(edge.from, edge.to);  // 然后把这个边的from节点和to节点所在的集合合并，
			}
		}
		return result;
	}
}
```

<br/>

<br/>

#### p算法

按照点来考察，随便找一个点，然后考虑它的所有边，找到权值最小且to node没有出现过的内条边， 加入结果集，再把to node的所有边都放进优先级队列中，继续找权值最小，且 to node 没有出现过的，重复此循环即可，过程中不用担心加边加到死循环，因为从优先级队列中取边的时候，会判断这条边的 to node 是否出现过，如果这条边是之前已经出现过的，那么它的to node 一定出现过了，就直接跳过了；

{% asset_img picture10.jpg %}

<br/>

k算法是用并查集来判断是否形成回路，形成了回路，就不要这条边

p算法是每次把一个点加入集合中来，所以使用一个hashset 就足够了，不牵扯到两个集合合并的问题；

<br/>

代码：

```java
public class Code_06_Prim {

	public static class EdgeComparator implements Comparator<Edge> {
		@Override
		public int compare(Edge o1, Edge o2) {
			return o1.weight - o2.weight;
		}
	}

	public static Set<Edge> primMST(Graph graph) {
		PriorityQueue<Edge> priorityQueue = new PriorityQueue<>(new EdgeComparator());
		HashSet<Node> set = new HashSet<>();
		Set<Edge> result = new HashSet<>();

		//这个for 循环是针对森林设计的，如果只有一张连通图，下面的if足够了；
		for (Node node : graph.nodes.values()) {

			//node: v1
			if (!set.contains(node)) {
				set.add(node);
				for (Edge edge : node.edges) {
					priorityQueue.add(edge);  // node的所有边加入到优先级队列中；
				}
				while (!priorityQueue.isEmpty()) {
					Edge edge = priorityQueue.poll();  // 弹出一个权重最小的边，
					Node toNode = edge.to;  		// 找到这个表的to node，如果一个边已经加过了，它的to node 一定已经加过了，
					if (!set.contains(toNode)) {  // 如果to node不在set中，
						set.add(toNode); 		 // 就加入set中；
						result.add(edge);
						for (Edge nextEdge : toNode.edges) {
							priorityQueue.add(nextEdge); // to node的后续所有边都加到优先级队列中；
						}
					}
				}
			}

		}
		return result;
	}
}

```

<br/>

<br/>

### Dijktra算法

适用范围：

有向图且没有权值为负数的边

<br/>

解决的问题：

找到一个点到其他所有点的最短距离

<br/>

图示

{% asset_img picture11.jpg %}

<br/>

过程

求A到其他各个节点的最短距离，准备一个map，key是A到哪个节点，value是最短距离，开始的时候，放入{A,0}，然后从map中取出{A,0}，说明A到A的最短距离为0，找到A到达的下一层节点，DBC，放入map，{C,10}{B,8}{D,2}，然后从中取出value值最小的，{D,2}，说明A到D的最短距离为2，然后找到D的下一层节点，BE，查看BE在map中是否存在，不存在直接加入,{E,6}，存在的话，取出来和现在能到达的最短距离相比，如果现在的小，就更新，所以C更新为{C,5}，重复此过程，直到map中没有值；

{% asset_img picture12.jpg %}

<br/>

代码

```java
public class Code_07_Dijkstra {

	public static HashMap<Node, Integer> dijkstra1(Node head) {
		//从head出来，到key的距离是多少？
		HashMap<Node, Integer> distanceMap = new HashMap<>();
		distanceMap.put(head, 0);
		HashSet<Node> selectedNodes = new HashSet<>();		//标记一个点是否计算过；

		Node minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);
		while (minNode != null) {
			int distance = distanceMap.get(minNode);  //最小距离
			for (Edge edge : minNode.edges) {
				Node toNode = edge.to;//下一层的一个节点，
				if (!distanceMap.containsKey(toNode)) {
					distanceMap.put(toNode, distance + edge.weight);//没有出现过，放到map中；
				}
				distanceMap.put(edge.to, Math.min(distanceMap.get(toNode), distance + edge.weight));//选择一个小的放进map
			}
			selectedNodes.add(minNode);//标记一下，已经找到了这个节点的最小节点，以后不再找到这个节点的最短距离了；
			minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);
		}
		return distanceMap;
	}

	//遍历找最小值的点，找的过程中排除在touchedNodes中的节点
	public static Node getMinDistanceAndUnselectedNode(HashMap<Node, Integer> distanceMap, HashSet<Node> touchedNodes) {
		Node minNode = null;
		int minDistance = Integer.MAX_VALUE;
		for (Entry<Node, Integer> entry : distanceMap.entrySet()) {
			Node node = entry.getKey();
			int distance = entry.getValue();
			if (!touchedNodes.contains(node) && distance < minDistance) { //在touchedNodes中的说明已经找到了到这个节点的最短距离，所以不用再碰他了
				minNode = node;
				minDistance = distance;
			}
		}
		return minNode;
	}

	public static class NodeRecord {
		public Node node;
		public int distance;

		public NodeRecord(Node node, int distance) {
			this.node = node;
			this.distance = distance;
		}
	}

	public static class NodeHeap {
		private Node[] nodes;
		private HashMap<Node, Integer> heapIndexMap;
		private HashMap<Node, Integer> distanceMap;
		private int size;

		public NodeHeap(int size) {
			nodes = new Node[size];
			heapIndexMap = new HashMap<>();
			distanceMap = new HashMap<>();
			this.size = 0;
		}

		public boolean isEmpty() {
			return size == 0;
		}

		public void addOrUpdateOrIgnore(Node node, int distance) {
			if (inHeap(node)) {
				distanceMap.put(node, Math.min(distanceMap.get(node), distance));
				insertHeapify(node, heapIndexMap.get(node));
			}
			if (!isEntered(node)) {
				nodes[size] = node;
				heapIndexMap.put(node, size);
				distanceMap.put(node, distance);
				insertHeapify(node, size++);
			}
		}

		public NodeRecord pop() {
			NodeRecord nodeRecord = new NodeRecord(nodes[0], distanceMap.get(nodes[0]));
			swap(0, size - 1);
			heapIndexMap.put(nodes[size - 1], -1);
			distanceMap.remove(nodes[size - 1]);
			nodes[size - 1] = null;
			heapify(0, --size);
			return nodeRecord;
		}

		private void insertHeapify(Node node, int index) {
			while (distanceMap.get(nodes[index]) < distanceMap.get(nodes[(index - 1) / 2])) {
				swap(index, (index - 1) / 2);
				index = (index - 1) / 2;
			}
		}

		private void heapify(int index, int size) {
			int left = index * 2 + 1;
			while (left < size) {
				int smallest = left + 1 < size && distanceMap.get(nodes[left + 1]) < distanceMap.get(nodes[left])
						? left + 1 : left;
				smallest = distanceMap.get(nodes[smallest]) < distanceMap.get(nodes[index]) ? smallest : index;
				if (smallest == index) {
					break;
				}
				swap(smallest, index);
				index = smallest;
				left = index * 2 + 1;
			}
		}

		private boolean isEntered(Node node) {
			return heapIndexMap.containsKey(node);
		}

		private boolean inHeap(Node node) {
			return isEntered(node) && heapIndexMap.get(node) != -1;
		}

		private void swap(int index1, int index2) {
			heapIndexMap.put(nodes[index1], index2);
			heapIndexMap.put(nodes[index2], index1);
			Node tmp = nodes[index1];
			nodes[index1] = nodes[index2];
			nodes[index2] = tmp;
		}
	}

	public static HashMap<Node, Integer> dijkstra2(Node head, int size) {
		NodeHeap nodeHeap = new NodeHeap(size);
		nodeHeap.addOrUpdateOrIgnore(head, 0);
		HashMap<Node, Integer> result = new HashMap<>();
		while (!nodeHeap.isEmpty()) {
			NodeRecord record = nodeHeap.pop();
			Node cur = record.node;
			int distance = record.distance;
			for (Edge edge : cur.edges) {
				nodeHeap.addOrUpdateOrIgnore(edge.to, edge.weight + distance);
			}
			result.put(cur, distance);
		}
		return result;
	}
}
```

