---
title: 算法基础第三课
categories:
  - leetcode
abbrlink: c2bc9d2e
date: 2019-02-23 12:18:40
---

### 用数组结构实现大小固定的队列和栈

<br/>

#### 栈

{% asset_img picture1.jpg %}

<br/>

代码：

```java
public static class ArrayStack {//固定数组，实现栈
    private Integer[] arr;
    private Integer index;//如果把数组竖着排，index就是第一个。

    public ArrayStack(int initSize) {
        if (initSize < 0) {
            throw new IllegalArgumentException("The init size is less than 0");
        }
        arr = new Integer[initSize];
        index = 0;
    }

    public void push(Integer x) {
        if (index == arr.length) {    //先赋值，再自增，所以index最终不能使用的位置是arr.length，也就是数组再向上一个位置。
            throw new IllegalArgumentException("stack is full");
        }
        arr[index++] = x;
    }

    public Integer pop() {
        if (index == 0) {     //先自减，再赋值,所以index最终不能使用的位置是0，也就是指向数组最下方的位置。
            throw new IllegalArgumentException("stack is empty");
        }
        return arr[--index];
    }
}
```

<br/>

#### 队列

{% asset_img picture2.jpg %}

<br/>

可以省略size，但是会导致非常麻烦，加上size，就不用管start和end之间的关系，用size约束start和end，代码会变得非常简单；

<br/>

代码

```java
/**
     * 相当于一个循环数组
     * start 永远追着end跑
     * size 就相当于他们之间的距离，所以不能超过初始设定的数组长度。
     * start都在向下移动，所以都是++操作。
     */
public static class ArrayQueue {
    private Integer[] arr;
    private Integer size;
    private Integer start;
    private Integer end;

    public ArrayQueue(int initSize) {
        if (initSize < 0) {
            throw new IllegalArgumentException("The init size is less than 0");
        }
        arr = new Integer[initSize];
        size = 0;
        start = 0;  //first 指向第一个
        end = 0;    //end 指向最后一个
    }

    public Integer peek() {
        if (size == 0) {
            return null;
        }
        return arr[start];
    }

    public void push(Integer x) {
        if (size == arr.length) {
            throw new IllegalArgumentException("stack is full");
        }
        size++;//size 自增1.
        arr[end] = x;
        end = (end == arr.length - 1) ? 0 : end++;
    }

    public Integer poll(){
        if(size == 0){
            throw new IllegalArgumentException("stack is empty");
        }
        size--; //poll一个相当于追上了一步，所以size（两人之间的距离-1）
        int temp = start;
        start = (start == arr.length - 1) ? 0 : start++;//都在向下跑，且初始值都是0，所以判断条件都是 == arr.length-1，意思就是跑到底了。
        return arr[temp];
    }
}
```

<br/>

<br/>

### 实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返 回栈中最小元素的操作。

<br/>

【要求】 

1. pop、push、getMin操作的时间复杂度都是O(1)。 
2. 设计的栈类型可以使用现成的栈结构。

<br/>

思路：

两个栈，data栈，min栈，

增加一个维持getMin( ) 的栈的数据结构，每次data栈压入一个值，min栈也压入一个值，如果压入的数字比min栈的值小，min栈也压入当前数，如果压入的数字比min栈大，min栈就取出栈顶的数重新压入

{% asset_img picture3.jpg %}

<br/>

代码：

```java
public static class MyStack2 {
    private Stack<Integer> stackData;
    private Stack<Integer> stackMin;

    public MyStack2() {
        this.stackData = new Stack<Integer>();
        this.stackMin = new Stack<Integer>();
    }

    public void push(int newNum) {
        if (this.stackMin.isEmpty()) {
            this.stackMin.push(newNum);
        } else if (newNum < this.getmin()) {
            this.stackMin.push(newNum);
        } else {
            int newMin = this.stackMin.peek();
            this.stackMin.push(newMin);
        }
        this.stackData.push(newNum);
    }

    public int pop() {
        if (this.stackData.isEmpty()) {
            throw new RuntimeException("Your stack is empty.");
        }
        this.stackMin.pop();
        return this.stackData.pop();
    }

    public int getmin() {
        if (this.stackMin.isEmpty()) {
            throw new RuntimeException("Your stack is empty.");
        }
        return this.stackMin.peek();
    }
}
```

<br/>

<br/>

### 如何仅用队列结构实现栈结构？

<br/>

思路：

push的时候直接往data队列里扔。
pop的时候先把之前的所有数字放到help队列，只剩最后一个，返回，然后把help队列变为data队列，下次pop的时候仍然执行此操作。

{% asset_img picture4.jpg %}

<br/>

代码：

```java
public static class TwoQueuesStack {
    private Queue<Integer> data;
    private Queue<Integer> help;

    public TwoQueuesStack() {
        data = new LinkedList<Integer>();
        help = new LinkedList<Integer>();
    }

    public void push(Integer x){
        data.add(x);
    }

    public Integer poll(){
        if (data.isEmpty()) {
            throw new RuntimeException("Stack is empty!");
        }

        while(data.size() > 1){
            help.add(data.poll());  //之前的全部放到help队列中，只剩最后一个
        }
        int res = data.poll();  //最后一个要取的就是结果
        swap();
        return res;
    }

    /**
         * 交换两个队列的引用
         * 使得下次poll取数据的时候，还是从data队列中取，然后把除最后一个以外的都放到help队列。
         */
    private void swap() {
        Queue<Integer> tmp = help;
        help = data;
        data = tmp;
    }
}
```

<br/>

### 如何仅用栈结构实现队列结构？

<br/>

思路

用户新给一个数，永远进push栈，用户想要一个数，永远从pop栈取

数先进push栈，取数字的时候，把push栈的数据导入pop栈，再从pop栈取数据

{% asset_img picture5.jpg %}

<br/>

两个限制：

1. 如果push栈要往pop栈里面倒，一次要倒完
2. 如果pop栈里面有东西，一定不要倒了。

<br/>

代码：

```java
public static class TwoStacksQueue {
    private Stack<Integer> stackPush;
    private Stack<Integer> stackPop;

    public TwoStacksQueue() {
        stackPush = new Stack<Integer>();
        stackPop = new Stack<Integer>();
    }

    public void push(int pushInt) {
        stackPush.push(pushInt);
    }

    public Integer poll(){

        if (stackPop.empty() && stackPush.empty()) {
            throw new RuntimeException("Queue is empty!");
        }else if(stackPop.isEmpty()){//第一个限制条件：Pop栈一定为空时才能倒。
            while(!stackPush.isEmpty()){//第二个限制条件：只要倒，就一定要倒完。
                stackPop.push(stackPush.pop());//从stackPush倒数据到stackPop。
            }
        }
        return stackPop.pop();//返回pop栈的第一个。
    }
}
```

<br/>

### 猫狗问题

```java
public class Pet { 
    private String type; 
    public Pet(String type) { this.type = type; } 
    public String getPetType() { return this.type; } } 
public class Dog extends Pet { public Dog() { super("dog"); } } 
public class Cat extends Pet { public Cat() { super("cat"); } }
```

<br/>

实现一种狗猫队列的结构，要求如下： 用户可以调用add方法将cat类或dog类的 实例放入队列中； 用户可以调用pollAll方法，将队列中所有的实例按照进队列 的先后顺序依次弹出； 用户可以调用pollDog方法，将队列中dog类的实例按照 进队列的先后顺序依次弹出； 用户可以调用pollCat方法，将队列中cat类的实 例按照进队列的先后顺序依次弹出； 用户可以调用isEmpty方法，检查队列中是 否还有dog或cat的实例； 用户可以调用isDogEmpty方法，检查队列中是否有dog 类的实例； 用户可以调用isCatEmpty方法，检查队列中是否有cat类的实例。

<br/>

思路：

猫狗各自一个队列，每个进来的宠物添加上一个时间戳，这样调用 pollAll 方法的时候，从两个队列中各自取一个，再比较取得的两个pe的时间戳，取较小的内个

{% asset_img picture6.jpg %}

<br/>

代码：

```java
public class Code_04_DogCatQueue {

    public static class Pet {
        private String type;

        public Pet(String type) {
            this.type = type;
        }

        public String getPetType() {
            return this.type;
        }
    }

    public static class Dog extends Pet {
        public Dog() {
            super("dog");
        }
    }

    public static class Cat extends Pet {
        public Cat() {
            super("cat");
        }
    }

    public static class PetEnterQueue {
        private Pet pet;
        private long count;

        public PetEnterQueue(Pet pet, long count) {
            this.pet = pet;
            this.count = count;
        }

        public Pet getPet() {
            return this.pet;
        }

        public long getCount() {
            return this.count;
        }

        public String getEnterPetType() {
            return this.pet.getPetType();
        }
    }

    public static class DogCatQueue {
        private Queue<PetEnterQueue> dogQ;
        private Queue<PetEnterQueue> catQ;
        private long count;

        public DogCatQueue() {
            this.dogQ = new LinkedList<PetEnterQueue>();
            this.catQ = new LinkedList<PetEnterQueue>();
            this.count = 0;
        }

        public void add(Pet pet) {
            if (pet.getPetType().equals("dog")) {
                this.dogQ.add(new PetEnterQueue(pet, this.count++));
            } else if (pet.getPetType().equals("cat")) {
                this.catQ.add(new PetEnterQueue(pet, this.count++));
            } else {
                throw new RuntimeException("err, not dog or cat");
            }
        }

        public Pet pollAll() {
            if (!this.dogQ.isEmpty() && !this.catQ.isEmpty()) {
                if (this.dogQ.peek().getCount() < this.catQ.peek().getCount()) {
                    return this.dogQ.poll().getPet();
                } else {
                    return this.catQ.poll().getPet();
                }
            } else if (!this.dogQ.isEmpty()) {
                return this.dogQ.poll().getPet();
            } else if (!this.catQ.isEmpty()) {
                return this.catQ.poll().getPet();
            } else {
                throw new RuntimeException("err, queue is empty!");
            }
        }

        public Dog pollDog() {
            if (!this.isDogQueueEmpty()) {
                return (Dog) this.dogQ.poll().getPet();
            } else {
                throw new RuntimeException("Dog queue is empty!");
            }
        }

        public Cat pollCat() {
            if (!this.isCatQueueEmpty()) {
                return (Cat) this.catQ.poll().getPet();
            } else
                throw new RuntimeException("Cat queue is empty!");
        }

        public boolean isEmpty() {
            return this.dogQ.isEmpty() && this.catQ.isEmpty();
        }

        public boolean isDogQueueEmpty() {
            return this.dogQ.isEmpty();
        }

        public boolean isCatQueueEmpty() {
            return this.catQ.isEmpty();
        }

    }

    public static void main(String[] args) {
        DogCatQueue test = new DogCatQueue();

        Pet dog1 = new Dog();
        Pet cat1 = new Cat();
        Pet dog2 = new Dog();
        Pet cat2 = new Cat();
        Pet dog3 = new Dog();
        Pet cat3 = new Cat();

        test.add(dog1);
        test.add(cat1);
        test.add(dog2);
        test.add(cat2);
        test.add(dog3);
        test.add(cat3);

        test.add(dog1);
        test.add(cat1);
        test.add(dog2);
        test.add(cat2);
        test.add(dog3);
        test.add(cat3);

        test.add(dog1);
        test.add(cat1);
        test.add(dog2);
        test.add(cat2);
        test.add(dog3);
        test.add(cat3);
        while (!test.isDogQueueEmpty()) {
            System.out.println(test.pollDog().getPetType());
        }
        while (!test.isEmpty()) {
            System.out.println(test.pollAll().getPetType());
        }
    }
}
```

<br/>

<br/>

### 转圈打印矩阵

要求

空间复杂度O(1)

<br/>

思路：

给定左上角的一个点，右上角的一个点，然后按照顺时针的方向，打印一圈，这个是很容易实现的，然后左上角的点向右下角移动一个位置，右下角的位置向左上角移动一个位置，再打印一圈。。。。

{% asset_img picture7.jpg %}

{% asset_img picture8.jpg %}

<br/>

代码：

```java
public class Code_06_PrintMatrixSpiralOrder {
    public static void spiralOrderPrint(int[][] matrix) {
        //左上角
        int tR = 0;
        int tC = 0;
        //右下角
        int dR = matrix.length - 1;
        int dC = matrix[0].length - 1;

        /**
         * 一圈一圈的打印，
         * 一圈打印完成之后，
         * 左上角向右下角移动一个位置，右下角向左上角移动一个位置。
         * 然后重复此过程
         * 直到有行或列冲突了，停止。
         */
        while (tR <= dR && tC <= dC) {
            printEdge(matrix, tR++, tC++, dR--, dC--);
        }
    }

    /**
     * 打印一圈
     * @param m
     * @param tR    左上角
     * @param tC    右上角
     * @param dR    左下角
     * @param dC    右下角
     */
    public static void printEdge(int[][] m, int tR, int tC, int dR, int dC) {
        if (tR == dR) {                             //一行
            for (int i = tC; i <= dC; i++) {
                System.out.print(m[tR][i] + " ");
            }
        } else if (tC == dC) {                      //一列
            for (int i = tR; i <= dR; i++) {
                System.out.print(m[i][tC] + " ");
            }
        } else {
            int curC = tC;
            int curR = tR;
            while (curC != dC) {                   //上
                System.out.print(m[tR][curC] + " ");
                curC++;
            }
            while (curR != dR) {                    //右
                System.out.print(m[curR][dC] + " ");
                curR++;
            }
            while (curC != tC) {                    //下
                System.out.print(m[dR][curC] + " ");
                curC--;
            }
            while (curR != tR) {                    //左
                System.out.print(m[curR][tC] + " ");
                curR--;
            }
        }
    }

    public static void main(String[] args) {
        int[][] matrix = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 },
                { 13, 14, 15, 16 } };
        spiralOrderPrint(matrix);
    }
}
```

<br/>

### 旋转正方形矩阵

要求

额外空间复杂度为O(1)。

<br/>

思路

还是利用分圈结构，四个点为一组，按照顺序交换位置，具体看图示

{% asset_img picture9.jpg %}

<br/>

代码：

```java
public class Code_05_RotateMatrix {
    public static void rotate(int[][] matrix) {
        int tR = 0;
        int tC = 0;
        int dR = matrix.length - 1;
        int dC = matrix[0].length - 1;
        while (tR < dR) {
            rotateEdge(matrix, tR++, tC++, dR--, dC--);
        }
    }

    /**
     * 一定是长方形
     * 根据两个对角的值进行旋转，每次旋转一个圈。
     * @param m
     * @param tR    左上角行号
     * @param tC    左上角列号
     * @param dR    右下角行号
     * @param dC    右下角列号
     */
    public static void rotateEdge(int[][] m, int tR, int tC, int dR, int dC) {
        int times = dC - tC;//列号相减，也就求出了每行或者每列要有多少个数字进行旋转，也就是下面的for循环要执行的次数。
        int tmp = 0;
        //每一个要旋转的数字，
        // 4个点之间进行互换位置。
        for (int i = 0; i != times; i++) {
            tmp = m[tR][tC + i];//首先记下第一个要换的数字，因为要被覆盖。
            m[tR][tC + i] = m[dR - i][tC];  //第四个点占据第一个点的位置
            m[dR - i][tC] = m[dR][dC - i];  //第三个点占据第四个点的位置
            m[dR][dC - i] = m[tR + i][dC];  //第二个点占据第三个点的位置
            m[tR + i][dC] = tmp;  // 第一个点占据第二个点的位置
        }
    }

    public static void printMatrix(int[][] matrix) {
        for (int i = 0; i != matrix.length; i++) {
            for (int j = 0; j != matrix[0].length; j++) {
                System.out.print(matrix[i][j] + " ");
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        int[][] matrix = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 },
                { 13, 14, 15, 16 } };
        printMatrix(matrix);
        rotate(matrix);
        System.out.println("=========");
        printMatrix(matrix);
    }
}

```

<br/>

<br/>

### 之字形打印矩阵

<br/>

思路：

AB都从 （0，0） 开始，A往右走，B往下走，A走到最右了，就往下走，B走到最下了，就往右走，AB第二次重合时结束。A，B 走 是独立的，每次都走一步；实现一个函数，给定右上的点和左下的点，再给定一个boolean类型变量，为true代表从上往下，false 代表从下往上；

{% asset_img picture10.jpg %}

<br/>

代码：

```java
public class Code_08_ZigZagPrintMatrix {

    public static void printMatrixZigZag(int[][] matrix) {
        int aR = 0;
        int aC = 0;
        //右下角
        int bR = 0;
        int bC = 0;
        int endR = matrix.length - 1;       //结束行
        int endC = matrix[0].length - 1;    //结束列
        boolean fromUp = false;
        while (aR != endR + 1) {            //A点的行没有到右下角所在的行，就循环，因为A是先向右，再向下
            printLevel(matrix, aR, aC, bR, bC, fromUp);
            aR = aC == endC ? aR + 1 : aR;  //如果A点的列到了最后一列，就把A的行向下移动。
            aC = aC == endC ? aC : aC + 1;  //如果A点的列到了最后一列，A的列就不变了，否则，一直向右。
            bC = bR == endR ? bC + 1 : bC;  //如果B点的行到了最后一行，就向右，
            bR = bR == endR ? bR : bR + 1;
            fromUp = !fromUp;
        }
        System.out.println();
    }

    /**
     * 根据对角（两个点）
     * 按照对角线打印。
     */
    public static void printLevel(int[][] m, int tR, int tC, int dR, int dC,
                                  boolean f) {
        if (f) {//从上往下打印
            while (tR != dR + 1) {
                System.out.print(m[tR++][tC--] + " ");//行++，列--
            }
        } else {//从下往上打印
            while (dR != tR - 1) {
                System.out.print(m[dR--][dC++] + " ");//行--，列++
            }
        }
    }

    public static void main(String[] args) {
        int[][] matrix = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } };
        printMatrixZigZag(matrix);
    }
}

```

<br/>

<br/>

### 在行列都排好序的矩阵中找数

要求

时间复杂度为O(N+M)，额外空间复杂度为O(1)。

<br/>

思路：

从右上角开始走，只要要找的数比当前的数小，就往左走，下面的数肯定都被淘汰了，比当前的数大，就往下走，左边的数都被淘汰，最终找到；

{% asset_img picture11.jpg %}

<br/>

代码：

```java
public class Code_09_FindNumInSortedMatrix {
    public static boolean isContains(int[][] matrix, int K) {
        int row = 0;
        int col = matrix[0].length - 1;
        //从右上角开始找的。所以只能往左，或者往下查找。
        while (row < matrix.length && col > -1) {
            if (matrix[row][col] == K) {
                return true;
            } else if (matrix[row][col] > K) {//大于目标值，向左移动。
                col--;
            } else {    //否则：向下移动
                row++;
            }
        }
        return false;
    }

    public static void main(String[] args) {
        int[][] matrix = new int[][] { { 0, 1, 2, 3, 4, 5, 6 },// 0
                { 10, 12, 13, 15, 16, 17, 18 },// 1
                { 23, 24, 25, 26, 27, 28, 29 },// 2
                { 44, 45, 46, 47, 48, 49, 50 },// 3
                { 65, 66, 67, 68, 69, 70, 71 },// 4
                { 96, 97, 98, 99, 100, 111, 122 },// 5
                { 166, 176, 186, 187, 190, 195, 200 },// 6
                { 233, 243, 321, 341, 356, 370, 380 } // 7
        };
        int K = 233;
        System.out.println(isContains(matrix, K));
    }
}

```

<br/>

<br/>

### 打印两个链表的公共部分

<br/>

思路

外排

<br/>

代码：

```java
public class Code_10_PrintCommonPart {
    
    public static class Node {
        public int value;
        public Node next;
        public Node(int data) {
            this.value = data;
        }
    }
    /**
     * 其实就是外排的过程
     */
    public static void printCommonPart(Node head1, Node head2) {
        System.out.print("Common Part: ");
        while (head1 != null && head2 != null) {
            if (head1.value < head2.value) {
                head1 = head1.next;
            } else if (head1.value > head2.value) {
                head2 = head2.next;
            } else {
                System.out.print(head1.value + " ");
                head1 = head1.next;
                head2 = head2.next;
            }
        }
        System.out.println();
    }

    public static void printLinkedList(Node node) {
        System.out.print("Linked List: ");
        while (node != null) {
            System.out.print(node.value + " ");
            node = node.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        Node node1 = new Node(2);
        node1.next = new Node(3);
        node1.next.next = new Node(5);
        node1.next.next.next = new Node(6);

        Node node2 = new Node(1);
        node2.next = new Node(2);
        node2.next.next = new Node(5);
        node2.next.next.next = new Node(7);
        node2.next.next.next.next = new Node(8);

        printLinkedList(node1);
        printLinkedList(node2);
        printCommonPart(node1, node2);
    }
}

```

<br/>

<br/>

### 判断一个链表是否为回文结构

**链表的难度都在额外空间复杂度上**

例如： 1->2->1，返回true。 1->2->2->1，返回true。 15->6->15，返回true。 1->2->3，返回false。

<br/>

思路一：

放进栈里，再取出来，从头结点遍历，看是否完全一致

<br/>

代码：

```java
//第一种方法：使用栈
// need n extra space
public static boolean isPalindrome1(Node head) {
    Stack<Node> stack = new Stack<Node>();
    Node cur = head;
    while (cur != null) {
        stack.push(cur);
        cur = cur.next;
    }
    while (head != null) {
        if (head.value != stack.pop().value) {
            return false;
        }
        head = head.next;
    }
    return true;
}

```

<br/>

思路二：

快慢指针，快指针走完的时候，慢指针一定在中点的位置，此时慢指针继续往后走，然后每走一步，都放进栈里；

然后再从头结点开始遍历，从栈中弹出元素，和此时遍历的节点比较，不相等，说明不是回文结构，栈弹完了，都没有碰到不相等的，说明是回文结构，

方法的本质就是：相当于只把后半段逆序，然后和前半段比较。

空间复杂度  O(N/2)

<br/>

代码：

```java
//第二种方法：栈（但是只装一半数据）
// need n/2 extra space
public static boolean isPalindrome2(Node head) {
    if (head == null || head.next == null) {
        return true;
    }
    Node right = head.next;     //慢指针从第二个数字开始走
    Node cur = head;            //快指针
    while (cur.next != null && cur.next.next != null) {
        right = right.next;     //慢指针一次走一步
        cur = cur.next.next;    //快指针一次走两步
    }
    Stack<Node> stack = new Stack<Node>();
    while (right != null) {
        stack.push(right);//如果是1，2，3，2，1    那么stack中是2,1
        right = right.next;
    }
    while (!stack.isEmpty()) {
        if (head.value != stack.pop().value) {
            return false;
        }
        head = head.next;
    }
    return true;
}

```

<br/>

<br/>

思路三：

快慢指针，快指针走完的时候，慢指针一定在中点的位置，此时把后半段链表倒序，然后一个指针从头结点开始，一个指针从尾节点开始，遍历比较大小，遍历到中间节点停，中间有任何不相等，返回false，说明不是回文结构

要注意的是最后要把链表恢复原来的样子

空间复杂度 O(1)

<br/>

代码：

```java
// need O(1) extra space
public static boolean isPalindrome3(Node head) {
    if (head == null || head.next == null) {
        return true;
    }
    Node n1 = head;//慢指针
    Node n2 = head;//快指针
    while (n2.next != null && n2.next.next != null) { //奇数个会来到中点，偶数个来到中点前一个。
        n1 = n1.next; // n1 -> mid
        n2 = n2.next.next; // n2 -> end
    }
    n2 = n1.next; // n2 -> right part first node
    n1.next = null; // mid.next -> null
    Node n3 = null;

    //反转链表
    while (n2 != null) { // right part convert
        n3 = n2.next; // n3 -> save next node
        n2.next = n1; // next of right node convert
        n1 = n2; // n1 move
        n2 = n3; // n2 move
    }

    n3 = n1; // n3 -> save last node
    n2 = head;// n2 -> left first node
    boolean res = true;
    while (n1 != null && n2 != null) { // check palindrome
        if (n1.value != n2.value) {
            res = false;
            break;
        }
        n1 = n1.next; // left to mid
        n2 = n2.next; // right to mid
    }
    n1 = n3.next;
    n3.next = null;
    while (n1 != null) { // recover list
        n2 = n1.next;
        n1.next = n3;
        n3 = n1;
        n1 = n2;
    }
    return res;
}

```

<br/>

### 链表的荷兰国旗问题

将单向链表按某值划分成左边小、中间相等、右边大的形式

<br/>

思路一：

把链表的值全部放进数组中，然后进行荷兰国旗问题，最后再串起来。

<br/>

进阶：

保持稳定性，同时要求：时间复杂度请达到O(N)，额外空间复杂度请达到O(1)。

<br/>

思路

三个变量，less，equal，more 都是节点类型，对链表进行一次遍历，找到第一个小于num的变量，赋给less，找到第一个等于num的变量，赋给equal，找到第一个大于num的变量，赋给more，一次遍历，为三个变量赋值。相当于定义了三个区域，每个区域两个变量（less和end，equal和end，more和end），每次遇到小于num的，挂在less开头的链表上，等于num的，挂在equal开头的链表上，大于num的，挂在more开头的链表上，最后把第一个区域的end和第二个区域的equal相连，第二个区域的end和第三个区域的more相连；

本质就是把一个大链表拆成三个小链表，然后再把三个小链表和并在一起的过程。

{% asset_img picture12.jpg %}

<br/>

代码：

```java
public class Code_12_SmallerEqualBigger {

    public static class Node {
        public int value;
        public Node next;

        public Node(int data) {
            this.value = data;
        }
    }

    public static Node listPartition1(Node head, int pivot) {
        if (head == null) {
            return head;
        }
        Node cur = head;
        int i = 0;
        while (cur != null) {
            i++;
            cur = cur.next;
        }
        Node[] nodeArr = new Node[i];
        i = 0;
        cur = head;
        for (i = 0; i != nodeArr.length; i++) {
            nodeArr[i] = cur;
            cur = cur.next;
        }
        arrPartition(nodeArr, pivot);
        for (i = 1; i != nodeArr.length; i++) {
            nodeArr[i - 1].next = nodeArr[i];
        }
        nodeArr[i - 1].next = null;
        return nodeArr[0];
    }

    public static void arrPartition(Node[] nodeArr, int pivot) {
        int small = -1;
        int big = nodeArr.length;
        int index = 0;
        while (index != big) {
            if (nodeArr[index].value < pivot) {
                swap(nodeArr, ++small, index++);
            } else if (nodeArr[index].value == pivot) {
                index++;
            } else {
                swap(nodeArr, --big, index);
            }
        }
    }

    public static void swap(Node[] nodeArr, int a, int b) {
        Node tmp = nodeArr[a];
        nodeArr[a] = nodeArr[b];
        nodeArr[b] = tmp;
    }

    public static Node listPartition2(Node head, int pivot) {
        Node sH = null; // small head
        Node sT = null; // small tail
        Node eH = null; // equal head
        Node eT = null; // equal tail
        Node bH = null; // big head
        Node bT = null; // big tail
        Node next = null; // save next node
        // every node distributed to three lists
        while (head != null) {
            next = head.next;
            head.next = null;
            if (head.value < pivot) {
                if (sH == null) {
                    sH = head;
                    sT = head;
                } else {
                    sT.next = head;
                    sT = head;
                }
            } else if (head.value == pivot) {
                if (eH == null) {
                    eH = head;
                    eT = head;
                } else {
                    eT.next = head;
                    eT = head;
                }
            } else {
                if (bH == null) {
                    bH = head;
                    bT = head;
                } else {
                    bT.next = head;
                    bT = head;
                }
            }
            head = next;
        }
        // small and equal reconnect
        if (sT != null) {
            sT.next = eH;
            eT = eT == null ? sT : eT;
        }
        // all reconnect
        if (eT != null) {
            eT.next = bH;
        }
        return sH != null ? sH : eH != null ? eH : bH;
    }

    public static void printLinkedList(Node node) {
        System.out.print("Linked List: ");
        while (node != null) {
            System.out.print(node.value + " ");
            node = node.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        Node head1 = new Node(7);
        head1.next = new Node(9);
        head1.next.next = new Node(1);
        head1.next.next.next = new Node(8);
        head1.next.next.next.next = new Node(5);
        head1.next.next.next.next.next = new Node(2);
        head1.next.next.next.next.next.next = new Node(5);
        //        printLinkedList(head1);
        // head1 = listPartition1(head1, 4);
        head1 = listPartition2(head1, 5);
        printLinkedList(head1);
    }
}

```

<br/>

<br/>

### 复制含有随机指针节点的链表

Node类中的value是节点值，next指针和正常单链表中next指针的意义 一 样，都指向下一个节点，rand指针是Node类中新增的指针，这个指 针可 能指向链表中的任意一个节点，也可能指向null。 给定一个由 Node节点类型组成的无环单链表的头节点head，请实现一个 函数完成 这个链表中所有结构的复制，并返回复制的新链表的头节点。 进阶： 不使用额外的数据结构，只用有限几个变量，且在时间复杂度为 O(N) 内完成原问题要实现的函数。

<br/>

思路1：

一个哈希表，先遍历一遍链表，把每个节点和它的复制节点作为key和value 放进哈希表；再次遍历链表，遍历1，然后用1作为key从哈希表中找到1的复制节点1’，此时1‘的next指针和random指针都没连，此时可以正确的设置1’的next指针和random指针，因为1的next可以找到2，然后从哈希表中利用2作为key找到2‘，然后把1’的next指向2‘。然后找到1的random指针3，从哈希表中，取出3的复制节点3‘。赋值给1’的random指针；遍历2和3时重复此步骤即可；

额外空间复杂度O(N)

{% asset_img picture13.jpg %}

<br/>

代码：

```java
/**
     *  方法一：使用hashmap，
     *  两个链表压根就没有发生过联系，就只是通过map联系起来的。
     */
public static Node copyListWithRand1(Node head) {
    HashMap<Node, Node> map = new HashMap<Node, Node>();
    Node cur = head;
    while (cur != null) {   //生成每个节点的拷贝节点，
        map.put(cur, new Node(cur.value));//new Node 就是生成的拷贝节点。
        cur = cur.next;
    }
    cur = head;
    while (cur != null) {  //为每个拷贝节点的next节点和random节点赋值
        map.get(cur).next = map.get(cur.next);// 1' 的next指针应该指向1的next指针的内个节点的拷贝节点，
        map.get(cur).rand = map.get(cur.rand);
        cur = cur.next;
    }
    return map.get(head);//返回原始头链表的拷贝节点：也就是1' 节点
}

```

<br/>

思路2：

遍历节点，1的拷贝节点1‘放在1的next指针上，1’的next指针指向2，2的拷贝节点2‘放在2的next指针上，2’的next指针指向3，后面的节点都这么放，然后要做的事就是正确的设置好复制节点的random指针，再次遍历大链表，一次拿出两个节点，比如1和1‘，取出来，赋给两个变量，然后通过1的random找到3，如何找到3的拷贝节点呢，原来是通过在哈希表中取出3的拷贝节点，但是现在这种结构导致一个节点的拷贝节点都是这个节点的下一个，所以可以通过3的next找到3’，然后赋值给1‘的random指针，就完成了，以此放下走；2和3都这么处理；

本质就是用一个节点的拷贝节点放在这个节点的后面的方式，来省掉了map，**但是还是解决的3怎么找到3’的问题**，之前是用哈希对应的关系找，现在是用一个节点的拷贝节点放在这个节点的后面的方式，以此来省掉了空间复杂度

注意最后还要把整个链表分开，原节点和复制节点的random指针是不互相干预的， 所以只需要把random指针分开即可；

{% asset_img picture14.jpg %}

<br/>

### 两个单链表相交的一系列问题

在本题中，单链表可能有环，也可能无环。给定两个单链表的头节点 head1和head2，这两个链表可能相交，也可能不相交。请实现一个函数， 如果两个链表相交，请返回相交的第一个节点；如果不相交，返回null即可。 要求：如果链表1 的长度为N，链表2的长度为M，时间复杂度请达到 O(N+M)，额外空间复杂度请达到 O(1)。

<br/>

#### 子问题：判断有环还是无环，有环返回第一个入环节点，无环返回空

思路1：

哈希表，节点放进map中，第一个重合的节点就是入环节点，如果遍历完了都没有发现重合节点，说明无环，返回null

<br/>

思路二：快慢指针：

如果快指针遇到null了，说明肯定无环，如果有环，快慢指针一定会在环上相遇，相遇的时候，快指针回到头结点，然后快指针由一次走两步改为一次走一步，快指针和慢指针一定会在第一个入环节点处相遇；

<br/>

#### 情况一： 两个链表都无环，返回相交节点：

<br/>

思路一：map

用map，把链表一全部遍历放进map，然后遍历链表二，查看map中是否存在当前节点，第一个重合的节点就是相交节点。

<br/>

思路二：不用map

先遍历链表一，统计链表一的长度，以及拿到最后一个节点，遍历链表二，统计链表二的长度，拿到链表二的最后一个节点。然后判断两个end是否相等（内存地址相等），如果end1不等于end2，这两个节点不可能相交，如果end1等于end2，说明相交，假设链表一长度为100，链表二长度为80，那么就让链表一先走20步，然后让两个链表一起走，他们一定会同时走到第一个相交节点；

<br/>

#### 情况二：一个链表有环，一个链表无环：

此时一定不能相交；

<br/>

#### 情况三：两个链表都有环：返回相交节点

三种拓扑结构：

1. 各自成环，此时不可能相交，
2. 先相交，然后共享一个环，
3. 开始不相交，最后合并到一个环上

{% asset_img picture15.jpg %}

<br/>

思路：

head1，loop1，head2，loop2，足以区分；

如果loop1等于loop2，说明是情况2，这种情况下，如何求他的第一个相交节点，其实等同于无环链表的相交情况，无环链表是以空位置作为结尾，现在让他以loop1为结尾，就变成了单链表无环情况下的相交问题，此时环是不影响的；

如果loop1不等于loop2，说明是情况1或者情况3，怎么区分？让loop1继续以next的方式往下走，如果最后又回到loop1的时候，仍然没有遇到loop2，说明是情况1，如果在转的过程中遇到了loop2，就说明是情况3，此时返回loop1作为第一个相交节点还是返回loop2作为第一个相交的节点，都对；loop1和loop2的区别只是距离哪个head更近的问题而已

<br/>

#### 代码

```java
public class Code_14_FindFirstIntersectNode {
    public static class Node {
        public int value;
        public Node next;

        public Node(int data) {
            this.value = data;
        }
    }
    /**
     * 主函数
     * @param head1 第一个链表
     * @param head2 第二个链表
     * @return  两个链表的第一个相交节点，
     */
    public static Node getIntersectNode(Node head1, Node head2) {
        if (head1 == null || head2 == null) {
            return null;
        }
        Node loop1 = getLoopNode(head1);
        Node loop2 = getLoopNode(head2);
        if (loop1 == null && loop2 == null) {
            return noLoop(head1, head2);
        }
        if (loop1 != null && loop2 != null) {
            return bothLoop(head1, loop1, head2, loop2);
        }
        //如果一个有环，一个无环，肯定不会有相交节点。
        return null;
    }

    /**
     * 返回第一个入环的节点
     * 如果链表无环：返回null
     * @return
     */
    public static Node getLoopNode(Node head) {
        if (head == null || head.next == null || head.next.next == null) {
            return null;
        }
        Node n1 = head.next; // n1 -> slow
        Node n2 = head.next.next; // n2 -> fast
        while (n1 != n2) {
            if (n2.next == null || n2.next.next == null) {
                return null;
            }
            n2 = n2.next.next;
            n1 = n1.next;
        }
        n2 = head; // n2 -> walk again from head
        while (n1 != n2) {
            n1 = n1.next;
            n2 = n2.next;
        }
        return n1;
    }

    /**
     * 两个无环链表的相交问题
     * @param head1 链表1
     * @param head2 链表2
     * @return  返回第一个相交节点
     */
    public static Node noLoop(Node head1, Node head2) {
        if (head1 == null || head2 == null) {
            return null;
        }
        Node cur1 = head1;
        Node cur2 = head2;
        int n = 0;
        while (cur1.next != null) {
            n++;
            cur1 = cur1.next;
        }
        while (cur2.next != null) {
            n--;
            cur2 = cur2.next;
        }
        if (cur1 != cur2) {//一个链表的最后一个节点和另外一个链表的最后一个节点都不相等，他们不可能相交。
            return null;
        }
        //如果head1有100个节点，head2有80个节点，那么head1先走20步，然后一起走，
        //那么他俩一定会共同走到相交的节点处
        cur1 = n > 0 ? head1 : head2;//cur1指向需要先走的那个链表。
        cur2 = cur1 == head1 ? head2 : head1;
        n = Math.abs(n);
        while (n != 0) {
            n--;
            cur1 = cur1.next;
        }
        while (cur1 != cur2) {//再次走到同一个节点的时候，这个节点就是第一个相交节点。
            cur1 = cur1.next;
            cur2 = cur2.next;
        }
        return cur1;
    }

    /**
     *  两个有环链表的相交问题。
     * @param head1 链表1的头节点
     * @param loop1 链表1的入环节点
     * @param head2 链表2的头节点
     * @param loop2 链表2的入环节点
     * @return  第一个相交节点
     * 看图片
     */
    public static Node bothLoop(Node head1, Node loop1, Node head2, Node loop2) {
        Node cur1 = null;
        Node cur2 = null;
        if (loop1 == loop2) {//第二种情况，和两个无环链表的相交问题相同。只是以loop1和loop2做结尾。
            cur1 = head1;
            cur2 = head2;
            int n = 0;
            while (cur1 != loop1) {
                n++;
                cur1 = cur1.next;
            }
            while (cur2 != loop2) {
                n--;
                cur2 = cur2.next;
            }
            cur1 = n > 0 ? head1 : head2;
            cur2 = cur1 == head1 ? head2 : head1;
            n = Math.abs(n);
            while (n != 0) {
                n--;
                cur1 = cur1.next;
            }
            while (cur1 != cur2) {
                cur1 = cur1.next;
                cur2 = cur2.next;
            }
            return cur1;
        } else {//可能是第一种情况或者是第三种情况。
            cur1 = loop1.next;
            while (cur1 != loop1) {//让loop1一直以next的方式一直往下走，如果直到回到自己还没有遇到loop2，就是第一种情况，
                if (cur1 == loop2) {              //如果遇到loop2了就是第三种情况。
                    return loop1;       //第三种情况返回loop1还是loop2都可以，loop1距离head1近。loop2距离head2近
                }
                cur1 = cur1.next;
            }
            return null;
        }
    }
    public static void main(String[] args) {
        // 1->2->3->4->5->6->7->null
        Node head1 = new Node(1);
        head1.next = new Node(2);
        head1.next.next = new Node(3);
        head1.next.next.next = new Node(4);
        head1.next.next.next.next = new Node(5);
        head1.next.next.next.next.next = new Node(6);
        head1.next.next.next.next.next.next = new Node(7);

        // 0->9->8->6->7->null
        Node head2 = new Node(0);
        head2.next = new Node(9);
        head2.next.next = new Node(8);
        head2.next.next.next = head1.next.next.next.next.next; // 8->6
        System.out.println(getIntersectNode(head1, head2).value);

        // 1->2->3->4->5->6->7->4...
        head1 = new Node(1);
        head1.next = new Node(2);
        head1.next.next = new Node(3);
        head1.next.next.next = new Node(4);
        head1.next.next.next.next = new Node(5);
        head1.next.next.next.next.next = new Node(6);
        head1.next.next.next.next.next.next = new Node(7);
        head1.next.next.next.next.next.next = head1.next.next.next; // 7->4

        // 0->9->8->2...
        head2 = new Node(0);
        head2.next = new Node(9);
        head2.next.next = new Node(8);
        head2.next.next.next = head1.next; // 8->2
        System.out.println(getIntersectNode(head1, head2).value);

        // 0->9->8->6->4->5->6..
        head2 = new Node(0);
        head2.next = new Node(9);
        head2.next.next = new Node(8);
        head2.next.next.next = head1.next.next.next.next.next; // 8->6
        System.out.println(getIntersectNode(head1, head2).value);
    }
}
```