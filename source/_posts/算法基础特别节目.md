---
title: 算法基础特别节目
categories:
  - leetcode
abbrlink: 8bd8430e
date: 2019-02-28 09:53:23
---



### 数组随机划分两部分，求|max_left-max_right|的最大值

已知一个整型数组arr，数组长度为size且size大于2，arr有size-1种 可以划分成左右两部分的方案。 比如： arr = {3, 2, 3, 4, 1, 2} 第1种划分左部分为[3]，右部分为[2, 3, 4, 1, 2] 第2种划分左部分为[3, 2]，右部分为[3, 4, 1, 2] 第3种划分左部分为[3, 2, 3]，右部分为[4, 1, 2] 第4种划分左部分为[3, 2, 3, 4]，右部分为[1, 2] 第5种划分左部分为[3, 2, 3, 4, 1]，右部分为[2]

每一种划分下，左部分都有最大值记为max_left，右部分都有最大值记 为max_right。 求|max_left-max_right|(左部分最大值与左部分最大值之差的绝对值)， 最大是多少？ 要求：时间复杂度为O(N)，额外空间复杂度O(1)。

<br/>

时间复杂度为O(N) 说明只能遍历有限次数；

<br/>

#### 暴力解法

遍历，每遍历到n，求n左边的最大值，和n右边的最大值，最后的时间复杂度为O(n^2)

<br/>

#### 优化：使用两个辅助数组，

一个辅助数组收集从0到n位置的最大值，另外一个辅助数组收集从n位置到N-1位置的最大值，然后两个数组对应的位置相减即可；

{% asset_img picture1.jpg %}

<br/>

#### 最优解

遍历一遍找到最大值max，然后看0位置和N-1位置的数字哪个小，用max减去较小的值；就是答案

<br/>

原理：

首先，最终的结果肯定是max减去某个数；废话，因为max肯定属于左右两边中的一边，肯定它是被减数；

如果max被划分在了左部分，因为右边肯定包含N-1位置的数，如果右边数组有多个数字，那么右边数组产生的最大值肯定不会比N-1位置的数小，所以要想让右边数组产生的最大值比较小的话，就必须要划在N-1的位置；所以最终的结果就是max-(N-1位置的数字)，

如果max被划分在了右部分，那么同理，左边产生的最大值肯定不会比0位置的数小，所以就必须划在第一个数后面的位置，让左边产生的最大值只能是0位置的数字，那么最终结果就是：是max-(0位置的数字)；

{% asset_img picture2.jpg %}

<br/>

#### 重点：

预处理数组的技巧，笨办法弱点在于左边遍历，右边遍历，相减求最大值；于是我们想到：我们想查询的这个需求，是否可以提前处理好，方便使用；这是很多题目的处理技巧；

<br/>

最优解的套路：

特殊的条件：都是正数，都是大于某个数的数字

特殊的结果标准：求|max_left-max_right|的最大值

要充分利用这些特殊条件：

<br/>

#### 代码

```java
public class Code_02_MaxABSBetweenLeftAndRight {

	public static int maxABS1(int[] arr) {
		int res = Integer.MIN_VALUE;
		int maxLeft = 0;
		int maxRight = 0;
		for (int i = 0; i != arr.length - 1; i++) {
			maxLeft = Integer.MIN_VALUE;
			for (int j = 0; j != i + 1; j++) {
				maxLeft = Math.max(arr[j], maxLeft);
			}
			maxRight = Integer.MIN_VALUE;
			for (int j = i + 1; j != arr.length; j++) {
				maxRight = Math.max(arr[j], maxRight);
			}
			res = Math.max(Math.abs(maxLeft - maxRight), res);
		}
		return res;
	}

	public static int maxABS2(int[] arr) {
		int[] lArr = new int[arr.length];
		int[] rArr = new int[arr.length];
		lArr[0] = arr[0];
		rArr[arr.length - 1] = arr[arr.length - 1];
		for (int i = 1; i < arr.length; i++) {
			lArr[i] = Math.max(lArr[i - 1], arr[i]);
		}
		for (int i = arr.length - 2; i > -1; i--) {
			rArr[i] = Math.max(rArr[i + 1], arr[i]);
		}
		int max = 0;
		for (int i = 0; i < arr.length - 1; i++) {
			max = Math.max(max, Math.abs(lArr[i] - rArr[i + 1]));
		}
		return max;
	}

	public static int maxABS3(int[] arr) {
		int max = Integer.MIN_VALUE;
		for (int i = 0; i < arr.length; i++) {
			max = Math.max(arr[i], max);
		}
		return max - Math.min(arr[0], arr[arr.length - 1]);
	}

	public static int[] generateRandomArray(int length) {
		int[] arr = new int[length];
		for (int i = 0; i != arr.length; i++) {
			arr[i] = (int) (Math.random() * 1000) - 499;
		}
		return arr;
	}

	public static void main(String[] args) {
		int[] arr = generateRandomArray(200);
		System.out.println(maxABS1(arr));
		System.out.println(maxABS2(arr));
		System.out.println(maxABS3(arr));
	}
}
```

<br/>

<br/>

### 求局部最小

定义局部最小的概念。arr长度为1时，arr[0]是局部最小。arr的长度 为N(N>1)时，如果arr[0]<arr[1]，那么arr[0]是局部最小；如果 arr[N-1]<arr[N-2]，那么arr[N-1]是局部最小；如果0<i<N-1，既有 arr[i]<arr[i-1]，又有arr[i]<arr[i+1]，那么arr[i]是局部最小。 给定无序数组arr，已知arr中任意两个相邻的数都不相等。写一个函 数，只需返回arr中任意一个局部最小出现的位置即可。

{% asset_img picture3.jpg %}

<br/>

暴力方法：

遍历一遍，时间复杂度为O(N)

<br/>

优化：

如果0位置的数字比1位置小，那么直接返回0位置，如果N-1位置比N-2位置小，直接返回N-1位置；

因为任意相邻数不相等，所以：中间一定有局部最小，因为从左到右是依次减小的，从右到左也是依次减小的，那么从左到右整体就是先减少再递增的过程，那么肯定有局部最小值；

因为这是一个对勾形状的函数啊，最底层的内个点肯定就是局部最小啊， 比左边的小，比右边的小；

二分找到中间的m位置之后，判断m和m-1位置上的数哪个大；如果m比m-1位置上的数大，那么从0到m-1又是整体先下降再上升的过程，这之间肯定有局部最小；继续二分查找下去即可；

{% asset_img picture5.jpg %}

<br/>

总结：

二分不是必须要有序的，只要符合01标准的都可以使用二分；即：只要保证左右两边，某一边肯定有我们想要找的值，都可以用二分；

<br/>

代码：

```java
public class Code_03_FindOneLessValueIndex {

	public static int getLessIndex(int[] arr) {
		if (arr == null || arr.length == 0) {
			return -1; // no exist
		}
		if (arr.length == 1 || arr[0] < arr[1]) {
			return 0;
		}
		if (arr[arr.length - 1] < arr[arr.length - 2]) {
			return arr.length - 1;
		}
		int left = 1;
		int right = arr.length - 2;
		int mid = 0;
		while (left < right) {
			mid = (left + right) / 2;
			if (arr[mid] > arr[mid - 1]) {
				right = mid - 1;
			} else if (arr[mid] > arr[mid + 1]) {
				left = mid + 1;
			} else {
				return mid;
			}
		}
		return left;
	}

	public static void printArray(int[] arr) {
		for (int i = 0; i != arr.length; i++) {
			System.out.print(arr[i] + " ");
		}
		System.out.println();
	}

	public static void main(String[] args) {
		int[] arr = { 6, 5, 3, 4, 6, 7, 8 };
		printArray(arr);
		int index = getLessIndex(arr);
		System.out.println("index: " + index + ", value: " + arr[index]);

	}
}
```

<br/>

<br/>

### 折纸问题

请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压 出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背 面。如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有 三条折痕，从上到下依次是下折痕、下折痕和上折痕。给定一个输入参 数N，代表纸条都从下边向上方连续对折N次，请从上到下打印所有折痕 的方向。 例如：N=1时，打印： down N=2时，打印： down down up

<br/>

思路：

每次对折，在上次折痕的上方出现一个下折痕，在上次折痕的下方出现一个上折痕；所以：最后的结果是一颗二叉树；而且最终的结果就是把树压扁，然后打印的过程，也就是中序遍历的过程

{% asset_img picture4.jpg %}

<br/>

不断复用递归这个结构，来完成打印；实现方面和二叉树没有关系；

<br/>

代码：

```java
public class Code_04_PaperFolding {
	public static void printAllFolds(int N) {
		printProcess(1, N, true);
	}

	/**
	 * @param i  第几层
	 * @param N  总共几层
	 * @param down  true表示下，false 表示上
	 */
	public static void printProcess(int i, int N, boolean down) {
		if (i > N) {
			return;
		}
		printProcess(i + 1, N, true);
		System.out.println(down ? "down " : "up ");
		printProcess(i + 1, N, false);
	}

	public static void main(String[] args) {
		int N = 4;
		printAllFolds(N);
	}
}
```